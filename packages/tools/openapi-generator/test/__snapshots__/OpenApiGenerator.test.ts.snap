// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`OpenApiGenerator > type-only > get operation 1`] = `
"import * as Data from "effect/data/Data"
import * as Effect from "effect/Effect"
import type { SchemaError } from "effect/schema/Schema"
import * as Schema from "effect/schema/Schema"
import type * as HttpClient from "effect/unstable/http/HttpClient"
import * as HttpClientError from "effect/unstable/http/HttpClientError"
import * as HttpClientRequest from "effect/unstable/http/HttpClientRequest"
import * as HttpClientResponse from "effect/unstable/http/HttpClientResponse"
import { HttpApiSchemaError } from "effect/unstable/httpapi/HttpApiError"

export type ComponentsSchema = { readonly "contentType": string, readonly "length": number }
export type ComponentsSchemaEncoded = ComponentsSchema
export const ComponentsSchema = Schema.Struct({ "contentType": Schema.String, "length": Schema.Int }).annotate({ "identifier": "ComponentsSchema" })

export type Group = { readonly "id": number, readonly "name": string }
export type GroupEncoded = Group
export const Group = Schema.Struct({ "id": Schema.Int, "name": Schema.String }).annotate({ "identifier": "Group" })

export type PersistedFile = string
export type PersistedFileEncoded = PersistedFile
export const PersistedFile = Schema.String.annotate({ "format": "binary" }).annotate({ "identifier": "PersistedFile" })

export type User = { readonly "id": number, readonly "uuid"?: string, readonly "name": string, 
/** a string that will be decoded as a DateTime.Utc */
readonly "createdAt": string }
export type UserEncoded = User
export const User = Schema.Struct({ "id": Schema.Int, "uuid": Schema.optionalKey(Schema.String), "name": Schema.String, "createdAt": Schema.String.annotate({ "description": "a string that will be decoded as a DateTime.Utc" }) }).annotate({ "identifier": "User" })

export type UserError = { readonly "_tag": "UserError" }
export type UserErrorEncoded = UserError
export const UserError = Schema.Struct({ "_tag": Schema.Literal("UserError") }).annotate({ "identifier": "UserError" })

export type NoStatusError = { readonly "_tag": "NoStatusError" }
export type NoStatusErrorEncoded = NoStatusError
export const NoStatusError = Schema.Struct({ "_tag": Schema.Literal("NoStatusError") }).annotate({ "identifier": "NoStatusError" })

export type GroupsFindById200 = Group
export type GroupsFindById200Encoded = GroupEncoded
export const GroupsFindById200 = Group

export type GroupsFindById400 = typeof HttpApiSchemaError["Type"]
export type GroupsFindById400Encoded = typeof HttpApiSchemaError["Encoded"]
export const GroupsFindById400 = HttpApiSchemaError

export type UsersFindById200 = User
export type UsersFindById200Encoded = UserEncoded
export const UsersFindById200 = User

export type UsersFindById400 = typeof HttpApiSchemaError["Type"] | UserError
export type UsersFindById400Encoded = typeof HttpApiSchemaError["Encoded"] | UserErrorEncoded
export const UsersFindById400 = Schema.Union([HttpApiSchemaError, UserError])

export type ListUsersParams = { 
/** a string that will be decoded as a finite number */
readonly "page"?: string, 
/** search query */
readonly "query"?: string }
export type ListUsersParamsEncoded = ListUsersParams
export const ListUsersParams = Schema.Struct({ "page": Schema.optionalKey(Schema.String.annotate({ "description": "a string that will be decoded as a finite number" })), "query": Schema.optionalKey(Schema.String.annotate({ "description": "search query" })) })

export type ListUsers200 = ReadonlyArray<User>
export type ListUsers200Encoded = ReadonlyArray<UserEncoded>
export const ListUsers200 = Schema.Array(User)

export type ListUsers400 = typeof HttpApiSchemaError["Type"]
export type ListUsers400Encoded = typeof HttpApiSchemaError["Encoded"]
export const ListUsers400 = HttpApiSchemaError

export type ListUsers500 = NoStatusError
export type ListUsers500Encoded = NoStatusErrorEncoded
export const ListUsers500 = NoStatusError

export type Healthz400 = typeof HttpApiSchemaError["Type"]
export type Healthz400Encoded = typeof HttpApiSchemaError["Encoded"]
export const Healthz400 = HttpApiSchemaError

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): TestClient => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse: <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ) => (
    request: HttpClientRequest.HttpClientRequest,
  ) => Effect.Effect<any, any> = options.transformClient
    ? (f) => (request) =>
        Effect.flatMap(
          Effect.flatMap(options.transformClient!(httpClient), (client) =>
            client.execute(request),
          ),
          f,
        )
    : (f) => (request) => Effect.flatMap(httpClient.execute(request), f)
  const decodeSuccess =
    <Schema extends Schema.Top>(schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, Schema extends Schema.Top>(tag: Tag, schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(TestClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "groupsFindById": (id) => HttpClientRequest.get(\`/groups/\${id}\`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GroupsFindById200),
      "400": decodeError("GroupsFindById400", GroupsFindById400),
      "418": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "usersFindById": (id) => HttpClientRequest.get(\`/users/\${id}\`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UsersFindById200),
      "400": decodeError("UsersFindById400", UsersFindById400),
      orElse: unexpectedStatus
    }))
  ),
  "listUsers": (options) => HttpClientRequest.get(\`/users\`).pipe(
    HttpClientRequest.setUrlParams({ "query": options?.["query"] as any }),
    HttpClientRequest.setHeaders({ "page": options?.["page"] ?? undefined }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListUsers200),
      "400": decodeError("ListUsers400", ListUsers400),
      "500": decodeError("ListUsers500", ListUsers500),
      orElse: unexpectedStatus
    }))
  ),
  "healthz": () => HttpClientRequest.get(\`/healthz\`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "400": decodeError("Healthz400", Healthz400),
      "204": () => Effect.void,
      orElse: unexpectedStatus
    }))
  )
  }
}

export interface TestClient {
  readonly httpClient: HttpClient.HttpClient
  readonly "groupsFindById": (id: string) => Effect.Effect<typeof GroupsFindById200.Type, HttpClientError.HttpClientError | SchemaError | TestClientError<"GroupsFindById400", typeof GroupsFindById400.Type>>
  readonly "usersFindById": (id: string) => Effect.Effect<typeof UsersFindById200.Type, HttpClientError.HttpClientError | SchemaError | TestClientError<"UsersFindById400", typeof UsersFindById400.Type>>
  /**
* test summary
*/
readonly "listUsers": (options?: typeof ListUsersParams.Encoded | undefined) => Effect.Effect<typeof ListUsers200.Type, HttpClientError.HttpClientError | SchemaError | TestClientError<"ListUsers400", typeof ListUsers400.Type> | TestClientError<"ListUsers500", typeof ListUsers500.Type>>
  readonly "healthz": () => Effect.Effect<void, HttpClientError.HttpClientError | SchemaError | TestClientError<"Healthz400", typeof Healthz400.Type>>
}

export interface TestClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class TestClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const TestClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): TestClientError<Tag, E> =>
  new TestClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any"
`;

exports[`OpenApiGenerator > type-only > get operation 2`] = `
"import * as Data from "effect/data/Data"
import * as Effect from "effect/Effect"
import type { SchemaError } from "effect/schema/Schema"
import * as Schema from "effect/schema/Schema"
import type * as HttpClient from "effect/unstable/http/HttpClient"
import * as HttpClientError from "effect/unstable/http/HttpClientError"
import * as HttpClientRequest from "effect/unstable/http/HttpClientRequest"
import * as HttpClientResponse from "effect/unstable/http/HttpClientResponse"



/** User object */
export type GetUser200 = { readonly "id": string, readonly "name": string }
export type GetUser200Encoded = GetUser200

/** User object */
export const GetUser200 = Schema.Struct({ "id": Schema.String, "name": Schema.String }).annotate({ "description": "User object" })

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): TestClient => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse: <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ) => (
    request: HttpClientRequest.HttpClientRequest,
  ) => Effect.Effect<any, any> = options.transformClient
    ? (f) => (request) =>
        Effect.flatMap(
          Effect.flatMap(options.transformClient!(httpClient), (client) =>
            client.execute(request),
          ),
          f,
        )
    : (f) => (request) => Effect.flatMap(httpClient.execute(request), f)
  const decodeSuccess =
    <Schema extends Schema.Top>(schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, Schema extends Schema.Top>(tag: Tag, schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(TestClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "getUser": (id) => HttpClientRequest.get(\`/users/\${id}\`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetUser200),
      orElse: unexpectedStatus
    }))
  )
  }
}

export interface TestClient {
  readonly httpClient: HttpClient.HttpClient
  readonly "getUser": (id: string) => Effect.Effect<typeof GetUser200.Type, HttpClientError.HttpClientError | SchemaError>
}

export interface TestClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class TestClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const TestClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): TestClientError<Tag, E> =>
  new TestClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any"
`;

exports[`OpenApiGenerator > type-only > get operation 3`] = `
"import * as Data from "effect/data/Data"
import * as Effect from "effect/Effect"
import type * as HttpClient from "effect/unstable/http/HttpClient"
import * as HttpClientError from "effect/unstable/http/HttpClientError"
import * as HttpClientRequest from "effect/unstable/http/HttpClientRequest"
import * as HttpClientResponse from "effect/unstable/http/HttpClientResponse"


export type GetUser200 = { readonly "id": string, readonly "name": string }
export type GetUser200Encoded = GetUser200

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): TestClient => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse: <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ) => (
    request: HttpClientRequest.HttpClientRequest,
  ) => Effect.Effect<any, any> = options.transformClient
    ? (f) => (request) =>
        Effect.flatMap(
          Effect.flatMap(options.transformClient!(httpClient), (client) =>
            client.execute(request),
          ),
          f,
        )
    : (f) => (request) => Effect.flatMap(httpClient.execute(request), f)
  const decodeSuccess = <A>(response: HttpClientResponse.HttpClientResponse) =>
    response.json as Effect.Effect<A, HttpClientError.ResponseError>
  const decodeVoid = (_response: HttpClientResponse.HttpClientResponse) =>
    Effect.void
  const decodeError =
    <Tag extends string, E>(tag: Tag) =>
    (
      response: HttpClientResponse.HttpClientResponse,
    ): Effect.Effect<
      never,
      TestClientError<Tag, E> | HttpClientError.ResponseError
    > =>
      Effect.flatMap(
        response.json as Effect.Effect<E, HttpClientError.ResponseError>,
        (cause) => Effect.fail(TestClientError(tag, cause, response)),
      )
  const onRequest = (
    successCodes: ReadonlyArray<string>,
    errorCodes?: Record<string, string>,
  ) => {
    const cases: any = { orElse: unexpectedStatus }
    for (const code of successCodes) {
      cases[code] = decodeSuccess
    }
    if (errorCodes) {
      for (const [code, tag] of Object.entries(errorCodes)) {
        cases[code] = decodeError(tag)
      }
    }
    if (successCodes.length === 0) {
      cases["2xx"] = decodeVoid
    }
    return withResponse(HttpClientResponse.matchStatus(cases) as any)
  }
  return {
    httpClient,
    "getUser": (id) => HttpClientRequest.get(\`/users/\${id}\`).pipe(
    onRequest(["2xx"])
  )
  }
}

export interface TestClient {
  readonly httpClient: HttpClient.HttpClient
  readonly "getUser": (id: string) => Effect.Effect<GetUser200, HttpClientError.HttpClientError>
}

export interface TestClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class TestClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const TestClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): TestClientError<Tag, E> =>
  new TestClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any"
`;
