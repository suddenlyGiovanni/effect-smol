// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`OpenApiGenerator > identifier sanitization > handles collision when sanitized name already exists 1`] = `
"import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type { SchemaError } from "effect/Schema"
import * as Schema from "effect/Schema"
import type * as HttpClient from "effect/unstable/http/HttpClient"
import * as HttpClientError from "effect/unstable/http/HttpClientError"
import * as HttpClientRequest from "effect/unstable/http/HttpClientRequest"
import * as HttpClientResponse from "effect/unstable/http/HttpClientResponse"
// non-recursive definitions
export type AddUploadPartRequest = { readonly "data": string }
export const AddUploadPartRequest = Schema.Struct({ "data": Schema.String.annotate({ "description": "The chunk of bytes for this Part.\\n", "format": "binary" }) }).annotate({ "identifier": "AddUploadPartRequest" })
export type AdminApiKey = { readonly "object": string, readonly "id": string, readonly "name": string, readonly "redacted_value": string, readonly "value"?: string, readonly "created_at": number, readonly "last_used_at": number | null, readonly "owner": { readonly "type"?: string, readonly "object"?: string, readonly "id"?: string, readonly "name"?: string, readonly "created_at"?: number, readonly "role"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const AdminApiKey = Schema.StructWithRest(Schema.Struct({ "object": Schema.String.annotate({ "description": "The object type, which is always \`organization.admin_api_key\`" }), "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }), "name": Schema.String.annotate({ "description": "The name of the API key" }), "redacted_value": Schema.String.annotate({ "description": "The redacted value of the API key" }), "value": Schema.optionalKey(Schema.String.annotate({ "description": "The value of the API key. Only shown on create." })), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the API key was created", "format": "int64" }).check(Schema.isInt()), "last_used_at": Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the API key was last used", "format": "int64" }).check(Schema.isInt()), Schema.Null]), "owner": Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "Always \`user\`" })), "object": Schema.optionalKey(Schema.String.annotate({ "description": "The object type, which is always organization.user" })), "id": Schema.optionalKey(Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the user" })), "created_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the user was created", "format": "int64" }).check(Schema.isInt())), "role": Schema.optionalKey(Schema.String.annotate({ "description": "Always \`owner\`" })) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents an individual Admin API key in an org.", "identifier": "AdminApiKey" })
export type AssignedRoleDetails = { readonly "id": string, readonly "name": string, readonly "permissions": ReadonlyArray<string>, readonly "resource_type": string, readonly "predefined_role": boolean, readonly "description": string | null, readonly "created_at": number | null, readonly "updated_at": number | null, readonly "created_by": string | null, readonly "created_by_user_obj": { readonly [x: string]: unknown } | null, readonly "metadata": { readonly [x: string]: unknown } | null, readonly [x: string]: unknown }
export const AssignedRoleDetails = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier for the role." }), "name": Schema.String.annotate({ "description": "Name of the role." }), "permissions": Schema.Array(Schema.String).annotate({ "description": "Permissions associated with the role." }), "resource_type": Schema.String.annotate({ "description": "Resource type the role applies to." }), "predefined_role": Schema.Boolean.annotate({ "description": "Whether the role is predefined by OpenAI." }), "description": Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Description of the role." }), "created_at": Schema.Union([Schema.Number.annotate({ "format": "int64" }).check(Schema.isInt()), Schema.Null]).annotate({ "description": "When the role was created." }), "updated_at": Schema.Union([Schema.Number.annotate({ "format": "int64" }).check(Schema.isInt()), Schema.Null]).annotate({ "description": "When the role was last updated." }), "created_by": Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Identifier of the actor who created the role." }), "created_by_user_obj": Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "User details for the actor that created the role, when available." }), "metadata": Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "Arbitrary metadata stored on the role." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Detailed information about a role assignment entry returned when listing assignments.", "identifier": "AssignedRoleDetails" })
export type AssistantSupportedModels = "gpt-5" | "gpt-5-mini" | "gpt-5-nano" | "gpt-5-2025-08-07" | "gpt-5-mini-2025-08-07" | "gpt-5-nano-2025-08-07" | "gpt-4.1" | "gpt-4.1-mini" | "gpt-4.1-nano" | "gpt-4.1-2025-04-14" | "gpt-4.1-mini-2025-04-14" | "gpt-4.1-nano-2025-04-14" | "o3-mini" | "o3-mini-2025-01-31" | "o1" | "o1-2024-12-17" | "gpt-4o" | "gpt-4o-2024-11-20" | "gpt-4o-2024-08-06" | "gpt-4o-2024-05-13" | "gpt-4o-mini" | "gpt-4o-mini-2024-07-18" | "gpt-4.5-preview" | "gpt-4.5-preview-2025-02-27" | "gpt-4-turbo" | "gpt-4-turbo-2024-04-09" | "gpt-4-0125-preview" | "gpt-4-turbo-preview" | "gpt-4-1106-preview" | "gpt-4-vision-preview" | "gpt-4" | "gpt-4-0314" | "gpt-4-0613" | "gpt-4-32k" | "gpt-4-32k-0314" | "gpt-4-32k-0613" | "gpt-3.5-turbo" | "gpt-3.5-turbo-16k" | "gpt-3.5-turbo-0613" | "gpt-3.5-turbo-1106" | "gpt-3.5-turbo-0125" | "gpt-3.5-turbo-16k-0613"
export const AssistantSupportedModels = Schema.Literals(["gpt-5", "gpt-5-mini", "gpt-5-nano", "gpt-5-2025-08-07", "gpt-5-mini-2025-08-07", "gpt-5-nano-2025-08-07", "gpt-4.1", "gpt-4.1-mini", "gpt-4.1-nano", "gpt-4.1-2025-04-14", "gpt-4.1-mini-2025-04-14", "gpt-4.1-nano-2025-04-14", "o3-mini", "o3-mini-2025-01-31", "o1", "o1-2024-12-17", "gpt-4o", "gpt-4o-2024-11-20", "gpt-4o-2024-08-06", "gpt-4o-2024-05-13", "gpt-4o-mini", "gpt-4o-mini-2024-07-18", "gpt-4.5-preview", "gpt-4.5-preview-2025-02-27", "gpt-4-turbo", "gpt-4-turbo-2024-04-09", "gpt-4-0125-preview", "gpt-4-turbo-preview", "gpt-4-1106-preview", "gpt-4-vision-preview", "gpt-4", "gpt-4-0314", "gpt-4-0613", "gpt-4-32k", "gpt-4-32k-0314", "gpt-4-32k-0613", "gpt-3.5-turbo", "gpt-3.5-turbo-16k", "gpt-3.5-turbo-0613", "gpt-3.5-turbo-1106", "gpt-3.5-turbo-0125", "gpt-3.5-turbo-16k-0613"]).annotate({ "identifier": "AssistantSupportedModels" })
export type AssistantToolsCode = { readonly "type": "code_interpreter", readonly [x: string]: unknown }
export const AssistantToolsCode = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("code_interpreter").annotate({ "description": "The type of tool being defined: \`code_interpreter\`" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code interpreter tool", "identifier": "AssistantToolsCode" })
export type AssistantToolsFileSearchTypeOnly = { readonly "type": "file_search", readonly [x: string]: unknown }
export const AssistantToolsFileSearchTypeOnly = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file_search").annotate({ "description": "The type of tool being defined: \`file_search\`" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "AssistantToolsFileSearchTypeOnly", "identifier": "AssistantToolsFileSearchTypeOnly" })
export type AssistantsNamedToolChoice = { readonly "type": "function" | "code_interpreter" | "file_search", readonly "function"?: { readonly "name": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const AssistantsNamedToolChoice = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literals(["function", "code_interpreter", "file_search"]).annotate({ "description": "The type of the tool. If type is \`function\`, the function name must be set" }), "function": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function to call." }) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Specifies a tool the model should use. Use to force the model to call a specific tool.", "identifier": "AssistantsNamedToolChoice" })
export type AudioResponseFormat = "json" | "text" | "srt" | "verbose_json" | "vtt" | "diarized_json"
export const AudioResponseFormat = Schema.Literals(["json", "text", "srt", "verbose_json", "vtt", "diarized_json"]).annotate({ "description": "The format of the output, in one of these options: \`json\`, \`text\`, \`srt\`, \`verbose_json\`, \`vtt\`, or \`diarized_json\`. For \`gpt-4o-transcribe\` and \`gpt-4o-mini-transcribe\`, the only supported format is \`json\`. For \`gpt-4o-transcribe-diarize\`, the supported formats are \`json\`, \`text\`, and \`diarized_json\`, with \`diarized_json\` required to receive speaker annotations.\\n", "default": "json", "identifier": "AudioResponseFormat" })
export type AudioTranscription = { readonly "model"?: string | "whisper-1" | "gpt-4o-mini-transcribe" | "gpt-4o-mini-transcribe-2025-12-15" | "gpt-4o-transcribe" | "gpt-4o-transcribe-diarize", readonly "language"?: string, readonly "prompt"?: string, readonly [x: string]: unknown }
export const AudioTranscription = Schema.StructWithRest(Schema.Struct({ "model": Schema.optionalKey(Schema.Union([Schema.String, Schema.Literals(["whisper-1", "gpt-4o-mini-transcribe", "gpt-4o-mini-transcribe-2025-12-15", "gpt-4o-transcribe", "gpt-4o-transcribe-diarize"])]).annotate({ "description": "The model to use for transcription. Current options are \`whisper-1\`, \`gpt-4o-mini-transcribe\`, \`gpt-4o-mini-transcribe-2025-12-15\`, \`gpt-4o-transcribe\`, and \`gpt-4o-transcribe-diarize\`. Use \`gpt-4o-transcribe-diarize\` when you need diarization with speaker labels.\\n" })), "language": Schema.optionalKey(Schema.String.annotate({ "description": "The language of the input audio. Supplying the input language in\\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. \`en\`) format\\nwill improve accuracy and latency.\\n" })), "prompt": Schema.optionalKey(Schema.String.annotate({ "description": "An optional text to guide the model's style or continue a previous audio\\nsegment.\\nFor \`whisper-1\`, the [prompt is a list of keywords](https://platform.openai.com/docs/guides/speech-to-text#prompting).\\nFor \`gpt-4o-transcribe\` models (excluding \`gpt-4o-transcribe-diarize\`), the prompt is a free text string, for example \\"expect words related to technology\\".\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "AudioTranscription" })
export type AuditLogActorServiceAccount = { readonly "id"?: string, readonly [x: string]: unknown }
export const AuditLogActorServiceAccount = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The service account id." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The service account that performed the audit logged action.", "identifier": "AuditLogActorServiceAccount" })
export type AuditLogActorUser = { readonly "id"?: string, readonly "email"?: string, readonly [x: string]: unknown }
export const AuditLogActorUser = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The user id." })), "email": Schema.optionalKey(Schema.String.annotate({ "description": "The user email." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The user who performed the audit logged action.", "identifier": "AuditLogActorUser" })
export type AuditLogEventType = "api_key.created" | "api_key.updated" | "api_key.deleted" | "certificate.created" | "certificate.updated" | "certificate.deleted" | "certificates.activated" | "certificates.deactivated" | "checkpoint.permission.created" | "checkpoint.permission.deleted" | "external_key.registered" | "external_key.removed" | "group.created" | "group.updated" | "group.deleted" | "invite.sent" | "invite.accepted" | "invite.deleted" | "ip_allowlist.created" | "ip_allowlist.updated" | "ip_allowlist.deleted" | "ip_allowlist.config.activated" | "ip_allowlist.config.deactivated" | "login.succeeded" | "login.failed" | "logout.succeeded" | "logout.failed" | "organization.updated" | "project.created" | "project.updated" | "project.archived" | "project.deleted" | "rate_limit.updated" | "rate_limit.deleted" | "resource.deleted" | "tunnel.created" | "tunnel.updated" | "tunnel.deleted" | "role.created" | "role.updated" | "role.deleted" | "role.assignment.created" | "role.assignment.deleted" | "scim.enabled" | "scim.disabled" | "service_account.created" | "service_account.updated" | "service_account.deleted" | "user.added" | "user.updated" | "user.deleted"
export const AuditLogEventType = Schema.Literals(["api_key.created", "api_key.updated", "api_key.deleted", "certificate.created", "certificate.updated", "certificate.deleted", "certificates.activated", "certificates.deactivated", "checkpoint.permission.created", "checkpoint.permission.deleted", "external_key.registered", "external_key.removed", "group.created", "group.updated", "group.deleted", "invite.sent", "invite.accepted", "invite.deleted", "ip_allowlist.created", "ip_allowlist.updated", "ip_allowlist.deleted", "ip_allowlist.config.activated", "ip_allowlist.config.deactivated", "login.succeeded", "login.failed", "logout.succeeded", "logout.failed", "organization.updated", "project.created", "project.updated", "project.archived", "project.deleted", "rate_limit.updated", "rate_limit.deleted", "resource.deleted", "tunnel.created", "tunnel.updated", "tunnel.deleted", "role.created", "role.updated", "role.deleted", "role.assignment.created", "role.assignment.deleted", "scim.enabled", "scim.disabled", "service_account.created", "service_account.updated", "service_account.deleted", "user.added", "user.updated", "user.deleted"]).annotate({ "description": "The event type.", "identifier": "AuditLogEventType" })
export type AutoChunkingStrategyRequestParam = { readonly "type": "auto" }
export const AutoChunkingStrategyRequestParam = Schema.Struct({ "type": Schema.Literal("auto").annotate({ "description": "Always \`auto\`." }) }).annotate({ "title": "Auto Chunking Strategy", "description": "The default strategy. This strategy currently uses a \`max_chunk_size_tokens\` of \`800\` and \`chunk_overlap_tokens\` of \`400\`.", "identifier": "AutoChunkingStrategyRequestParam" })
export type BatchFileExpirationAfter = { readonly "anchor": "created_at", readonly "seconds": number, readonly [x: string]: unknown }
export const BatchFileExpirationAfter = Schema.StructWithRest(Schema.Struct({ "anchor": Schema.Literal("created_at").annotate({ "description": "Anchor timestamp after which the expiration policy applies. Supported anchors: \`created_at\`. Note that the anchor is the file creation time, not the time the batch is created." }), "seconds": Schema.Number.annotate({ "description": "The number of seconds after the anchor time that the file will expire. Must be between 3600 (1 hour) and 2592000 (30 days)." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File expiration policy", "description": "The expiration policy for the output and/or error file that are generated for a batch.", "identifier": "BatchFileExpirationAfter" })
export type BatchRequestInput = { readonly "custom_id"?: string, readonly "method"?: "POST", readonly "url"?: string, readonly [x: string]: unknown }
export const BatchRequestInput = Schema.StructWithRest(Schema.Struct({ "custom_id": Schema.optionalKey(Schema.String.annotate({ "description": "A developer-provided per-request id that will be used to match outputs to inputs. Must be unique for each request in a batch." })), "method": Schema.optionalKey(Schema.Literal("POST").annotate({ "description": "The HTTP method to be used for the request. Currently only \`POST\` is supported." })), "url": Schema.optionalKey(Schema.String.annotate({ "description": "The OpenAI API relative URL to be used for the request. Currently \`/v1/responses\`, \`/v1/chat/completions\`, \`/v1/embeddings\`, \`/v1/completions\`, and \`/v1/moderations\` are supported." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The per-line object of the batch input file", "identifier": "BatchRequestInput" })
export type BatchRequestOutput = { readonly "id"?: string, readonly "custom_id"?: string, readonly "response"?: { readonly "status_code"?: number, readonly "request_id"?: string, readonly "body"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown } | null, readonly "error"?: { readonly "code"?: string, readonly "message"?: string, readonly [x: string]: unknown } | null, readonly [x: string]: unknown }
export const BatchRequestOutput = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String), "custom_id": Schema.optionalKey(Schema.String.annotate({ "description": "A developer-provided per-request id that will be used to match outputs to inputs." })), "response": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "status_code": Schema.optionalKey(Schema.Number.annotate({ "description": "The HTTP status code of the response" }).check(Schema.isInt())), "request_id": Schema.optionalKey(Schema.String.annotate({ "description": "An unique identifier for the OpenAI API request. Please include this request ID when contacting support." })), "body": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The JSON body of the response" })) }), [Schema.Record(Schema.String, Schema.Unknown)]), Schema.Null])), "error": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "code": Schema.optionalKey(Schema.String.annotate({ "description": "A machine-readable error code.\\n\\nPossible values:\\n- \`batch_expired\`: The request could not be executed before the\\n  completion window ended.\\n- \`batch_cancelled\`: The batch was cancelled before this request\\n  executed.\\n- \`request_timeout\`: The underlying call to the model timed out.\\n" })), "message": Schema.optionalKey(Schema.String.annotate({ "description": "A human-readable error message." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "For requests that failed with a non-HTTP error, this will contain more information on the cause of the failure." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The per-line object of the batch output and error files", "identifier": "BatchRequestOutput" })
export type Certificate = { readonly "object": "certificate" | "organization.certificate" | "organization.project.certificate", readonly "id": string, readonly "name": string, readonly "created_at": number, readonly "certificate_details": { readonly "valid_at"?: number, readonly "expires_at"?: number, readonly "content"?: string, readonly [x: string]: unknown }, readonly "active"?: boolean, readonly [x: string]: unknown }
export const Certificate = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literals(["certificate", "organization.certificate", "organization.project.certificate"]).annotate({ "description": "The object type.\\n\\n- If creating, updating, or getting a specific certificate, the object type is \`certificate\`.\\n- If listing, activating, or deactivating certificates for the organization, the object type is \`organization.certificate\`.\\n- If listing, activating, or deactivating certificates for a project, the object type is \`organization.project.certificate\`.\\n" }), "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }), "name": Schema.String.annotate({ "description": "The name of the certificate." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the certificate was uploaded." }).check(Schema.isInt()), "certificate_details": Schema.StructWithRest(Schema.Struct({ "valid_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the certificate becomes valid." }).check(Schema.isInt())), "expires_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the certificate expires." }).check(Schema.isInt())), "content": Schema.optionalKey(Schema.String.annotate({ "description": "The content of the certificate in PEM format." })) }), [Schema.Record(Schema.String, Schema.Unknown)]), "active": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Whether the certificate is currently active at the specified scope. Not returned when getting details for a specific certificate." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents an individual \`certificate\` uploaded to the organization.", "identifier": "Certificate" })
export type ChatCompletionAllowedTools = { readonly "mode": "auto" | "required", readonly "tools": ReadonlyArray<{ readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const ChatCompletionAllowedTools = Schema.StructWithRest(Schema.Struct({ "mode": Schema.Literals(["auto", "required"]).annotate({ "description": "Constrains the tools available to the model to a pre-defined set.\\n\\n\`auto\` allows the model to pick from among the allowed tools and generate a\\nmessage.\\n\\n\`required\` requires the model to call one or more of the allowed tools.\\n" }), "tools": Schema.Array(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "A tool definition that the model should be allowed to call.\\n" })).annotate({ "description": "A list of tool definitions that the model should be allowed to call.\\n\\nFor the Chat Completions API, the list of tool definitions might look like:\\n\`\`\`json\\n[\\n  { \\"type\\": \\"function\\", \\"function\\": { \\"name\\": \\"get_weather\\" } },\\n  { \\"type\\": \\"function\\", \\"function\\": { \\"name\\": \\"get_time\\" } }\\n]\\n\`\`\`\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Allowed tools", "description": "Constrains the tools available to the model to a pre-defined set.\\n", "identifier": "ChatCompletionAllowedTools" })
export type ChatCompletionDeleted = { readonly "object": "chat.completion.deleted", readonly "id": string, readonly "deleted": boolean, readonly [x: string]: unknown }
export const ChatCompletionDeleted = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("chat.completion.deleted").annotate({ "description": "The type of object being deleted." }), "id": Schema.String.annotate({ "description": "The ID of the chat completion that was deleted." }), "deleted": Schema.Boolean.annotate({ "description": "Whether the chat completion was deleted." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ChatCompletionDeleted" })
export type ChatCompletionFunctionCallOption = { readonly "name": string, readonly [x: string]: unknown }
export const ChatCompletionFunctionCallOption = Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function to call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Specifying a particular function via \`{\\"name\\": \\"my_function\\"}\` forces the model to call that function.\\n", "identifier": "ChatCompletionFunctionCallOption" })
export type ChatCompletionMessageCustomToolCall = { readonly "id": string, readonly "type": "custom", readonly "custom": { readonly "name": string, readonly "input": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ChatCompletionMessageCustomToolCall = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The ID of the tool call." }), "type": Schema.Literal("custom").annotate({ "description": "The type of the tool. Always \`custom\`." }), "custom": Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the custom tool to call." }), "input": Schema.String.annotate({ "description": "The input for the custom tool call generated by the model." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The custom tool that the model called." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Custom tool call", "description": "A call to a custom tool created by the model.\\n", "identifier": "ChatCompletionMessageCustomToolCall" })
export type ChatCompletionMessageToolCall = { readonly "id": string, readonly "type": "function", readonly "function": { readonly "name": string, readonly "arguments": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ChatCompletionMessageToolCall = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The ID of the tool call." }), "type": Schema.Literal("function").annotate({ "description": "The type of the tool. Currently, only \`function\` is supported." }), "function": Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function to call." }), "arguments": Schema.String.annotate({ "description": "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The function that the model called." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool call", "description": "A call to a function tool created by the model.\\n", "identifier": "ChatCompletionMessageToolCall" })
export type ChatCompletionMessageToolCallChunk = { readonly "index": number, readonly "id"?: string, readonly "type"?: "function", readonly "function"?: { readonly "name"?: string, readonly "arguments"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ChatCompletionMessageToolCallChunk = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.check(Schema.isInt()), "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the tool call." })), "type": Schema.optionalKey(Schema.Literal("function").annotate({ "description": "The type of the tool. Currently, only \`function\` is supported." })), "function": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function to call." })), "arguments": Schema.optionalKey(Schema.String.annotate({ "description": "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function." })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ChatCompletionMessageToolCallChunk" })
export type ChatCompletionModalities = ReadonlyArray<"text" | "audio"> | null
export const ChatCompletionModalities = Schema.Union([Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "Output types that you would like the model to generate for this request.\\nMost models are capable of generating text, which is the default:\\n\\n\`[\\"text\\"]\`\\n\\nThe \`gpt-4o-audio-preview\` model can also be used to [generate audio](https://platform.openai.com/docs/guides/audio). To\\nrequest that this model generate both text and audio responses, you can\\nuse:\\n\\n\`[\\"text\\", \\"audio\\"]\`\\n" }), Schema.Null]).annotate({ "identifier": "ChatCompletionModalities" })
export type ChatCompletionNamedToolChoice = { readonly "type": "function", readonly "function": { readonly "name": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ChatCompletionNamedToolChoice = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("function").annotate({ "description": "For function calling, the type is always \`function\`." }), "function": Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function to call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool choice", "description": "Specifies a tool the model should use. Use to force the model to call a specific function.", "identifier": "ChatCompletionNamedToolChoice" })
export type ChatCompletionNamedToolChoiceCustom = { readonly "type": "custom", readonly "custom": { readonly "name": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ChatCompletionNamedToolChoiceCustom = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("custom").annotate({ "description": "For custom tool calling, the type is always \`custom\`." }), "custom": Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the custom tool to call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Custom tool choice", "description": "Specifies a tool the model should use. Use to force the model to call a specific custom tool.", "identifier": "ChatCompletionNamedToolChoiceCustom" })
export type ChatCompletionRequestFunctionMessage = { readonly "role": "function", readonly "content": string | null, readonly "name": string, readonly [x: string]: unknown }
export const ChatCompletionRequestFunctionMessage = Schema.StructWithRest(Schema.Struct({ "role": Schema.Literal("function").annotate({ "description": "The role of the messages author, in this case \`function\`." }), "content": Schema.Union([Schema.String.annotate({ "description": "The contents of the function message." }), Schema.Null]), "name": Schema.String.annotate({ "description": "The name of the function to call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function message", "identifier": "ChatCompletionRequestFunctionMessage" })
export type ChatCompletionRequestMessageContentPartAudio = { readonly "type": "input_audio", readonly "input_audio": { readonly "data": string, readonly "format": "wav" | "mp3", readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ChatCompletionRequestMessageContentPartAudio = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_audio").annotate({ "description": "The type of the content part. Always \`input_audio\`." }), "input_audio": Schema.StructWithRest(Schema.Struct({ "data": Schema.String.annotate({ "description": "Base64 encoded audio data." }), "format": Schema.Literals(["wav", "mp3"]).annotate({ "description": "The format of the encoded audio data. Currently supports \\"wav\\" and \\"mp3\\".\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Audio content part", "description": "Learn about [audio inputs](https://platform.openai.com/docs/guides/audio).\\n", "identifier": "ChatCompletionRequestMessageContentPartAudio" })
export type ChatCompletionRequestMessageContentPartFile = { readonly "type": "file", readonly "file": { readonly "filename"?: string, readonly "file_data"?: string, readonly "file_id"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ChatCompletionRequestMessageContentPartFile = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file").annotate({ "description": "The type of the content part. Always \`file\`." }), "file": Schema.StructWithRest(Schema.Struct({ "filename": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the file, used when passing the file to the model as a \\nstring.\\n" })), "file_data": Schema.optionalKey(Schema.String.annotate({ "description": "The base64 encoded file data, used when passing the file to the model \\nas a string.\\n" })), "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of an uploaded file to use as input.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File content part", "description": "Learn about [file inputs](https://platform.openai.com/docs/guides/text) for text generation.\\n", "identifier": "ChatCompletionRequestMessageContentPartFile" })
export type ChatCompletionRequestMessageContentPartImage = { readonly "type": "image_url", readonly "image_url": { readonly "url": string, readonly "detail"?: "auto" | "low" | "high", readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ChatCompletionRequestMessageContentPartImage = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image_url").annotate({ "description": "The type of the content part." }), "image_url": Schema.StructWithRest(Schema.Struct({ "url": Schema.String.annotate({ "description": "Either a URL of the image or the base64 encoded image data.", "format": "uri" }), "detail": Schema.optionalKey(Schema.Literals(["auto", "low", "high"]).annotate({ "description": "Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision#low-or-high-fidelity-image-understanding).", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Image content part", "description": "Learn about [image inputs](https://platform.openai.com/docs/guides/vision).\\n", "identifier": "ChatCompletionRequestMessageContentPartImage" })
export type ChatCompletionRequestMessageContentPartRefusal = { readonly "type": "refusal", readonly "refusal": string, readonly [x: string]: unknown }
export const ChatCompletionRequestMessageContentPartRefusal = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("refusal").annotate({ "description": "The type of the content part." }), "refusal": Schema.String.annotate({ "description": "The refusal message generated by the model." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Refusal content part", "identifier": "ChatCompletionRequestMessageContentPartRefusal" })
export type ChatCompletionRequestMessageContentPartText = { readonly "type": "text", readonly "text": string, readonly [x: string]: unknown }
export const ChatCompletionRequestMessageContentPartText = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("text").annotate({ "description": "The type of the content part." }), "text": Schema.String.annotate({ "description": "The text content." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Text content part", "description": "Learn about [text inputs](https://platform.openai.com/docs/guides/text-generation).\\n", "identifier": "ChatCompletionRequestMessageContentPartText" })
export type ChatCompletionRole = "developer" | "system" | "user" | "assistant" | "tool" | "function"
export const ChatCompletionRole = Schema.Literals(["developer", "system", "user", "assistant", "tool", "function"]).annotate({ "description": "The role of the author of a message", "identifier": "ChatCompletionRole" })
export type ChatCompletionStreamOptions = { readonly "include_usage"?: boolean, readonly "include_obfuscation"?: boolean, readonly [x: string]: unknown } | null
export const ChatCompletionStreamOptions = Schema.Union([Schema.StructWithRest(Schema.Struct({ "include_usage": Schema.optionalKey(Schema.Boolean.annotate({ "description": "If set, an additional chunk will be streamed before the \`data: [DONE]\`\\nmessage. The \`usage\` field on this chunk shows the token usage statistics\\nfor the entire request, and the \`choices\` field will always be an empty\\narray.\\n\\nAll other chunks will also include a \`usage\` field, but with a null\\nvalue. **NOTE:** If the stream is interrupted, you may not receive the\\nfinal usage chunk which contains the total token usage for the request.\\n" })), "include_obfuscation": Schema.optionalKey(Schema.Boolean.annotate({ "description": "When true, stream obfuscation will be enabled. Stream obfuscation adds\\nrandom characters to an \`obfuscation\` field on streaming delta events to\\nnormalize payload sizes as a mitigation to certain side-channel attacks.\\nThese obfuscation fields are included by default, but add a small amount\\nof overhead to the data stream. You can set \`include_obfuscation\` to\\nfalse to optimize for bandwidth if you trust the network links between\\nyour application and the OpenAI API.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Options for streaming response. Only set this when you set \`stream: true\`.\\n" }), Schema.Null]).annotate({ "identifier": "ChatCompletionStreamOptions" })
export type ChatCompletionTokenLogprob = { readonly "token": string, readonly "logprob": number, readonly "bytes": ReadonlyArray<number> | null, readonly "top_logprobs": ReadonlyArray<{ readonly "token": string, readonly "logprob": number, readonly "bytes": ReadonlyArray<number> | null, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const ChatCompletionTokenLogprob = Schema.StructWithRest(Schema.Struct({ "token": Schema.String.annotate({ "description": "The token." }), "logprob": Schema.Number.annotate({ "description": "The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value \`-9999.0\` is used to signify that the token is very unlikely." }).check(Schema.isFinite()), "bytes": Schema.Union([Schema.Array(Schema.Number.check(Schema.isInt())).annotate({ "description": "A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be \`null\` if there is no bytes representation for the token." }), Schema.Null]), "top_logprobs": Schema.Array(Schema.StructWithRest(Schema.Struct({ "token": Schema.String.annotate({ "description": "The token." }), "logprob": Schema.Number.annotate({ "description": "The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value \`-9999.0\` is used to signify that the token is very unlikely." }).check(Schema.isFinite()), "bytes": Schema.Union([Schema.Array(Schema.Number.check(Schema.isInt())).annotate({ "description": "A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be \`null\` if there is no bytes representation for the token." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested \`top_logprobs\` returned." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ChatCompletionTokenLogprob" })
export type CodeInterpreterFileOutput = { readonly "type": "files", readonly "files": ReadonlyArray<{ readonly "mime_type": string, readonly "file_id": string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const CodeInterpreterFileOutput = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("files").annotate({ "description": "The type of the code interpreter file output. Always \`files\`.\\n" }), "files": Schema.Array(Schema.StructWithRest(Schema.Struct({ "mime_type": Schema.String.annotate({ "description": "The MIME type of the file.\\n" }), "file_id": Schema.String.annotate({ "description": "The ID of the file.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code interpreter file output", "description": "The output of a code interpreter tool call that is a file.\\n", "identifier": "CodeInterpreterFileOutput" })
export type CodeInterpreterTextOutput = { readonly "type": "logs", readonly "logs": string, readonly [x: string]: unknown }
export const CodeInterpreterTextOutput = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("logs").annotate({ "description": "The type of the code interpreter text output. Always \`logs\`.\\n" }), "logs": Schema.String.annotate({ "description": "The logs of the code interpreter tool call.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code interpreter text output", "description": "The output of a code interpreter tool call that is text.\\n", "identifier": "CodeInterpreterTextOutput" })
export type CompleteUploadRequest = { readonly "part_ids": ReadonlyArray<string>, readonly "md5"?: string }
export const CompleteUploadRequest = Schema.Struct({ "part_ids": Schema.Array(Schema.String).annotate({ "description": "The ordered list of Part IDs.\\n" }), "md5": Schema.optionalKey(Schema.String.annotate({ "description": "The optional md5 checksum for the file contents to verify if the bytes uploaded matches what you expect.\\n" })) }).annotate({ "identifier": "CompleteUploadRequest" })
export type CompletionUsage = { readonly "completion_tokens": number, readonly "prompt_tokens": number, readonly "total_tokens": number, readonly "completion_tokens_details"?: { readonly "accepted_prediction_tokens"?: number, readonly "audio_tokens"?: number, readonly "reasoning_tokens"?: number, readonly "rejected_prediction_tokens"?: number, readonly [x: string]: unknown }, readonly "prompt_tokens_details"?: { readonly "audio_tokens"?: number, readonly "cached_tokens"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const CompletionUsage = Schema.StructWithRest(Schema.Struct({ "completion_tokens": Schema.Number.annotate({ "description": "Number of tokens in the generated completion.", "default": 0 }).check(Schema.isInt()), "prompt_tokens": Schema.Number.annotate({ "description": "Number of tokens in the prompt.", "default": 0 }).check(Schema.isInt()), "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used in the request (prompt + completion).", "default": 0 }).check(Schema.isInt()), "completion_tokens_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "accepted_prediction_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "When using Predicted Outputs, the number of tokens in the\\nprediction that appeared in the completion.\\n", "default": 0 }).check(Schema.isInt())), "audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "Audio input tokens generated by the model.", "default": 0 }).check(Schema.isInt())), "reasoning_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "Tokens generated by the model for reasoning.", "default": 0 }).check(Schema.isInt())), "rejected_prediction_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "When using Predicted Outputs, the number of tokens in the\\nprediction that did not appear in the completion. However, like\\nreasoning tokens, these tokens are still counted in the total\\ncompletion tokens for purposes of billing, output, and context window\\nlimits.\\n", "default": 0 }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Breakdown of tokens used in a completion." })), "prompt_tokens_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "Audio input tokens present in the prompt.", "default": 0 }).check(Schema.isInt())), "cached_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "Cached tokens present in the prompt.", "default": 0 }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Breakdown of tokens used in the prompt." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Usage statistics for the completion request.", "identifier": "CompletionUsage" })
export type ComputerScreenshotImage = { readonly "type": "computer_screenshot", readonly "image_url"?: string, readonly "file_id"?: string, readonly [x: string]: unknown }
export const ComputerScreenshotImage = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("computer_screenshot").annotate({ "description": "Specifies the event type. For a computer screenshot, this property is \\nalways set to \`computer_screenshot\`.\\n", "default": "computer_screenshot" }), "image_url": Schema.optionalKey(Schema.String.annotate({ "description": "The URL of the screenshot image." })), "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The identifier of an uploaded file that contains the screenshot." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A computer screenshot image used with the computer use tool.\\n", "identifier": "ComputerScreenshotImage" })
export type ComputerToolCallOutputResource = never
export const ComputerToolCallOutputResource = Schema.Never.annotate({ "identifier": "ComputerToolCallOutputResource" })
export type ContainerFileResource = { readonly "id": string, readonly "object": "container.file", readonly "container_id": string, readonly "created_at": number, readonly "bytes": number, readonly "path": string, readonly "source": string, readonly [x: string]: unknown }
export const ContainerFileResource = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Unique identifier for the file." }), "object": Schema.Literal("container.file").annotate({ "description": "The type of this object (\`container.file\`)." }), "container_id": Schema.String.annotate({ "description": "The container this file belongs to." }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the file was created." }).check(Schema.isInt()), "bytes": Schema.Number.annotate({ "description": "Size of the file in bytes." }).check(Schema.isInt()), "path": Schema.String.annotate({ "description": "Path of the file in the container." }), "source": Schema.String.annotate({ "description": "Source of the file (e.g., \`user\`, \`assistant\`)." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "The container file object", "identifier": "ContainerFileResource" })
export type ContainerResource = { readonly "id": string, readonly "object": string, readonly "name": string, readonly "created_at": number, readonly "status": string, readonly "last_active_at"?: number, readonly "expires_after"?: { readonly "anchor"?: "last_active_at", readonly "minutes"?: number, readonly [x: string]: unknown }, readonly "memory_limit"?: "1g" | "4g" | "16g" | "64g", readonly [x: string]: unknown }
export const ContainerResource = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Unique identifier for the container." }), "object": Schema.String.annotate({ "description": "The type of this object." }), "name": Schema.String.annotate({ "description": "Name of the container." }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the container was created." }).check(Schema.isInt()), "status": Schema.String.annotate({ "description": "Status of the container (e.g., active, deleted)." }), "last_active_at": Schema.optionalKey(Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the container was last active." }).check(Schema.isInt())), "expires_after": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "anchor": Schema.optionalKey(Schema.Literal("last_active_at").annotate({ "description": "The reference point for the expiration." })), "minutes": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of minutes after the anchor before the container expires." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The container will expire after this time period.\\nThe anchor is the reference point for the expiration.\\nThe minutes is the number of minutes after the anchor before the container expires.\\n" })), "memory_limit": Schema.optionalKey(Schema.Literals(["1g", "4g", "16g", "64g"]).annotate({ "description": "The memory limit configured for the container." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "The container object", "identifier": "ContainerResource" })
export type Content = unknown | unknown
export const Content = Schema.Union([Schema.Unknown.annotate({ "title": "Input content types" }), Schema.Unknown.annotate({ "title": "Output content types" })]).annotate({ "description": "Multi-modal input and output contents.\\n", "identifier": "Content" })
export type Conversation = unknown
export const Conversation = Schema.Unknown.annotate({ "title": "The conversation object", "identifier": "Conversation" })
export type CostsResult = { readonly "object": "organization.costs.result", readonly "amount"?: { readonly "value"?: number, readonly "currency"?: string, readonly [x: string]: unknown }, readonly "line_item"?: string | null, readonly "project_id"?: string | null, readonly [x: string]: unknown }
export const CostsResult = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.costs.result"), "amount": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "value": Schema.optionalKey(Schema.Number.annotate({ "description": "The numeric value of the cost." }).check(Schema.isFinite())), "currency": Schema.optionalKey(Schema.String.annotate({ "description": "Lowercase ISO-4217 currency e.g. \\"usd\\"" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The monetary value in its associated currency." })), "line_item": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=line_item\`, this field provides the line item of the grouped costs result." }), Schema.Null])), "project_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=project_id\`, this field provides the project ID of the grouped costs result." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The aggregated costs details of the specific time bucket.", "identifier": "CostsResult" })
export type CreateContainerBody = { readonly "name": string, readonly "file_ids"?: ReadonlyArray<string>, readonly "expires_after"?: { readonly "anchor": "last_active_at", readonly "minutes": number, readonly [x: string]: unknown }, readonly "memory_limit"?: "1g" | "4g" | "16g" | "64g", readonly [x: string]: unknown }
export const CreateContainerBody = Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "Name of the container to create." }), "file_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "IDs of files to copy to the container." })), "expires_after": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "anchor": Schema.Literal("last_active_at").annotate({ "description": "Time anchor for the expiration time. Currently only 'last_active_at' is supported." }), "minutes": Schema.Number.check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Container expiration time in seconds relative to the 'anchor' time." })), "memory_limit": Schema.optionalKey(Schema.Literals(["1g", "4g", "16g", "64g"]).annotate({ "description": "Optional memory limit for the container. Defaults to \\"1g\\"." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateContainerBody" })
export type CreateContainerFileBody = { readonly "file_id"?: string, readonly "file"?: string, readonly [x: string]: unknown }
export const CreateContainerFileBody = Schema.StructWithRest(Schema.Struct({ "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "Name of the file to create." })), "file": Schema.optionalKey(Schema.String.annotate({ "description": "The File object (not file name) to be uploaded.\\n", "format": "binary" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateContainerFileBody" })
export type CreateEmbeddingRequest = { readonly "input": string | ReadonlyArray<string> | ReadonlyArray<number> | ReadonlyArray<ReadonlyArray<number>>, readonly "model": string | "text-embedding-ada-002" | "text-embedding-3-small" | "text-embedding-3-large", readonly "encoding_format"?: "float" | "base64", readonly "dimensions"?: number, readonly "user"?: string }
export const CreateEmbeddingRequest = Schema.Struct({ "input": Schema.Union([Schema.String.annotate({ "title": "string", "description": "The string that will be turned into an embedding.", "default": "" }), Schema.Array(Schema.String.annotate({ "default": "" })).annotate({ "title": "Array of strings", "description": "The array of strings that will be turned into an embedding." }), Schema.Array(Schema.Number.check(Schema.isInt())).annotate({ "title": "Array of tokens", "description": "The array of integers that will be turned into an embedding." }), Schema.Array(Schema.Array(Schema.Number.check(Schema.isInt()))).annotate({ "title": "Array of token arrays", "description": "The array of arrays containing integers that will be turned into an embedding." })]).annotate({ "description": "Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for all embedding models), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. In addition to the per-input token limit, all embedding  models enforce a maximum of 300,000 tokens summed across all inputs in a  single request.\\n" }), "model": Schema.Union([Schema.String, Schema.Literals(["text-embedding-ada-002", "text-embedding-3-small", "text-embedding-3-large"])]).annotate({ "description": "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\\n" }), "encoding_format": Schema.optionalKey(Schema.Literals(["float", "base64"]).annotate({ "description": "The format to return the embeddings in. Can be either \`float\` or [\`base64\`](https://pypi.org/project/pybase64/).", "default": "float" })), "dimensions": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of dimensions the resulting output embeddings should have. Only supported in \`text-embedding-3\` and later models.\\n" }).check(Schema.isInt())), "user": Schema.optionalKey(Schema.String.annotate({ "description": "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\\n" })) }).annotate({ "identifier": "CreateEmbeddingRequest" })
export type CreateEvalCustomDataSourceConfig = { readonly "type": "custom", readonly "item_schema": { readonly [x: string]: unknown }, readonly "include_sample_schema"?: boolean, readonly [x: string]: unknown }
export const CreateEvalCustomDataSourceConfig = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("custom").annotate({ "description": "The type of data source. Always \`custom\`.", "default": "custom" }), "item_schema": Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The json schema for each row in the data source." }), "include_sample_schema": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Whether the eval should expect you to populate the sample namespace (ie, by generating responses off of your data source)", "default": false })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "CustomDataSourceConfig", "description": "A CustomDataSourceConfig object that defines the schema for the data source used for the evaluation runs.\\nThis schema is used to define the shape of the data that will be:\\n- Used to define your testing criteria and\\n- What data is required when creating a run\\n", "identifier": "CreateEvalCustomDataSourceConfig" })
export type CreateEvalLogsDataSourceConfig = { readonly "type": "logs", readonly "metadata"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const CreateEvalLogsDataSourceConfig = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("logs").annotate({ "description": "The type of data source. Always \`logs\`.", "default": "logs" }), "metadata": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "Metadata filters for the logs data source." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "LogsDataSourceConfig", "description": "A data source config which specifies the metadata property of your logs query.\\nThis is usually metadata like \`usecase=chatbot\` or \`prompt-version=v2\`, etc.\\n", "identifier": "CreateEvalLogsDataSourceConfig" })
export type CreateEvalStoredCompletionsDataSourceConfig = { readonly "type": "stored_completions", readonly "metadata"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const CreateEvalStoredCompletionsDataSourceConfig = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("stored_completions").annotate({ "description": "The type of data source. Always \`stored_completions\`.", "default": "stored_completions" }), "metadata": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "Metadata filters for the stored completions data source." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "StoredCompletionsDataSourceConfig", "description": "Deprecated in favor of LogsDataSourceConfig.\\n", "identifier": "CreateEvalStoredCompletionsDataSourceConfig" })
export type CreateFineTuningCheckpointPermissionRequest = { readonly "project_ids": ReadonlyArray<string> }
export const CreateFineTuningCheckpointPermissionRequest = Schema.Struct({ "project_ids": Schema.Array(Schema.String).annotate({ "description": "The project identifiers to grant access to." }) }).annotate({ "identifier": "CreateFineTuningCheckpointPermissionRequest" })
export type CreateGroupBody = { readonly "name": string, readonly [x: string]: unknown }
export const CreateGroupBody = Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "Human readable name for the group." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Request payload for creating a new group in the organization.", "identifier": "CreateGroupBody" })
export type CreateGroupUserBody = { readonly "user_id": string, readonly [x: string]: unknown }
export const CreateGroupUserBody = Schema.StructWithRest(Schema.Struct({ "user_id": Schema.String.annotate({ "description": "Identifier of the user to add to the group." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Request payload for adding a user to a group.", "identifier": "CreateGroupUserBody" })
export type CreateImageVariationRequest = { readonly "image": string, readonly "model"?: string | "dall-e-2" | null, readonly "n"?: number | null, readonly "response_format"?: "url" | "b64_json" | null, readonly "size"?: "256x256" | "512x512" | "1024x1024" | null, readonly "user"?: string, readonly [x: string]: unknown }
export const CreateImageVariationRequest = Schema.StructWithRest(Schema.Struct({ "image": Schema.String.annotate({ "description": "The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.", "format": "binary" }), "model": Schema.optionalKey(Schema.Union([Schema.Union([Schema.String, Schema.Literal("dall-e-2")]).annotate({ "description": "The model to use for image generation. Only \`dall-e-2\` is supported at this time." }), Schema.Null])), "n": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The number of images to generate. Must be between 1 and 10.", "default": 1 })), "response_format": Schema.optionalKey(Schema.Union([Schema.Literal("url"), Schema.Literal("b64_json"), Schema.Null]).annotate({ "description": "The format in which the generated images are returned. Must be one of \`url\` or \`b64_json\`. URLs are only valid for 60 minutes after the image has been generated.", "default": "url" })), "size": Schema.optionalKey(Schema.Union([Schema.Literal("256x256"), Schema.Literal("512x512"), Schema.Literal("1024x1024"), Schema.Null]).annotate({ "description": "The size of the generated images. Must be one of \`256x256\`, \`512x512\`, or \`1024x1024\`.", "default": "1024x1024" })), "user": Schema.optionalKey(Schema.String.annotate({ "description": "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateImageVariationRequest" })
export type CreateModelResponseProperties = { readonly "top_logprobs"?: number, readonly [x: string]: unknown }
export const CreateModelResponseProperties = Schema.StructWithRest(Schema.Struct({ "top_logprobs": Schema.optionalKey(Schema.Number.annotate({ "description": "An integer between 0 and 20 specifying the number of most likely tokens to\\nreturn at each token position, each with an associated log probability.\\n" }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateModelResponseProperties" })
export type CreateModerationResponse = { readonly "id": string, readonly "model": string, readonly "results": ReadonlyArray<{ readonly "flagged": boolean, readonly "categories": { readonly "hate": boolean, readonly "hate/threatening": boolean, readonly "harassment": boolean, readonly "harassment/threatening": boolean, readonly "illicit": boolean | null, readonly "illicit/violent": boolean | null, readonly "self-harm": boolean, readonly "self-harm/intent": boolean, readonly "self-harm/instructions": boolean, readonly "sexual": boolean, readonly "sexual/minors": boolean, readonly "violence": boolean, readonly "violence/graphic": boolean, readonly [x: string]: unknown }, readonly "category_scores": { readonly "hate": number, readonly "hate/threatening": number, readonly "harassment": number, readonly "harassment/threatening": number, readonly "illicit": number, readonly "illicit/violent": number, readonly "self-harm": number, readonly "self-harm/intent": number, readonly "self-harm/instructions": number, readonly "sexual": number, readonly "sexual/minors": number, readonly "violence": number, readonly "violence/graphic": number, readonly [x: string]: unknown }, readonly "category_applied_input_types": { readonly "hate": ReadonlyArray<"text">, readonly "hate/threatening": ReadonlyArray<"text">, readonly "harassment": ReadonlyArray<"text">, readonly "harassment/threatening": ReadonlyArray<"text">, readonly "illicit": ReadonlyArray<"text">, readonly "illicit/violent": ReadonlyArray<"text">, readonly "self-harm": ReadonlyArray<"text" | "image">, readonly "self-harm/intent": ReadonlyArray<"text" | "image">, readonly "self-harm/instructions": ReadonlyArray<"text" | "image">, readonly "sexual": ReadonlyArray<"text" | "image">, readonly "sexual/minors": ReadonlyArray<"text">, readonly "violence": ReadonlyArray<"text" | "image">, readonly "violence/graphic": ReadonlyArray<"text" | "image">, readonly [x: string]: unknown }, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const CreateModerationResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique identifier for the moderation request." }), "model": Schema.String.annotate({ "description": "The model used to generate the moderation results." }), "results": Schema.Array(Schema.StructWithRest(Schema.Struct({ "flagged": Schema.Boolean.annotate({ "description": "Whether any of the below categories are flagged." }), "categories": Schema.StructWithRest(Schema.Struct({ "hate": Schema.Boolean.annotate({ "description": "Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment." }), "hate/threatening": Schema.Boolean.annotate({ "description": "Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste." }), "harassment": Schema.Boolean.annotate({ "description": "Content that expresses, incites, or promotes harassing language towards any target." }), "harassment/threatening": Schema.Boolean.annotate({ "description": "Harassment content that also includes violence or serious harm towards any target." }), "illicit": Schema.Union([Schema.Boolean.annotate({ "description": "Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, \\"how to shoplift\\" would fit this category." }), Schema.Null]), "illicit/violent": Schema.Union([Schema.Boolean.annotate({ "description": "Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon." }), Schema.Null]), "self-harm": Schema.Boolean.annotate({ "description": "Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders." }), "self-harm/intent": Schema.Boolean.annotate({ "description": "Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders." }), "self-harm/instructions": Schema.Boolean.annotate({ "description": "Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts." }), "sexual": Schema.Boolean.annotate({ "description": "Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness)." }), "sexual/minors": Schema.Boolean.annotate({ "description": "Sexual content that includes an individual who is under 18 years old." }), "violence": Schema.Boolean.annotate({ "description": "Content that depicts death, violence, or physical injury." }), "violence/graphic": Schema.Boolean.annotate({ "description": "Content that depicts death, violence, or physical injury in graphic detail." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A list of the categories, and whether they are flagged or not." }), "category_scores": Schema.StructWithRest(Schema.Struct({ "hate": Schema.Number.annotate({ "description": "The score for the category 'hate'." }).check(Schema.isFinite()), "hate/threatening": Schema.Number.annotate({ "description": "The score for the category 'hate/threatening'." }).check(Schema.isFinite()), "harassment": Schema.Number.annotate({ "description": "The score for the category 'harassment'." }).check(Schema.isFinite()), "harassment/threatening": Schema.Number.annotate({ "description": "The score for the category 'harassment/threatening'." }).check(Schema.isFinite()), "illicit": Schema.Number.annotate({ "description": "The score for the category 'illicit'." }).check(Schema.isFinite()), "illicit/violent": Schema.Number.annotate({ "description": "The score for the category 'illicit/violent'." }).check(Schema.isFinite()), "self-harm": Schema.Number.annotate({ "description": "The score for the category 'self-harm'." }).check(Schema.isFinite()), "self-harm/intent": Schema.Number.annotate({ "description": "The score for the category 'self-harm/intent'." }).check(Schema.isFinite()), "self-harm/instructions": Schema.Number.annotate({ "description": "The score for the category 'self-harm/instructions'." }).check(Schema.isFinite()), "sexual": Schema.Number.annotate({ "description": "The score for the category 'sexual'." }).check(Schema.isFinite()), "sexual/minors": Schema.Number.annotate({ "description": "The score for the category 'sexual/minors'." }).check(Schema.isFinite()), "violence": Schema.Number.annotate({ "description": "The score for the category 'violence'." }).check(Schema.isFinite()), "violence/graphic": Schema.Number.annotate({ "description": "The score for the category 'violence/graphic'." }).check(Schema.isFinite()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A list of the categories along with their scores as predicted by model." }), "category_applied_input_types": Schema.StructWithRest(Schema.Struct({ "hate": Schema.Array(Schema.Literal("text")).annotate({ "description": "The applied input type(s) for the category 'hate'." }), "hate/threatening": Schema.Array(Schema.Literal("text")).annotate({ "description": "The applied input type(s) for the category 'hate/threatening'." }), "harassment": Schema.Array(Schema.Literal("text")).annotate({ "description": "The applied input type(s) for the category 'harassment'." }), "harassment/threatening": Schema.Array(Schema.Literal("text")).annotate({ "description": "The applied input type(s) for the category 'harassment/threatening'." }), "illicit": Schema.Array(Schema.Literal("text")).annotate({ "description": "The applied input type(s) for the category 'illicit'." }), "illicit/violent": Schema.Array(Schema.Literal("text")).annotate({ "description": "The applied input type(s) for the category 'illicit/violent'." }), "self-harm": Schema.Array(Schema.Literals(["text", "image"])).annotate({ "description": "The applied input type(s) for the category 'self-harm'." }), "self-harm/intent": Schema.Array(Schema.Literals(["text", "image"])).annotate({ "description": "The applied input type(s) for the category 'self-harm/intent'." }), "self-harm/instructions": Schema.Array(Schema.Literals(["text", "image"])).annotate({ "description": "The applied input type(s) for the category 'self-harm/instructions'." }), "sexual": Schema.Array(Schema.Literals(["text", "image"])).annotate({ "description": "The applied input type(s) for the category 'sexual'." }), "sexual/minors": Schema.Array(Schema.Literal("text")).annotate({ "description": "The applied input type(s) for the category 'sexual/minors'." }), "violence": Schema.Array(Schema.Literals(["text", "image"])).annotate({ "description": "The applied input type(s) for the category 'violence'." }), "violence/graphic": Schema.Array(Schema.Literals(["text", "image"])).annotate({ "description": "The applied input type(s) for the category 'violence/graphic'." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A list of the categories along with the input type(s) that the score applies to." }) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "A list of moderation objects." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents if a given text input is potentially harmful.", "identifier": "CreateModerationResponse" })
export type CreateResponse = never
export const CreateResponse = Schema.Never.annotate({ "identifier": "CreateResponse" })
export type CreateSpeechRequest = { readonly "model": string | "tts-1" | "tts-1-hd" | "gpt-4o-mini-tts" | "gpt-4o-mini-tts-2025-12-15", readonly "input": string, readonly "instructions"?: string, readonly "voice": unknown, readonly "response_format"?: "mp3" | "opus" | "aac" | "flac" | "wav" | "pcm", readonly "speed"?: number, readonly "stream_format"?: "sse" | "audio" }
export const CreateSpeechRequest = Schema.Struct({ "model": Schema.Union([Schema.String, Schema.Literals(["tts-1", "tts-1-hd", "gpt-4o-mini-tts", "gpt-4o-mini-tts-2025-12-15"])]).annotate({ "description": "One of the available [TTS models](https://platform.openai.com/docs/models#tts): \`tts-1\`, \`tts-1-hd\`, \`gpt-4o-mini-tts\`, or \`gpt-4o-mini-tts-2025-12-15\`.\\n" }), "input": Schema.String.annotate({ "description": "The text to generate audio for. The maximum length is 4096 characters." }), "instructions": Schema.optionalKey(Schema.String.annotate({ "description": "Control the voice of your generated audio with additional instructions. Does not work with \`tts-1\` or \`tts-1-hd\`." })), "voice": Schema.Unknown.annotate({ "description": "The voice to use when generating the audio. Supported voices are \`alloy\`, \`ash\`, \`ballad\`, \`coral\`, \`echo\`, \`fable\`, \`onyx\`, \`nova\`, \`sage\`, \`shimmer\`, and \`verse\`. Previews of the voices are available in the [Text to speech guide](https://platform.openai.com/docs/guides/text-to-speech#voice-options)." }), "response_format": Schema.optionalKey(Schema.Literals(["mp3", "opus", "aac", "flac", "wav", "pcm"]).annotate({ "description": "The format to audio in. Supported formats are \`mp3\`, \`opus\`, \`aac\`, \`flac\`, \`wav\`, and \`pcm\`.", "default": "mp3" })), "speed": Schema.optionalKey(Schema.Number.annotate({ "description": "The speed of the generated audio. Select a value from \`0.25\` to \`4.0\`. \`1.0\` is the default.", "default": 1 }).check(Schema.isFinite())), "stream_format": Schema.optionalKey(Schema.Literals(["sse", "audio"]).annotate({ "description": "The format to stream the audio in. Supported formats are \`sse\` and \`audio\`. \`sse\` is not supported for \`tts-1\` or \`tts-1-hd\`.", "default": "audio" })) }).annotate({ "identifier": "CreateSpeechRequest" })
export type CreateTranslationRequest = { readonly "file": string, readonly "model": string | "whisper-1", readonly "prompt"?: string, readonly "response_format"?: "json" | "text" | "srt" | "verbose_json" | "vtt", readonly "temperature"?: number }
export const CreateTranslationRequest = Schema.Struct({ "file": Schema.String.annotate({ "description": "The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\\n", "format": "binary" }), "model": Schema.Union([Schema.String, Schema.Literal("whisper-1")]).annotate({ "description": "ID of the model to use. Only \`whisper-1\` (which is powered by our open source Whisper V2 model) is currently available.\\n" }), "prompt": Schema.optionalKey(Schema.String.annotate({ "description": "An optional text to guide the model's style or continue a previous audio segment. The [prompt](https://platform.openai.com/docs/guides/speech-to-text#prompting) should be in English.\\n" })), "response_format": Schema.optionalKey(Schema.Literals(["json", "text", "srt", "verbose_json", "vtt"]).annotate({ "description": "The format of the output, in one of these options: \`json\`, \`text\`, \`srt\`, \`verbose_json\`, or \`vtt\`.\\n", "default": "json" })), "temperature": Schema.optionalKey(Schema.Number.annotate({ "description": "The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.\\n", "default": 0 }).check(Schema.isFinite())) }).annotate({ "identifier": "CreateTranslationRequest" })
export type CreateTranslationResponseJson = { readonly "text": string, readonly [x: string]: unknown }
export const CreateTranslationResponseJson = Schema.StructWithRest(Schema.Struct({ "text": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateTranslationResponseJson" })
export type CreateVoiceConsentRequest = { readonly "name": string, readonly "recording": string, readonly "language": string }
export const CreateVoiceConsentRequest = Schema.Struct({ "name": Schema.String.annotate({ "description": "The label to use for this consent recording." }), "recording": Schema.String.annotate({ "description": "The consent audio recording file. Maximum size is 10 MiB.\\n\\nSupported MIME types:\\n\`audio/mpeg\`, \`audio/wav\`, \`audio/x-wav\`, \`audio/ogg\`, \`audio/aac\`, \`audio/flac\`, \`audio/webm\`, \`audio/mp4\`.\\n", "format": "binary" }), "language": Schema.String.annotate({ "description": "The BCP 47 language tag for the consent phrase (for example, \`en-US\`)." }) }).annotate({ "identifier": "CreateVoiceConsentRequest" })
export type CreateVoiceRequest = { readonly "name": string, readonly "audio_sample": string, readonly "consent": string }
export const CreateVoiceRequest = Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the new voice." }), "audio_sample": Schema.String.annotate({ "description": "The sample audio recording file. Maximum size is 10 MiB.\\n\\nSupported MIME types:\\n\`audio/mpeg\`, \`audio/wav\`, \`audio/x-wav\`, \`audio/ogg\`, \`audio/aac\`, \`audio/flac\`, \`audio/webm\`, \`audio/mp4\`.\\n", "format": "binary" }), "consent": Schema.String.annotate({ "description": "The consent recording ID (for example, \`cons_1234\`)." }) }).annotate({ "identifier": "CreateVoiceRequest" })
export type CustomToolCall = { readonly "type": "custom_tool_call", readonly "id"?: string, readonly "call_id": string, readonly "name": string, readonly "input": string, readonly [x: string]: unknown }
export const CustomToolCall = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("custom_tool_call").annotate({ "description": "The type of the custom tool call. Always \`custom_tool_call\`.\\n" }), "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the custom tool call in the OpenAI platform.\\n" })), "call_id": Schema.String.annotate({ "description": "An identifier used to map this custom tool call to a tool call output.\\n" }), "name": Schema.String.annotate({ "description": "The name of the custom tool being called.\\n" }), "input": Schema.String.annotate({ "description": "The input for the custom tool call generated by the model.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Custom tool call", "description": "A call to a custom tool created by the model.\\n", "identifier": "CustomToolCall" })
export type CustomToolChatCompletions = { readonly "type": "custom", readonly "custom": { readonly "name": string, readonly "description"?: string, readonly "format"?: { readonly "type": "text" } | { readonly "type": "grammar", readonly "grammar": { readonly "definition": string, readonly "syntax": "lark" | "regex", readonly [x: string]: unknown } }, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const CustomToolChatCompletions = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("custom").annotate({ "description": "The type of the custom tool. Always \`custom\`." }), "custom": Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the custom tool, used to identify it in tool calls." }), "description": Schema.optionalKey(Schema.String.annotate({ "description": "Optional description of the custom tool, used to provide more context.\\n" })), "format": Schema.optionalKey(Schema.Union([Schema.Struct({ "type": Schema.Literal("text").annotate({ "description": "Unconstrained text format. Always \`text\`." }) }).annotate({ "title": "Text format", "description": "Unconstrained free-form text." }), Schema.Struct({ "type": Schema.Literal("grammar").annotate({ "description": "Grammar format. Always \`grammar\`." }), "grammar": Schema.StructWithRest(Schema.Struct({ "definition": Schema.String.annotate({ "description": "The grammar definition." }), "syntax": Schema.Literals(["lark", "regex"]).annotate({ "description": "The syntax of the grammar definition. One of \`lark\` or \`regex\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Grammar format", "description": "Your chosen grammar." }) }).annotate({ "title": "Grammar format", "description": "A grammar defined by the user." })]).annotate({ "description": "The input format for the custom tool. Default is unconstrained text.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Custom tool properties", "description": "Properties of the custom tool.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Custom tool", "description": "A custom tool that processes input using a specified format.\\n", "identifier": "CustomToolChatCompletions" })
export type DeleteAssistantResponse = { readonly "id": string, readonly "deleted": boolean, readonly "object": "assistant.deleted", readonly [x: string]: unknown }
export const DeleteAssistantResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String, "deleted": Schema.Boolean, "object": Schema.Literal("assistant.deleted") }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "DeleteAssistantResponse" })
export type DeleteCertificateResponse = { readonly "object": "certificate.deleted", readonly "id": string, readonly [x: string]: unknown }
export const DeleteCertificateResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("certificate.deleted").annotate({ "description": "The object type, must be \`certificate.deleted\`." }), "id": Schema.String.annotate({ "description": "The ID of the certificate that was deleted." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "DeleteCertificateResponse" })
export type DeleteFileResponse = { readonly "id": string, readonly "object": "file", readonly "deleted": boolean, readonly [x: string]: unknown }
export const DeleteFileResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String, "object": Schema.Literal("file"), "deleted": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "DeleteFileResponse" })
export type DeleteFineTuningCheckpointPermissionResponse = { readonly "id": string, readonly "object": "checkpoint.permission", readonly "deleted": boolean, readonly [x: string]: unknown }
export const DeleteFineTuningCheckpointPermissionResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The ID of the fine-tuned model checkpoint permission that was deleted." }), "object": Schema.Literal("checkpoint.permission").annotate({ "description": "The object type, which is always \\"checkpoint.permission\\"." }), "deleted": Schema.Boolean.annotate({ "description": "Whether the fine-tuned model checkpoint permission was successfully deleted." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "DeleteFineTuningCheckpointPermissionResponse" })
export type DeleteMessageResponse = { readonly "id": string, readonly "deleted": boolean, readonly "object": "thread.message.deleted", readonly [x: string]: unknown }
export const DeleteMessageResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String, "deleted": Schema.Boolean, "object": Schema.Literal("thread.message.deleted") }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "DeleteMessageResponse" })
export type DeleteModelResponse = { readonly "id": string, readonly "deleted": boolean, readonly "object": string, readonly [x: string]: unknown }
export const DeleteModelResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String, "deleted": Schema.Boolean, "object": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "DeleteModelResponse" })
export type DeleteThreadResponse = { readonly "id": string, readonly "deleted": boolean, readonly "object": "thread.deleted", readonly [x: string]: unknown }
export const DeleteThreadResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String, "deleted": Schema.Boolean, "object": Schema.Literal("thread.deleted") }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "DeleteThreadResponse" })
export type DeleteVectorStoreFileResponse = { readonly "id": string, readonly "deleted": boolean, readonly "object": "vector_store.file.deleted", readonly [x: string]: unknown }
export const DeleteVectorStoreFileResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String, "deleted": Schema.Boolean, "object": Schema.Literal("vector_store.file.deleted") }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "DeleteVectorStoreFileResponse" })
export type DeleteVectorStoreResponse = { readonly "id": string, readonly "deleted": boolean, readonly "object": "vector_store.deleted", readonly [x: string]: unknown }
export const DeleteVectorStoreResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String, "deleted": Schema.Boolean, "object": Schema.Literal("vector_store.deleted") }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "DeleteVectorStoreResponse" })
export type DeletedConversation = unknown
export const DeletedConversation = Schema.Unknown.annotate({ "title": "The deleted conversation object", "identifier": "DeletedConversation" })
export type DeletedRoleAssignmentResource = { readonly "object": string, readonly "deleted": boolean, readonly [x: string]: unknown }
export const DeletedRoleAssignmentResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.String.annotate({ "description": "Identifier for the deleted assignment, such as \`group.role.deleted\` or \`user.role.deleted\`." }), "deleted": Schema.Boolean.annotate({ "description": "Whether the assignment was removed." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Confirmation payload returned after unassigning a role.", "identifier": "DeletedRoleAssignmentResource" })
export type DoneEvent = { readonly "event": "done", readonly "data": "[DONE]", readonly [x: string]: unknown }
export const DoneEvent = Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("done"), "data": Schema.Literal("[DONE]") }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a stream ends.", "identifier": "DoneEvent" })
export type Embedding = { readonly "index": number, readonly "embedding": ReadonlyArray<number>, readonly "object": "embedding", readonly [x: string]: unknown }
export const Embedding = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the embedding in the list of embeddings." }).check(Schema.isInt()), "embedding": Schema.Array(Schema.Number.annotate({ "format": "float" }).check(Schema.isFinite())).annotate({ "description": "The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).\\n" }), "object": Schema.Literal("embedding").annotate({ "description": "The object type, which is always \\"embedding\\"." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents an embedding vector returned by embedding endpoint.\\n", "identifier": "Embedding" })
export type Error = { readonly "code": string | null, readonly "message": string, readonly "param": string | null, readonly "type": string, readonly [x: string]: unknown }
export const Error = Schema.StructWithRest(Schema.Struct({ "code": Schema.Union([Schema.String, Schema.Null]), "message": Schema.String, "param": Schema.Union([Schema.String, Schema.Null]), "type": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "Error" })
export type EvalApiError = { readonly "code": string, readonly "message": string, readonly [x: string]: unknown }
export const EvalApiError = Schema.StructWithRest(Schema.Struct({ "code": Schema.String.annotate({ "description": "The error code." }), "message": Schema.String.annotate({ "description": "The error message." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalApiError", "description": "An object representing an error response from the Eval API.\\n", "identifier": "EvalApiError" })
export type EvalCustomDataSourceConfig = { readonly "type": "custom", readonly "schema": { readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const EvalCustomDataSourceConfig = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("custom").annotate({ "description": "The type of data source. Always \`custom\`.", "default": "custom" }), "schema": Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The json schema for the run data source items.\\nLearn how to build JSON schemas [here](https://json-schema.org/).\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "CustomDataSourceConfig", "description": "A CustomDataSourceConfig which specifies the schema of your \`item\` and optionally \`sample\` namespaces.\\nThe response schema defines the shape of the data that will be:\\n- Used to define your testing criteria and\\n- What data is required when creating a run\\n", "identifier": "EvalCustomDataSourceConfig" })
export type EvalGraderLabelModel = { readonly [x: string]: unknown }
export const EvalGraderLabelModel = Schema.Record(Schema.String, Schema.Unknown).annotate({ "title": "LabelModelGrader", "identifier": "EvalGraderLabelModel" })
export type EvalGraderPython = { readonly "pass_threshold"?: number, readonly [x: string]: unknown }
export const EvalGraderPython = Schema.StructWithRest(Schema.Struct({ "pass_threshold": Schema.optionalKey(Schema.Number.annotate({ "description": "The threshold for the score." }).check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalGraderPython", "identifier": "EvalGraderPython" })
export type EvalGraderScoreModel = { readonly "pass_threshold"?: number, readonly [x: string]: unknown }
export const EvalGraderScoreModel = Schema.StructWithRest(Schema.Struct({ "pass_threshold": Schema.optionalKey(Schema.Number.annotate({ "description": "The threshold for the score." }).check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalGraderScoreModel", "identifier": "EvalGraderScoreModel" })
export type EvalGraderStringCheck = { readonly [x: string]: unknown }
export const EvalGraderStringCheck = Schema.Record(Schema.String, Schema.Unknown).annotate({ "title": "StringCheckGrader", "identifier": "EvalGraderStringCheck" })
export type EvalGraderTextSimilarity = { readonly "pass_threshold": number, readonly [x: string]: unknown }
export const EvalGraderTextSimilarity = Schema.StructWithRest(Schema.Struct({ "pass_threshold": Schema.Number.annotate({ "description": "The threshold for the score." }).check(Schema.isFinite()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalGraderTextSimilarity", "identifier": "EvalGraderTextSimilarity" })
export type EvalItemContentOutputText = { readonly "type": "output_text", readonly "text": string, readonly [x: string]: unknown }
export const EvalItemContentOutputText = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("output_text").annotate({ "description": "The type of the output text. Always \`output_text\`.\\n" }), "text": Schema.String.annotate({ "description": "The text output from the model.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Output text", "description": "A text output from the model.\\n", "identifier": "EvalItemContentOutputText" })
export type EvalItemContentText = string
export const EvalItemContentText = Schema.String.annotate({ "title": "Text input", "description": "A text input to the model.\\n", "identifier": "EvalItemContentText" })
export type EvalItemInputImage = { readonly "type": "input_image", readonly "image_url": string, readonly "detail"?: string, readonly [x: string]: unknown }
export const EvalItemInputImage = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_image").annotate({ "description": "The type of the image input. Always \`input_image\`.\\n" }), "image_url": Schema.String.annotate({ "description": "The URL of the image input.\\n" }), "detail": Schema.optionalKey(Schema.String.annotate({ "description": "The detail level of the image to be sent to the model. One of \`high\`, \`low\`, or \`auto\`. Defaults to \`auto\`.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input image", "description": "An image input block used within EvalItem content arrays.", "identifier": "EvalItemInputImage" })
export type EvalJsonlFileContentSource = { readonly "type": "file_content", readonly "content": ReadonlyArray<{ readonly "item": { readonly [x: string]: unknown }, readonly "sample"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const EvalJsonlFileContentSource = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file_content").annotate({ "description": "The type of jsonl source. Always \`file_content\`.", "default": "file_content" }), "content": Schema.Array(Schema.StructWithRest(Schema.Struct({ "item": Schema.Record(Schema.String, Schema.Unknown), "sample": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown)) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The content of the jsonl file." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalJsonlFileContentSource", "identifier": "EvalJsonlFileContentSource" })
export type EvalJsonlFileIdSource = { readonly "type": "file_id", readonly "id": string, readonly [x: string]: unknown }
export const EvalJsonlFileIdSource = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file_id").annotate({ "description": "The type of jsonl source. Always \`file_id\`.", "default": "file_id" }), "id": Schema.String.annotate({ "description": "The identifier of the file." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalJsonlFileIdSource", "identifier": "EvalJsonlFileIdSource" })
export type EvalRunOutputItemResult = { readonly "name": string, readonly "type"?: string, readonly "score": number, readonly "passed": boolean, readonly "sample"?: { readonly [x: string]: unknown } | null, readonly [x: string]: unknown }
export const EvalRunOutputItemResult = Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the grader." }), "type": Schema.optionalKey(Schema.String.annotate({ "description": "The grader type (for example, \\"string-check-grader\\")." })), "score": Schema.Number.annotate({ "description": "The numeric score produced by the grader." }).check(Schema.isFinite()), "passed": Schema.Boolean.annotate({ "description": "Whether the grader considered the output a pass." }), "sample": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "Optional sample or intermediate data produced by the grader." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalRunOutputItemResult", "description": "A single grader result for an evaluation run output item.\\n", "identifier": "EvalRunOutputItemResult" })
export type FileExpirationAfter = { readonly "anchor": "created_at", readonly "seconds": number, readonly [x: string]: unknown }
export const FileExpirationAfter = Schema.StructWithRest(Schema.Struct({ "anchor": Schema.Literal("created_at").annotate({ "description": "Anchor timestamp after which the expiration policy applies. Supported anchors: \`created_at\`." }), "seconds": Schema.Number.annotate({ "description": "The number of seconds after the anchor time that the file will expire. Must be between 3600 (1 hour) and 2592000 (30 days)." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File expiration policy", "description": "The expiration policy for a file. By default, files with \`purpose=batch\` expire after 30 days and all other files are persisted until they are manually deleted.", "identifier": "FileExpirationAfter" })
export type FilePath = { readonly "type": "file_path", readonly "file_id": string, readonly "index": number, readonly [x: string]: unknown }
export const FilePath = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file_path").annotate({ "description": "The type of the file path. Always \`file_path\`.\\n" }), "file_id": Schema.String.annotate({ "description": "The ID of the file.\\n" }), "index": Schema.Number.annotate({ "description": "The index of the file in the list of files.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File path", "description": "A path to a file.\\n", "identifier": "FilePath" })
export type FileSearchRanker = "auto" | "default_2024_08_21"
export const FileSearchRanker = Schema.Literals(["auto", "default_2024_08_21"]).annotate({ "description": "The ranker to use for the file search. If not specified will use the \`auto\` ranker.", "identifier": "FileSearchRanker" })
export type FineTuneChatCompletionRequestAssistantMessage = never
export const FineTuneChatCompletionRequestAssistantMessage = Schema.Never.annotate({ "identifier": "FineTuneChatCompletionRequestAssistantMessage" })
export type FineTuneDPOHyperparameters = { readonly "beta"?: "auto" | number, readonly "batch_size"?: "auto" | number, readonly "learning_rate_multiplier"?: "auto" | number, readonly "n_epochs"?: "auto" | number, readonly [x: string]: unknown }
export const FineTuneDPOHyperparameters = Schema.StructWithRest(Schema.Struct({ "beta": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isFinite())]).annotate({ "description": "The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model.\\n" })), "batch_size": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isInt())]).annotate({ "description": "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\\n", "default": "auto" })), "learning_rate_multiplier": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isFinite())]).annotate({ "description": "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\\n" })), "n_epochs": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isInt())]).annotate({ "description": "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\\n", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The hyperparameters used for the DPO fine-tuning job.", "identifier": "FineTuneDPOHyperparameters" })
export type FineTuneReinforcementHyperparameters = { readonly "batch_size"?: "auto" | number, readonly "learning_rate_multiplier"?: "auto" | number, readonly "n_epochs"?: "auto" | number, readonly "reasoning_effort"?: "default" | "low" | "medium" | "high", readonly "compute_multiplier"?: "auto" | number, readonly "eval_interval"?: "auto" | number, readonly "eval_samples"?: "auto" | number, readonly [x: string]: unknown }
export const FineTuneReinforcementHyperparameters = Schema.StructWithRest(Schema.Struct({ "batch_size": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isInt())]).annotate({ "description": "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\\n", "default": "auto" })), "learning_rate_multiplier": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isFinite())]).annotate({ "description": "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\\n" })), "n_epochs": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isInt())]).annotate({ "description": "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\\n", "default": "auto" })), "reasoning_effort": Schema.optionalKey(Schema.Literals(["default", "low", "medium", "high"]).annotate({ "description": "Level of reasoning effort.\\n", "default": "default" })), "compute_multiplier": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isFinite())]).annotate({ "description": "Multiplier on amount of compute used for exploring search space during training.\\n" })), "eval_interval": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isInt())]).annotate({ "description": "The number of training steps between evaluation runs.\\n", "default": "auto" })), "eval_samples": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isInt())]).annotate({ "description": "Number of evaluation samples to generate per training step.\\n", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The hyperparameters used for the reinforcement fine-tuning job.", "identifier": "FineTuneReinforcementHyperparameters" })
export type FineTuneSupervisedHyperparameters = { readonly "batch_size"?: "auto" | number, readonly "learning_rate_multiplier"?: "auto" | number, readonly "n_epochs"?: "auto" | number, readonly [x: string]: unknown }
export const FineTuneSupervisedHyperparameters = Schema.StructWithRest(Schema.Struct({ "batch_size": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isInt())]).annotate({ "description": "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\\n", "default": "auto" })), "learning_rate_multiplier": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isFinite())]).annotate({ "description": "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\\n" })), "n_epochs": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isInt())]).annotate({ "description": "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\\n", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The hyperparameters used for the fine-tuning job.", "identifier": "FineTuneSupervisedHyperparameters" })
export type FineTuningCheckpointPermission = { readonly "id": string, readonly "created_at": number, readonly "project_id": string, readonly "object": "checkpoint.permission", readonly [x: string]: unknown }
export const FineTuningCheckpointPermission = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The permission identifier, which can be referenced in the API endpoints." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the permission was created." }).check(Schema.isInt()), "project_id": Schema.String.annotate({ "description": "The project identifier that the permission is for." }), "object": Schema.Literal("checkpoint.permission").annotate({ "description": "The object type, which is always \\"checkpoint.permission\\"." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "FineTuningCheckpointPermission", "description": "The \`checkpoint.permission\` object represents a permission for a fine-tuned model checkpoint.\\n", "identifier": "FineTuningCheckpointPermission" })
export type FineTuningIntegration = { readonly "type": "wandb", readonly "wandb": { readonly "project": string, readonly "name"?: string | null, readonly "entity"?: string | null, readonly "tags"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const FineTuningIntegration = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("wandb").annotate({ "description": "The type of the integration being enabled for the fine-tuning job" }), "wandb": Schema.StructWithRest(Schema.Struct({ "project": Schema.String.annotate({ "description": "The name of the project that the new run will be created under.\\n" }), "name": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "A display name to set for the run. If not set, we will use the Job ID as the name.\\n" }), Schema.Null])), "entity": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The entity to use for the run. This allows you to set the team or username of the WandB user that you would\\nlike associated with the run. If not set, the default entity for the registered WandB API key is used.\\n" }), Schema.Null])), "tags": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some\\ndefault tags are generated by OpenAI: \\"openai/finetune\\", \\"openai/{base-model}\\", \\"openai/{ftjob-abcdef}\\".\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The settings for your integration with Weights and Biases. This payload specifies the project that\\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\\nto your run, and set a default entity (team, username, etc) to be associated with your run.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Fine-Tuning Job Integration", "identifier": "FineTuningIntegration" })
export type FineTuningJobCheckpoint = { readonly "id": string, readonly "created_at": number, readonly "fine_tuned_model_checkpoint": string, readonly "step_number": number, readonly "metrics": { readonly "step"?: number, readonly "train_loss"?: number, readonly "train_mean_token_accuracy"?: number, readonly "valid_loss"?: number, readonly "valid_mean_token_accuracy"?: number, readonly "full_valid_loss"?: number, readonly "full_valid_mean_token_accuracy"?: number, readonly [x: string]: unknown }, readonly "fine_tuning_job_id": string, readonly "object": "fine_tuning.job.checkpoint", readonly [x: string]: unknown }
export const FineTuningJobCheckpoint = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The checkpoint identifier, which can be referenced in the API endpoints." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the checkpoint was created." }).check(Schema.isInt()), "fine_tuned_model_checkpoint": Schema.String.annotate({ "description": "The name of the fine-tuned checkpoint model that is created." }), "step_number": Schema.Number.annotate({ "description": "The step number that the checkpoint was created at." }).check(Schema.isInt()), "metrics": Schema.StructWithRest(Schema.Struct({ "step": Schema.optionalKey(Schema.Number.check(Schema.isFinite())), "train_loss": Schema.optionalKey(Schema.Number.check(Schema.isFinite())), "train_mean_token_accuracy": Schema.optionalKey(Schema.Number.check(Schema.isFinite())), "valid_loss": Schema.optionalKey(Schema.Number.check(Schema.isFinite())), "valid_mean_token_accuracy": Schema.optionalKey(Schema.Number.check(Schema.isFinite())), "full_valid_loss": Schema.optionalKey(Schema.Number.check(Schema.isFinite())), "full_valid_mean_token_accuracy": Schema.optionalKey(Schema.Number.check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Metrics at the step number during the fine-tuning job." }), "fine_tuning_job_id": Schema.String.annotate({ "description": "The name of the fine-tuning job that this checkpoint was created from." }), "object": Schema.Literal("fine_tuning.job.checkpoint").annotate({ "description": "The object type, which is always \\"fine_tuning.job.checkpoint\\"." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "FineTuningJobCheckpoint", "description": "The \`fine_tuning.job.checkpoint\` object represents a model checkpoint for a fine-tuning job that is ready to use.\\n", "identifier": "FineTuningJobCheckpoint" })
export type FineTuningJobEvent = { readonly "object": "fine_tuning.job.event", readonly "id": string, readonly "created_at": number, readonly "level": "info" | "warn" | "error", readonly "message": string, readonly "type"?: "message" | "metrics", readonly "data"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const FineTuningJobEvent = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("fine_tuning.job.event").annotate({ "description": "The object type, which is always \\"fine_tuning.job.event\\"." }), "id": Schema.String.annotate({ "description": "The object identifier." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the fine-tuning job was created." }).check(Schema.isInt()), "level": Schema.Literals(["info", "warn", "error"]).annotate({ "description": "The log level of the event." }), "message": Schema.String.annotate({ "description": "The message of the event." }), "type": Schema.optionalKey(Schema.Literals(["message", "metrics"]).annotate({ "description": "The type of event." })), "data": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The data associated with the event." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Fine-tuning job event object", "identifier": "FineTuningJobEvent" })
export type FunctionParameters = { readonly [x: string]: unknown }
export const FunctionParameters = Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format. \\n\\nOmitting \`parameters\` defines a function with an empty parameter list.", "identifier": "FunctionParameters" })
export type FunctionToolCall = { readonly "id"?: string, readonly "type": "function_call", readonly "call_id": string, readonly "name": string, readonly "arguments": string, readonly "status"?: "in_progress" | "completed" | "incomplete", readonly [x: string]: unknown }
export const FunctionToolCall = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the function tool call.\\n" })), "type": Schema.Literal("function_call").annotate({ "description": "The type of the function tool call. Always \`function_call\`.\\n" }), "call_id": Schema.String.annotate({ "description": "The unique ID of the function tool call generated by the model.\\n" }), "name": Schema.String.annotate({ "description": "The name of the function to run.\\n" }), "arguments": Schema.String.annotate({ "description": "A JSON string of the arguments to pass to the function.\\n" }), "status": Schema.optionalKey(Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "description": "The status of the item. One of \`in_progress\`, \`completed\`, or\\n\`incomplete\`. Populated when items are returned via API.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool call", "description": "A tool call to run a function. See the \\n[function calling guide](https://platform.openai.com/docs/guides/function-calling) for more information.\\n", "identifier": "FunctionToolCall" })
export type FunctionToolCallOutputResource = never
export const FunctionToolCallOutputResource = Schema.Never.annotate({ "identifier": "FunctionToolCallOutputResource" })
export type FunctionToolCallResource = never
export const FunctionToolCallResource = Schema.Never.annotate({ "identifier": "FunctionToolCallResource" })
export type GraderPython = { readonly "type": "python", readonly "name": string, readonly "source": string, readonly "image_tag"?: string, readonly [x: string]: unknown }
export const GraderPython = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("python").annotate({ "description": "The object type, which is always \`python\`." }), "name": Schema.String.annotate({ "description": "The name of the grader." }), "source": Schema.String.annotate({ "description": "The source code of the python script." }), "image_tag": Schema.optionalKey(Schema.String.annotate({ "description": "The image tag to use for the python script." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "PythonGrader", "description": "A PythonGrader object that runs a python script on the input.\\n", "identifier": "GraderPython" })
export type GraderStringCheck = { readonly "type": "string_check", readonly "name": string, readonly "input": string, readonly "reference": string, readonly "operation": "eq" | "ne" | "like" | "ilike", readonly [x: string]: unknown }
export const GraderStringCheck = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("string_check").annotate({ "description": "The object type, which is always \`string_check\`." }), "name": Schema.String.annotate({ "description": "The name of the grader." }), "input": Schema.String.annotate({ "description": "The input text. This may include template strings." }), "reference": Schema.String.annotate({ "description": "The reference text. This may include template strings." }), "operation": Schema.Literals(["eq", "ne", "like", "ilike"]).annotate({ "description": "The string check operation to perform. One of \`eq\`, \`ne\`, \`like\`, or \`ilike\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "StringCheckGrader", "description": "A StringCheckGrader object that performs a string comparison between input and reference using a specified operation.\\n", "identifier": "GraderStringCheck" })
export type GraderTextSimilarity = { readonly "type": "text_similarity", readonly "name": string, readonly "input": string, readonly "reference": string, readonly "evaluation_metric": "cosine" | "fuzzy_match" | "bleu" | "gleu" | "meteor" | "rouge_1" | "rouge_2" | "rouge_3" | "rouge_4" | "rouge_5" | "rouge_l", readonly [x: string]: unknown }
export const GraderTextSimilarity = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("text_similarity").annotate({ "description": "The type of grader.", "default": "text_similarity" }), "name": Schema.String.annotate({ "description": "The name of the grader." }), "input": Schema.String.annotate({ "description": "The text being graded." }), "reference": Schema.String.annotate({ "description": "The text being graded against." }), "evaluation_metric": Schema.Literals(["cosine", "fuzzy_match", "bleu", "gleu", "meteor", "rouge_1", "rouge_2", "rouge_3", "rouge_4", "rouge_5", "rouge_l"]).annotate({ "description": "The evaluation metric to use. One of \`cosine\`, \`fuzzy_match\`, \`bleu\`, \\n\`gleu\`, \`meteor\`, \`rouge_1\`, \`rouge_2\`, \`rouge_3\`, \`rouge_4\`, \`rouge_5\`, \\nor \`rouge_l\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "TextSimilarityGrader", "description": "A TextSimilarityGrader object which grades text based on similarity metrics.\\n", "identifier": "GraderTextSimilarity" })
export type Group = { readonly "object": "group", readonly "id": string, readonly "name": string, readonly "created_at": number, readonly "scim_managed": boolean, readonly [x: string]: unknown }
export const Group = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("group").annotate({ "description": "Always \`group\`." }), "id": Schema.String.annotate({ "description": "Identifier for the group." }), "name": Schema.String.annotate({ "description": "Display name of the group." }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the group was created.", "format": "int64" }).check(Schema.isInt()), "scim_managed": Schema.Boolean.annotate({ "description": "Whether the group is managed through SCIM." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Summary information about a group returned in role assignment responses.", "identifier": "Group" })
export type GroupDeletedResource = { readonly "object": "group.deleted", readonly "id": string, readonly "deleted": boolean, readonly [x: string]: unknown }
export const GroupDeletedResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("group.deleted").annotate({ "description": "Always \`group.deleted\`." }), "id": Schema.String.annotate({ "description": "Identifier of the deleted group." }), "deleted": Schema.Boolean.annotate({ "description": "Whether the group was deleted." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Confirmation payload returned after deleting a group.", "identifier": "GroupDeletedResource" })
export type GroupResourceWithSuccess = { readonly "id": string, readonly "name": string, readonly "created_at": number, readonly "is_scim_managed": boolean, readonly [x: string]: unknown }
export const GroupResourceWithSuccess = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier for the group." }), "name": Schema.String.annotate({ "description": "Updated display name for the group." }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the group was created.", "format": "int64" }).check(Schema.isInt()), "is_scim_managed": Schema.Boolean.annotate({ "description": "Whether the group is managed through SCIM and controlled by your identity provider." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Response returned after updating a group.", "identifier": "GroupResourceWithSuccess" })
export type GroupResponse = { readonly "id": string, readonly "name": string, readonly "created_at": number, readonly "is_scim_managed": boolean, readonly [x: string]: unknown }
export const GroupResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier for the group." }), "name": Schema.String.annotate({ "description": "Display name of the group." }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the group was created.", "format": "int64" }).check(Schema.isInt()), "is_scim_managed": Schema.Boolean.annotate({ "description": "Whether the group is managed through SCIM and controlled by your identity provider." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details about an organization group.", "identifier": "GroupResponse" })
export type GroupUserAssignment = { readonly "object": "group.user", readonly "user_id": string, readonly "group_id": string, readonly [x: string]: unknown }
export const GroupUserAssignment = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("group.user").annotate({ "description": "Always \`group.user\`." }), "user_id": Schema.String.annotate({ "description": "Identifier of the user that was added." }), "group_id": Schema.String.annotate({ "description": "Identifier of the group the user was added to." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Confirmation payload returned after adding a user to a group.", "identifier": "GroupUserAssignment" })
export type GroupUserDeletedResource = { readonly "object": "group.user.deleted", readonly "deleted": boolean, readonly [x: string]: unknown }
export const GroupUserDeletedResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("group.user.deleted").annotate({ "description": "Always \`group.user.deleted\`." }), "deleted": Schema.Boolean.annotate({ "description": "Whether the group membership was removed." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Confirmation payload returned after removing a user from a group.", "identifier": "GroupUserDeletedResource" })
export type Image = { readonly "b64_json"?: string, readonly "url"?: string, readonly "revised_prompt"?: string, readonly [x: string]: unknown }
export const Image = Schema.StructWithRest(Schema.Struct({ "b64_json": Schema.optionalKey(Schema.String.annotate({ "description": "The base64-encoded JSON of the generated image. Returned by default for the GPT image models, and only present if \`response_format\` is set to \`b64_json\` for \`dall-e-2\` and \`dall-e-3\`." })), "url": Schema.optionalKey(Schema.String.annotate({ "description": "When using \`dall-e-2\` or \`dall-e-3\`, the URL of the generated image if \`response_format\` is set to \`url\` (default value). Unsupported for the GPT image models." })), "revised_prompt": Schema.optionalKey(Schema.String.annotate({ "description": "For \`dall-e-3\` only, the revised prompt that was used to generate the image." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents the content or the URL of an image generated by the OpenAI API.", "identifier": "Image" })
export type ImageEditPartialImageEvent = { readonly "type": "image_edit.partial_image", readonly "b64_json": string, readonly "created_at": number, readonly "size": "1024x1024" | "1024x1536" | "1536x1024" | "auto", readonly "quality": "low" | "medium" | "high" | "auto", readonly "background": "transparent" | "opaque" | "auto", readonly "output_format": "png" | "webp" | "jpeg", readonly "partial_image_index": number, readonly [x: string]: unknown }
export const ImageEditPartialImageEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image_edit.partial_image").annotate({ "description": "The type of the event. Always \`image_edit.partial_image\`.\\n" }), "b64_json": Schema.String.annotate({ "description": "Base64-encoded partial image data, suitable for rendering as an image.\\n" }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp when the event was created.\\n" }).check(Schema.isInt()), "size": Schema.Literals(["1024x1024", "1024x1536", "1536x1024", "auto"]).annotate({ "description": "The size of the requested edited image.\\n" }), "quality": Schema.Literals(["low", "medium", "high", "auto"]).annotate({ "description": "The quality setting for the requested edited image.\\n" }), "background": Schema.Literals(["transparent", "opaque", "auto"]).annotate({ "description": "The background setting for the requested edited image.\\n" }), "output_format": Schema.Literals(["png", "webp", "jpeg"]).annotate({ "description": "The output format for the requested edited image.\\n" }), "partial_image_index": Schema.Number.annotate({ "description": "0-based index for the partial image (streaming).\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a partial image is available during image editing streaming.\\n", "identifier": "ImageEditPartialImageEvent" })
export type ImageGenPartialImageEvent = { readonly "type": "image_generation.partial_image", readonly "b64_json": string, readonly "created_at": number, readonly "size": "1024x1024" | "1024x1536" | "1536x1024" | "auto", readonly "quality": "low" | "medium" | "high" | "auto", readonly "background": "transparent" | "opaque" | "auto", readonly "output_format": "png" | "webp" | "jpeg", readonly "partial_image_index": number, readonly [x: string]: unknown }
export const ImageGenPartialImageEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image_generation.partial_image").annotate({ "description": "The type of the event. Always \`image_generation.partial_image\`.\\n" }), "b64_json": Schema.String.annotate({ "description": "Base64-encoded partial image data, suitable for rendering as an image.\\n" }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp when the event was created.\\n" }).check(Schema.isInt()), "size": Schema.Literals(["1024x1024", "1024x1536", "1536x1024", "auto"]).annotate({ "description": "The size of the requested image.\\n" }), "quality": Schema.Literals(["low", "medium", "high", "auto"]).annotate({ "description": "The quality setting for the requested image.\\n" }), "background": Schema.Literals(["transparent", "opaque", "auto"]).annotate({ "description": "The background setting for the requested image.\\n" }), "output_format": Schema.Literals(["png", "webp", "jpeg"]).annotate({ "description": "The output format for the requested image.\\n" }), "partial_image_index": Schema.Number.annotate({ "description": "0-based index for the partial image (streaming).\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a partial image is available during image generation streaming.\\n", "identifier": "ImageGenPartialImageEvent" })
export type ImageGenToolCall = { readonly "type": "image_generation_call", readonly "id": string, readonly "status": "in_progress" | "completed" | "generating" | "failed", readonly "result": string | null, readonly [x: string]: unknown }
export const ImageGenToolCall = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image_generation_call").annotate({ "description": "The type of the image generation call. Always \`image_generation_call\`.\\n" }), "id": Schema.String.annotate({ "description": "The unique ID of the image generation call.\\n" }), "status": Schema.Literals(["in_progress", "completed", "generating", "failed"]).annotate({ "description": "The status of the image generation call.\\n" }), "result": Schema.Union([Schema.String.annotate({ "description": "The generated image encoded in base64.\\n" }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Image generation call", "description": "An image generation request made by the model.\\n", "identifier": "ImageGenToolCall" })
export type ImagesUsage = { readonly "total_tokens": number, readonly "input_tokens": number, readonly "output_tokens": number, readonly "input_tokens_details": { readonly "text_tokens": number, readonly "image_tokens": number, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ImagesUsage = Schema.StructWithRest(Schema.Struct({ "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens (images and text) used for the image generation.\\n" }).check(Schema.isInt()), "input_tokens": Schema.Number.annotate({ "description": "The number of tokens (images and text) in the input prompt." }).check(Schema.isInt()), "output_tokens": Schema.Number.annotate({ "description": "The number of image tokens in the output image." }).check(Schema.isInt()), "input_tokens_details": Schema.StructWithRest(Schema.Struct({ "text_tokens": Schema.Number.annotate({ "description": "The number of text tokens in the input prompt." }).check(Schema.isInt()), "image_tokens": Schema.Number.annotate({ "description": "The number of image tokens in the input prompt." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The input tokens detailed information for the image generation." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "For the GPT image models only, the token usage information for the image generation.\\n", "identifier": "ImagesUsage" })
export type InputAudio = { readonly "type": "input_audio", readonly "input_audio": { readonly "data": string, readonly "format": "mp3" | "wav", readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const InputAudio = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_audio").annotate({ "description": "The type of the input item. Always \`input_audio\`.\\n" }), "input_audio": Schema.StructWithRest(Schema.Struct({ "data": Schema.String.annotate({ "description": "Base64-encoded audio data.\\n" }), "format": Schema.Literals(["mp3", "wav"]).annotate({ "description": "The format of the audio data. Currently supported formats are \`mp3\` and\\n\`wav\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input audio", "description": "An audio input to the model.\\n", "identifier": "InputAudio" })
export type InputMessageResource = never
export const InputMessageResource = Schema.Never.annotate({ "identifier": "InputMessageResource" })
export type Invite = { readonly "object": "organization.invite", readonly "id": string, readonly "email": string, readonly "role": "owner" | "reader", readonly "status": "accepted" | "expired" | "pending", readonly "invited_at": number, readonly "expires_at": number, readonly "accepted_at"?: number, readonly "projects"?: ReadonlyArray<{ readonly "id"?: string, readonly "role"?: "member" | "owner", readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const Invite = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.invite").annotate({ "description": "The object type, which is always \`organization.invite\`" }), "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }), "email": Schema.String.annotate({ "description": "The email address of the individual to whom the invite was sent" }), "role": Schema.Literals(["owner", "reader"]).annotate({ "description": "\`owner\` or \`reader\`" }), "status": Schema.Literals(["accepted", "expired", "pending"]).annotate({ "description": "\`accepted\`,\`expired\`, or \`pending\`" }), "invited_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the invite was sent." }).check(Schema.isInt()), "expires_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the invite expires." }).check(Schema.isInt()), "accepted_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the invite was accepted." }).check(Schema.isInt())), "projects": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "Project's public ID" })), "role": Schema.optionalKey(Schema.Literals(["member", "owner"]).annotate({ "description": "Project membership role" })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The projects that were granted membership upon acceptance of the invite." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents an individual \`invite\` to the organization.", "identifier": "Invite" })
export type InviteDeleteResponse = { readonly "object": "organization.invite.deleted", readonly "id": string, readonly "deleted": boolean, readonly [x: string]: unknown }
export const InviteDeleteResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.invite.deleted").annotate({ "description": "The object type, which is always \`organization.invite.deleted\`" }), "id": Schema.String, "deleted": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "InviteDeleteResponse" })
export type InviteProjectGroupBody = { readonly "group_id": string, readonly "role": string, readonly [x: string]: unknown }
export const InviteProjectGroupBody = Schema.StructWithRest(Schema.Struct({ "group_id": Schema.String.annotate({ "description": "Identifier of the group to add to the project." }), "role": Schema.String.annotate({ "description": "Identifier of the project role to grant to the group." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Request payload for granting a group access to a project.", "identifier": "InviteProjectGroupBody" })
export type InviteRequest = { readonly "email": string, readonly "role": "reader" | "owner", readonly "projects"?: ReadonlyArray<{ readonly "id": string, readonly "role": "member" | "owner", readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const InviteRequest = Schema.StructWithRest(Schema.Struct({ "email": Schema.String.annotate({ "description": "Send an email to this address" }), "role": Schema.Literals(["reader", "owner"]).annotate({ "description": "\`owner\` or \`reader\`" }), "projects": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Project's public ID" }), "role": Schema.Literals(["member", "owner"]).annotate({ "description": "Project membership role" }) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "An array of projects to which membership is granted at the same time the org invite is accepted. If omitted, the user will be invited to the default project for compatibility with legacy behavior." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "InviteRequest" })
export type LocalShellToolCallOutput = { readonly "type": "local_shell_call_output", readonly "id": string, readonly "output": string, readonly "status"?: "in_progress" | "completed" | "incomplete" | null, readonly "call_id": unknown, readonly [x: string]: unknown }
export const LocalShellToolCallOutput = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("local_shell_call_output").annotate({ "description": "The type of the local shell tool call output. Always \`local_shell_call_output\`.\\n" }), "id": Schema.String.annotate({ "description": "The unique ID of the local shell tool call generated by the model.\\n" }), "output": Schema.String.annotate({ "description": "A JSON string of the output of the local shell tool call.\\n" }), "status": Schema.optionalKey(Schema.Union([Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "description": "The status of the item. One of \`in_progress\`, \`completed\`, or \`incomplete\`.\\n" }), Schema.Null])), "call_id": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Local shell call output", "description": "The output of a local shell tool call.\\n", "identifier": "LocalShellToolCallOutput" })
export type LogProbProperties = { readonly "token": string, readonly "logprob": number, readonly "bytes": ReadonlyArray<number>, readonly [x: string]: unknown }
export const LogProbProperties = Schema.StructWithRest(Schema.Struct({ "token": Schema.String.annotate({ "description": "The token that was used to generate the log probability.\\n" }), "logprob": Schema.Number.annotate({ "description": "The log probability of the token.\\n" }).check(Schema.isFinite()), "bytes": Schema.Array(Schema.Number.check(Schema.isInt())).annotate({ "description": "The bytes that were used to generate the log probability.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A log probability object.\\n", "identifier": "LogProbProperties" })
export type MCPApprovalRequest = { readonly "type": "mcp_approval_request", readonly "id": string, readonly "server_label": string, readonly "name": string, readonly "arguments": string, readonly [x: string]: unknown }
export const MCPApprovalRequest = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp_approval_request").annotate({ "description": "The type of the item. Always \`mcp_approval_request\`.\\n" }), "id": Schema.String.annotate({ "description": "The unique ID of the approval request.\\n" }), "server_label": Schema.String.annotate({ "description": "The label of the MCP server making the request.\\n" }), "name": Schema.String.annotate({ "description": "The name of the tool to run.\\n" }), "arguments": Schema.String.annotate({ "description": "A JSON string of arguments for the tool.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "MCP approval request", "description": "A request for human approval of a tool invocation.\\n", "identifier": "MCPApprovalRequest" })
export type MCPApprovalResponse = { readonly "type": "mcp_approval_response", readonly "id"?: string | null, readonly "approval_request_id": string, readonly "approve": boolean, readonly "reason"?: string | null, readonly "request_id": unknown, readonly [x: string]: unknown }
export const MCPApprovalResponse = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp_approval_response").annotate({ "description": "The type of the item. Always \`mcp_approval_response\`.\\n" }), "id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The unique ID of the approval response\\n" }), Schema.Null])), "approval_request_id": Schema.String.annotate({ "description": "The ID of the approval request being answered.\\n" }), "approve": Schema.Boolean.annotate({ "description": "Whether the request was approved.\\n" }), "reason": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Optional reason for the decision.\\n" }), Schema.Null])), "request_id": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "MCP approval response", "description": "A response to an MCP approval request.\\n", "identifier": "MCPApprovalResponse" })
export type MCPApprovalResponseResource = { readonly "type": "mcp_approval_response", readonly "id": string, readonly "approval_request_id": string, readonly "approve": boolean, readonly "reason"?: string | null, readonly "request_id": unknown, readonly [x: string]: unknown }
export const MCPApprovalResponseResource = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp_approval_response").annotate({ "description": "The type of the item. Always \`mcp_approval_response\`.\\n" }), "id": Schema.String.annotate({ "description": "The unique ID of the approval response\\n" }), "approval_request_id": Schema.String.annotate({ "description": "The ID of the approval request being answered.\\n" }), "approve": Schema.Boolean.annotate({ "description": "Whether the request was approved.\\n" }), "reason": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Optional reason for the decision.\\n" }), Schema.Null])), "request_id": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "MCP approval response", "description": "A response to an MCP approval request.\\n", "identifier": "MCPApprovalResponseResource" })
export type MCPListToolsTool = { readonly "name": string, readonly "description"?: string | null, readonly "input_schema": { readonly [x: string]: unknown }, readonly "annotations"?: { readonly [x: string]: unknown } | null, readonly [x: string]: unknown }
export const MCPListToolsTool = Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the tool.\\n" }), "description": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The description of the tool.\\n" }), Schema.Null])), "input_schema": Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The JSON schema describing the tool's input.\\n" }), "annotations": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "Additional annotations about the tool.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "MCP list tools tool", "description": "A tool available on an MCP server.\\n", "identifier": "MCPListToolsTool" })
export type MCPToolCall = { readonly "type": "mcp_call", readonly "id": string, readonly "server_label": string, readonly "name": string, readonly "arguments": string, readonly "output"?: string | null, readonly "error"?: string | null, readonly "status"?: unknown, readonly "approval_request_id"?: string | null, readonly [x: string]: unknown }
export const MCPToolCall = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp_call").annotate({ "description": "The type of the item. Always \`mcp_call\`.\\n" }), "id": Schema.String.annotate({ "description": "The unique ID of the tool call.\\n" }), "server_label": Schema.String.annotate({ "description": "The label of the MCP server running the tool.\\n" }), "name": Schema.String.annotate({ "description": "The name of the tool that was run.\\n" }), "arguments": Schema.String.annotate({ "description": "A JSON string of the arguments passed to the tool.\\n" }), "output": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The output from the tool call.\\n" }), Schema.Null])), "error": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The error from the tool call, if any.\\n" }), Schema.Null])), "status": Schema.optionalKey(Schema.Unknown.annotate({ "description": "The status of the tool call. One of \`in_progress\`, \`completed\`, \`incomplete\`, \`calling\`, or \`failed\`.\\n" })), "approval_request_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Unique identifier for the MCP tool call approval request.\\nInclude this value in a subsequent \`mcp_approval_response\` input to approve or reject the corresponding tool call.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "MCP tool call", "description": "An invocation of a tool on an MCP server.\\n", "identifier": "MCPToolCall" })
export type MCPToolFilter = { readonly "tool_names"?: ReadonlyArray<string>, readonly "read_only"?: boolean }
export const MCPToolFilter = Schema.Struct({ "tool_names": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "title": "MCP allowed tools", "description": "List of allowed tool names." })), "read_only": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Indicates whether or not a tool modifies data or is read-only. If an\\nMCP server is [annotated with \`readOnlyHint\`](https://modelcontextprotocol.io/specification/2025-06-18/schema#toolannotations-readonlyhint),\\nit will match this filter.\\n" })) }).annotate({ "title": "MCP tool filter", "description": "A filter object to specify which tools are allowed.\\n", "identifier": "MCPToolFilter" })
export type MessageContentImageFileObject = { readonly "type": "image_file", readonly "image_file": { readonly "file_id": string, readonly "detail"?: "auto" | "low" | "high", readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const MessageContentImageFileObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image_file").annotate({ "description": "Always \`image_file\`." }), "image_file": Schema.StructWithRest(Schema.Struct({ "file_id": Schema.String.annotate({ "description": "The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set \`purpose=\\"vision\\"\` when uploading the File if you need to later display the file content." }), "detail": Schema.optionalKey(Schema.Literals(["auto", "low", "high"]).annotate({ "description": "Specifies the detail level of the image if specified by the user. \`low\` uses fewer tokens, you can opt in to high resolution using \`high\`.", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Image file", "description": "References an image [File](https://platform.openai.com/docs/api-reference/files) in the content of a message.", "identifier": "MessageContentImageFileObject" })
export type MessageContentImageUrlObject = { readonly "type": "image_url", readonly "image_url": { readonly "url": string, readonly "detail"?: "auto" | "low" | "high", readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const MessageContentImageUrlObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image_url").annotate({ "description": "The type of the content part." }), "image_url": Schema.StructWithRest(Schema.Struct({ "url": Schema.String.annotate({ "description": "The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.", "format": "uri" }), "detail": Schema.optionalKey(Schema.Literals(["auto", "low", "high"]).annotate({ "description": "Specifies the detail level of the image. \`low\` uses fewer tokens, you can opt in to high resolution using \`high\`. Default value is \`auto\`", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Image URL", "description": "References an image URL in the content of a message.", "identifier": "MessageContentImageUrlObject" })
export type MessageContentRefusalObject = { readonly "type": "refusal", readonly "refusal": string, readonly [x: string]: unknown }
export const MessageContentRefusalObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("refusal").annotate({ "description": "Always \`refusal\`." }), "refusal": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Refusal", "description": "The refusal content generated by the assistant.", "identifier": "MessageContentRefusalObject" })
export type MessageContentTextAnnotationsFileCitationObject = { readonly "type": "file_citation", readonly "text": string, readonly "file_citation": { readonly "file_id": string, readonly [x: string]: unknown }, readonly "start_index": number, readonly "end_index": number, readonly [x: string]: unknown }
export const MessageContentTextAnnotationsFileCitationObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file_citation").annotate({ "description": "Always \`file_citation\`." }), "text": Schema.String.annotate({ "description": "The text in the message content that needs to be replaced." }), "file_citation": Schema.StructWithRest(Schema.Struct({ "file_id": Schema.String.annotate({ "description": "The ID of the specific File the citation is from." }) }), [Schema.Record(Schema.String, Schema.Unknown)]), "start_index": Schema.Number.check(Schema.isInt()), "end_index": Schema.Number.check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File citation", "description": "A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \\"file_search\\" tool to search files.", "identifier": "MessageContentTextAnnotationsFileCitationObject" })
export type MessageContentTextAnnotationsFilePathObject = { readonly "type": "file_path", readonly "text": string, readonly "file_path": { readonly "file_id": string, readonly [x: string]: unknown }, readonly "start_index": number, readonly "end_index": number, readonly [x: string]: unknown }
export const MessageContentTextAnnotationsFilePathObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file_path").annotate({ "description": "Always \`file_path\`." }), "text": Schema.String.annotate({ "description": "The text in the message content that needs to be replaced." }), "file_path": Schema.StructWithRest(Schema.Struct({ "file_id": Schema.String.annotate({ "description": "The ID of the file that was generated." }) }), [Schema.Record(Schema.String, Schema.Unknown)]), "start_index": Schema.Number.check(Schema.isInt()), "end_index": Schema.Number.check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File path", "description": "A URL for the file that's generated when the assistant used the \`code_interpreter\` tool to generate a file.", "identifier": "MessageContentTextAnnotationsFilePathObject" })
export type MessageDeltaContentImageFileObject = { readonly "index": number, readonly "type": "image_file", readonly "image_file"?: { readonly "file_id"?: string, readonly "detail"?: "auto" | "low" | "high", readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const MessageDeltaContentImageFileObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the content part in the message." }).check(Schema.isInt()), "type": Schema.Literal("image_file").annotate({ "description": "Always \`image_file\`." }), "image_file": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set \`purpose=\\"vision\\"\` when uploading the File if you need to later display the file content." })), "detail": Schema.optionalKey(Schema.Literals(["auto", "low", "high"]).annotate({ "description": "Specifies the detail level of the image if specified by the user. \`low\` uses fewer tokens, you can opt in to high resolution using \`high\`.", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Image file", "description": "References an image [File](https://platform.openai.com/docs/api-reference/files) in the content of a message.", "identifier": "MessageDeltaContentImageFileObject" })
export type MessageDeltaContentImageUrlObject = { readonly "index": number, readonly "type": "image_url", readonly "image_url"?: { readonly "url"?: string, readonly "detail"?: "auto" | "low" | "high", readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const MessageDeltaContentImageUrlObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the content part in the message." }).check(Schema.isInt()), "type": Schema.Literal("image_url").annotate({ "description": "Always \`image_url\`." }), "image_url": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "url": Schema.optionalKey(Schema.String.annotate({ "description": "The URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp." })), "detail": Schema.optionalKey(Schema.Literals(["auto", "low", "high"]).annotate({ "description": "Specifies the detail level of the image. \`low\` uses fewer tokens, you can opt in to high resolution using \`high\`.", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Image URL", "description": "References an image URL in the content of a message.", "identifier": "MessageDeltaContentImageUrlObject" })
export type MessageDeltaContentRefusalObject = { readonly "index": number, readonly "type": "refusal", readonly "refusal"?: string, readonly [x: string]: unknown }
export const MessageDeltaContentRefusalObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the refusal part in the message." }).check(Schema.isInt()), "type": Schema.Literal("refusal").annotate({ "description": "Always \`refusal\`." }), "refusal": Schema.optionalKey(Schema.String) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Refusal", "description": "The refusal content that is part of a message.", "identifier": "MessageDeltaContentRefusalObject" })
export type MessageDeltaContentTextAnnotationsFileCitationObject = { readonly "index": number, readonly "type": "file_citation", readonly "text"?: string, readonly "file_citation"?: { readonly "file_id"?: string, readonly "quote"?: string, readonly [x: string]: unknown }, readonly "start_index"?: number, readonly "end_index"?: number, readonly [x: string]: unknown }
export const MessageDeltaContentTextAnnotationsFileCitationObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the annotation in the text content part." }).check(Schema.isInt()), "type": Schema.Literal("file_citation").annotate({ "description": "Always \`file_citation\`." }), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text in the message content that needs to be replaced." })), "file_citation": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the specific File the citation is from." })), "quote": Schema.optionalKey(Schema.String.annotate({ "description": "The specific quote in the file." })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "start_index": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "end_index": Schema.optionalKey(Schema.Number.check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File citation", "description": "A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \\"file_search\\" tool to search files.", "identifier": "MessageDeltaContentTextAnnotationsFileCitationObject" })
export type MessageDeltaContentTextAnnotationsFilePathObject = { readonly "index": number, readonly "type": "file_path", readonly "text"?: string, readonly "file_path"?: { readonly "file_id"?: string, readonly [x: string]: unknown }, readonly "start_index"?: number, readonly "end_index"?: number, readonly [x: string]: unknown }
export const MessageDeltaContentTextAnnotationsFilePathObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the annotation in the text content part." }).check(Schema.isInt()), "type": Schema.Literal("file_path").annotate({ "description": "Always \`file_path\`." }), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text in the message content that needs to be replaced." })), "file_path": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the file that was generated." })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "start_index": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "end_index": Schema.optionalKey(Schema.Number.check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File path", "description": "A URL for the file that's generated when the assistant used the \`code_interpreter\` tool to generate a file.", "identifier": "MessageDeltaContentTextAnnotationsFilePathObject" })
export type MessageRequestContentTextObject = { readonly "type": "text", readonly "text": string, readonly [x: string]: unknown }
export const MessageRequestContentTextObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("text").annotate({ "description": "Always \`text\`." }), "text": Schema.String.annotate({ "description": "Text content to be sent to the model" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Text", "description": "The text content that is part of a message.", "identifier": "MessageRequestContentTextObject" })
export type Metadata = { readonly [x: string]: string } | null
export const Metadata = Schema.Union([Schema.Record(Schema.String, Schema.String).annotate({ "description": "Set of 16 key-value pairs that can be attached to an object. This can be\\nuseful for storing additional information about the object in a structured\\nformat, and querying for objects via API or the dashboard.\\n\\nKeys are strings with a maximum length of 64 characters. Values are strings\\nwith a maximum length of 512 characters.\\n" }), Schema.Null]).annotate({ "identifier": "Metadata" })
export type Model = { readonly "id": string, readonly "created": number, readonly "object": "model", readonly "owned_by": string, readonly [x: string]: unknown }
export const Model = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The model identifier, which can be referenced in the API endpoints." }), "created": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) when the model was created." }).check(Schema.isInt()), "object": Schema.Literal("model").annotate({ "description": "The object type, which is always \\"model\\"." }), "owned_by": Schema.String.annotate({ "description": "The organization that owns the model." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Model", "description": "Describes an OpenAI model offering that can be used with the API.", "identifier": "Model" })
export type ModifyCertificateRequest = { readonly "name": string, readonly [x: string]: unknown }
export const ModifyCertificateRequest = Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The updated name for the certificate" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ModifyCertificateRequest" })
export type Move = { readonly "type": "move", readonly "x": number, readonly "y": number, readonly [x: string]: unknown }
export const Move = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("move").annotate({ "description": "Specifies the event type. For a move action, this property is \\nalways set to \`move\`.\\n", "default": "move" }), "x": Schema.Number.annotate({ "description": "The x-coordinate to move to.\\n" }).check(Schema.isInt()), "y": Schema.Number.annotate({ "description": "The y-coordinate to move to.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Move", "description": "A mouse move action.\\n", "identifier": "Move" })
export type NoiseReductionType = "near_field" | "far_field"
export const NoiseReductionType = Schema.Literals(["near_field", "far_field"]).annotate({ "description": "Type of noise reduction. \`near_field\` is for close-talking microphones such as headphones, \`far_field\` is for far-field microphones such as laptop or conference room microphones.\\n", "identifier": "NoiseReductionType" })
export type OpenAIFile = { readonly "id": string, readonly "bytes": number, readonly "created_at": number, readonly "expires_at"?: number, readonly "filename": string, readonly "object": "file", readonly "purpose": "assistants" | "assistants_output" | "batch" | "batch_output" | "fine-tune" | "fine-tune-results" | "vision" | "user_data", readonly "status": "uploaded" | "processed" | "error", readonly "status_details"?: string, readonly [x: string]: unknown }
export const OpenAIFile = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The file identifier, which can be referenced in the API endpoints." }), "bytes": Schema.Number.annotate({ "description": "The size of the file, in bytes." }).check(Schema.isInt()), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the file was created." }).check(Schema.isInt()), "expires_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the file will expire." }).check(Schema.isInt())), "filename": Schema.String.annotate({ "description": "The name of the file." }), "object": Schema.Literal("file").annotate({ "description": "The object type, which is always \`file\`." }), "purpose": Schema.Literals(["assistants", "assistants_output", "batch", "batch_output", "fine-tune", "fine-tune-results", "vision", "user_data"]).annotate({ "description": "The intended purpose of the file. Supported values are \`assistants\`, \`assistants_output\`, \`batch\`, \`batch_output\`, \`fine-tune\`, \`fine-tune-results\`, \`vision\`, and \`user_data\`." }), "status": Schema.Literals(["uploaded", "processed", "error"]).annotate({ "description": "Deprecated. The current status of the file, which can be either \`uploaded\`, \`processed\`, or \`error\`." }), "status_details": Schema.optionalKey(Schema.String.annotate({ "description": "Deprecated. For details on why a fine-tuning training file failed validation, see the \`error\` field on \`fine_tuning.job\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "OpenAIFile", "description": "The \`File\` object represents a document that has been uploaded to OpenAI.", "identifier": "OpenAIFile" })
export type OtherChunkingStrategyResponseParam = { readonly "type": "other" }
export const OtherChunkingStrategyResponseParam = Schema.Struct({ "type": Schema.Literal("other").annotate({ "description": "Always \`other\`." }) }).annotate({ "title": "Other Chunking Strategy", "description": "This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the \`chunking_strategy\` concept was introduced in the API.", "identifier": "OtherChunkingStrategyResponseParam" })
export type OutputAudio = { readonly "type": "output_audio", readonly "data": string, readonly "transcript": string, readonly [x: string]: unknown }
export const OutputAudio = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("output_audio").annotate({ "description": "The type of the output audio. Always \`output_audio\`.\\n" }), "data": Schema.String.annotate({ "description": "Base64-encoded audio data from the model.\\n" }), "transcript": Schema.String.annotate({ "description": "The transcript of the audio data from the model.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Output audio", "description": "An audio output from the model.\\n", "identifier": "OutputAudio" })
export type ParallelToolCalls = boolean
export const ParallelToolCalls = Schema.Boolean.annotate({ "description": "Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.", "default": true, "identifier": "ParallelToolCalls" })
export type PartialImages = number | null
export const PartialImages = Schema.Union([Schema.Number.annotate({ "description": "The number of partial images to generate. This parameter is used for\\nstreaming responses that return partial images. Value must be between 0 and 3.\\nWhen set to 0, the response will be a single image sent in one streaming event.\\n\\nNote that the final image may be sent before the full number of partial images\\nare generated if the full image is generated more quickly.\\n", "default": 0 }).check(Schema.isInt()), Schema.Null]).annotate({ "identifier": "PartialImages" })
export type Project = { readonly "id": string, readonly "object": "organization.project", readonly "name": string, readonly "created_at": number, readonly "archived_at"?: number | null, readonly "status": "active" | "archived", readonly [x: string]: unknown }
export const Project = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }), "object": Schema.Literal("organization.project").annotate({ "description": "The object type, which is always \`organization.project\`" }), "name": Schema.String.annotate({ "description": "The name of the project. This appears in reporting." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the project was created." }).check(Schema.isInt()), "archived_at": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the project was archived or \`null\`." }).check(Schema.isInt()), Schema.Null])), "status": Schema.Literals(["active", "archived"]).annotate({ "description": "\`active\` or \`archived\`" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents an individual project.", "identifier": "Project" })
export type ProjectApiKeyDeleteResponse = { readonly "object": "organization.project.api_key.deleted", readonly "id": string, readonly "deleted": boolean, readonly [x: string]: unknown }
export const ProjectApiKeyDeleteResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.project.api_key.deleted"), "id": Schema.String, "deleted": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectApiKeyDeleteResponse" })
export type ProjectCreateRequest = { readonly "name": string, readonly "geography"?: "US" | "EU" | "JP" | "IN" | "KR" | "CA" | "AU" | "SG", readonly [x: string]: unknown }
export const ProjectCreateRequest = Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The friendly name of the project, this name appears in reports." }), "geography": Schema.optionalKey(Schema.Literals(["US", "EU", "JP", "IN", "KR", "CA", "AU", "SG"]).annotate({ "description": "Create the project with the specified data residency region. Your organization must have access to Data residency functionality in order to use. See [data residency controls](https://platform.openai.com/docs/guides/your-data#data-residency-controls) to review the functionality and limitations of setting this field." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectCreateRequest" })
export type ProjectGroup = { readonly "object": "project.group", readonly "project_id": string, readonly "group_id": string, readonly "group_name": string, readonly "created_at": number, readonly [x: string]: unknown }
export const ProjectGroup = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("project.group").annotate({ "description": "Always \`project.group\`." }), "project_id": Schema.String.annotate({ "description": "Identifier of the project." }), "group_id": Schema.String.annotate({ "description": "Identifier of the group that has access to the project." }), "group_name": Schema.String.annotate({ "description": "Display name of the group." }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the group was granted project access.", "format": "int64" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details about a group's membership in a project.", "identifier": "ProjectGroup" })
export type ProjectGroupDeletedResource = { readonly "object": "project.group.deleted", readonly "deleted": boolean, readonly [x: string]: unknown }
export const ProjectGroupDeletedResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("project.group.deleted").annotate({ "description": "Always \`project.group.deleted\`." }), "deleted": Schema.Boolean.annotate({ "description": "Whether the group membership in the project was removed." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Confirmation payload returned after removing a group from a project.", "identifier": "ProjectGroupDeletedResource" })
export type ProjectRateLimit = { readonly "object": "project.rate_limit", readonly "id": string, readonly "model": string, readonly "max_requests_per_1_minute": number, readonly "max_tokens_per_1_minute": number, readonly "max_images_per_1_minute"?: number, readonly "max_audio_megabytes_per_1_minute"?: number, readonly "max_requests_per_1_day"?: number, readonly "batch_1_day_max_input_tokens"?: number, readonly [x: string]: unknown }
export const ProjectRateLimit = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("project.rate_limit").annotate({ "description": "The object type, which is always \`project.rate_limit\`" }), "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }), "model": Schema.String.annotate({ "description": "The model this rate limit applies to." }), "max_requests_per_1_minute": Schema.Number.annotate({ "description": "The maximum requests per minute." }).check(Schema.isInt()), "max_tokens_per_1_minute": Schema.Number.annotate({ "description": "The maximum tokens per minute." }).check(Schema.isInt()), "max_images_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum images per minute. Only present for relevant models." }).check(Schema.isInt())), "max_audio_megabytes_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum audio megabytes per minute. Only present for relevant models." }).check(Schema.isInt())), "max_requests_per_1_day": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum requests per day. Only present for relevant models." }).check(Schema.isInt())), "batch_1_day_max_input_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum batch input tokens per day. Only present for relevant models." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents a project rate limit config.", "identifier": "ProjectRateLimit" })
export type ProjectRateLimitUpdateRequest = { readonly "max_requests_per_1_minute"?: number, readonly "max_tokens_per_1_minute"?: number, readonly "max_images_per_1_minute"?: number, readonly "max_audio_megabytes_per_1_minute"?: number, readonly "max_requests_per_1_day"?: number, readonly "batch_1_day_max_input_tokens"?: number, readonly [x: string]: unknown }
export const ProjectRateLimitUpdateRequest = Schema.StructWithRest(Schema.Struct({ "max_requests_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum requests per minute." }).check(Schema.isInt())), "max_tokens_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum tokens per minute." }).check(Schema.isInt())), "max_images_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum images per minute. Only relevant for certain models." }).check(Schema.isInt())), "max_audio_megabytes_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum audio megabytes per minute. Only relevant for certain models." }).check(Schema.isInt())), "max_requests_per_1_day": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum requests per day. Only relevant for certain models." }).check(Schema.isInt())), "batch_1_day_max_input_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum batch input tokens per day. Only relevant for certain models." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectRateLimitUpdateRequest" })
export type ProjectServiceAccount = { readonly "object": "organization.project.service_account", readonly "id": string, readonly "name": string, readonly "role": "owner" | "member", readonly "created_at": number, readonly [x: string]: unknown }
export const ProjectServiceAccount = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.project.service_account").annotate({ "description": "The object type, which is always \`organization.project.service_account\`" }), "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }), "name": Schema.String.annotate({ "description": "The name of the service account" }), "role": Schema.Literals(["owner", "member"]).annotate({ "description": "\`owner\` or \`member\`" }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the service account was created" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents an individual service account in a project.", "identifier": "ProjectServiceAccount" })
export type ProjectServiceAccountApiKey = { readonly "object": "organization.project.service_account.api_key", readonly "value": string, readonly "name": string, readonly "created_at": number, readonly "id": string, readonly [x: string]: unknown }
export const ProjectServiceAccountApiKey = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.project.service_account.api_key").annotate({ "description": "The object type, which is always \`organization.project.service_account.api_key\`" }), "value": Schema.String, "name": Schema.String, "created_at": Schema.Number.check(Schema.isInt()), "id": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectServiceAccountApiKey" })
export type ProjectServiceAccountCreateRequest = { readonly "name": string, readonly [x: string]: unknown }
export const ProjectServiceAccountCreateRequest = Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the service account being created." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectServiceAccountCreateRequest" })
export type ProjectServiceAccountDeleteResponse = { readonly "object": "organization.project.service_account.deleted", readonly "id": string, readonly "deleted": boolean, readonly [x: string]: unknown }
export const ProjectServiceAccountDeleteResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.project.service_account.deleted"), "id": Schema.String, "deleted": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectServiceAccountDeleteResponse" })
export type ProjectUpdateRequest = { readonly "name": string, readonly [x: string]: unknown }
export const ProjectUpdateRequest = Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The updated name of the project, this name appears in reports." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectUpdateRequest" })
export type ProjectUser = { readonly "object": "organization.project.user", readonly "id": string, readonly "name": string, readonly "email": string, readonly "role": "owner" | "member", readonly "added_at": number, readonly [x: string]: unknown }
export const ProjectUser = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.project.user").annotate({ "description": "The object type, which is always \`organization.project.user\`" }), "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }), "name": Schema.String.annotate({ "description": "The name of the user" }), "email": Schema.String.annotate({ "description": "The email address of the user" }), "role": Schema.Literals(["owner", "member"]).annotate({ "description": "\`owner\` or \`member\`" }), "added_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the project was added." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents an individual user in a project.", "identifier": "ProjectUser" })
export type ProjectUserCreateRequest = { readonly "user_id": string, readonly "role": "owner" | "member", readonly [x: string]: unknown }
export const ProjectUserCreateRequest = Schema.StructWithRest(Schema.Struct({ "user_id": Schema.String.annotate({ "description": "The ID of the user." }), "role": Schema.Literals(["owner", "member"]).annotate({ "description": "\`owner\` or \`member\`" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectUserCreateRequest" })
export type ProjectUserDeleteResponse = { readonly "object": "organization.project.user.deleted", readonly "id": string, readonly "deleted": boolean, readonly [x: string]: unknown }
export const ProjectUserDeleteResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.project.user.deleted"), "id": Schema.String, "deleted": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectUserDeleteResponse" })
export type ProjectUserUpdateRequest = { readonly "role": "owner" | "member", readonly [x: string]: unknown }
export const ProjectUserUpdateRequest = Schema.StructWithRest(Schema.Struct({ "role": Schema.Literals(["owner", "member"]).annotate({ "description": "\`owner\` or \`member\`" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectUserUpdateRequest" })
export type PublicAssignOrganizationGroupRoleBody = { readonly "role_id": string, readonly [x: string]: unknown }
export const PublicAssignOrganizationGroupRoleBody = Schema.StructWithRest(Schema.Struct({ "role_id": Schema.String.annotate({ "description": "Identifier of the role to assign." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Request payload for assigning a role to a group or user.", "identifier": "PublicAssignOrganizationGroupRoleBody" })
export type PublicCreateOrganizationRoleBody = { readonly "role_name": string, readonly "permissions": ReadonlyArray<string>, readonly "description"?: string | null, readonly [x: string]: unknown }
export const PublicCreateOrganizationRoleBody = Schema.StructWithRest(Schema.Struct({ "role_name": Schema.String.annotate({ "description": "Unique name for the role." }), "permissions": Schema.Array(Schema.String).annotate({ "description": "Permissions to grant to the role." }), "description": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Optional description of the role." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Request payload for creating a custom role.", "identifier": "PublicCreateOrganizationRoleBody" })
export type PublicUpdateOrganizationRoleBody = { readonly "permissions"?: ReadonlyArray<string> | null, readonly "description"?: string | null, readonly "role_name"?: string | null, readonly [x: string]: unknown }
export const PublicUpdateOrganizationRoleBody = Schema.StructWithRest(Schema.Struct({ "permissions": Schema.optionalKey(Schema.Union([Schema.Array(Schema.String), Schema.Null]).annotate({ "description": "Updated set of permissions for the role." })), "description": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "New description for the role." })), "role_name": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "New name for the role." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Request payload for updating an existing role.", "identifier": "PublicUpdateOrganizationRoleBody" })
export type RealtimeAudioFormats = { readonly "type"?: "audio/pcm", readonly "rate"?: 24000, readonly [x: string]: unknown } | { readonly "type"?: "audio/pcmu", readonly [x: string]: unknown } | { readonly "type"?: "audio/pcma", readonly [x: string]: unknown }
export const RealtimeAudioFormats = Schema.Union([Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("audio/pcm").annotate({ "description": "The audio format. Always \`audio/pcm\`." })), "rate": Schema.optionalKey(Schema.Literal(24000).annotate({ "description": "The sample rate of the audio. Always \`24000\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "PCM audio format", "description": "The PCM audio format. Only a 24kHz sample rate is supported." }), Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("audio/pcmu").annotate({ "description": "The audio format. Always \`audio/pcmu\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "PCMU audio format", "description": "The G.711 -law format." }), Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("audio/pcma").annotate({ "description": "The audio format. Always \`audio/pcma\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "PCMA audio format", "description": "The G.711 A-law format." })]).annotate({ "identifier": "RealtimeAudioFormats" })
export type RealtimeBetaClientEventConversationItemDelete = { readonly "event_id"?: string, readonly "type": "conversation.item.delete", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaClientEventConversationItemDelete = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("conversation.item.delete").annotate({ "description": "The event type, must be \`conversation.item.delete\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the item to delete." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event when you want to remove any item from the conversation \\nhistory. The server will respond with a \`conversation.item.deleted\` event, \\nunless the item does not exist in the conversation history, in which case the \\nserver will respond with an error.\\n", "identifier": "RealtimeBetaClientEventConversationItemDelete" })
export type RealtimeBetaClientEventConversationItemRetrieve = { readonly "event_id"?: string, readonly "type": "conversation.item.retrieve", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaClientEventConversationItemRetrieve = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("conversation.item.retrieve").annotate({ "description": "The event type, must be \`conversation.item.retrieve\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the item to retrieve." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event when you want to retrieve the server's representation of a specific item in the conversation history. This is useful, for example, to inspect user audio after noise cancellation and VAD.\\nThe server will respond with a \`conversation.item.retrieved\` event, \\nunless the item does not exist in the conversation history, in which case the \\nserver will respond with an error.\\n", "identifier": "RealtimeBetaClientEventConversationItemRetrieve" })
export type RealtimeBetaClientEventConversationItemTruncate = { readonly "event_id"?: string, readonly "type": "conversation.item.truncate", readonly "item_id": string, readonly "content_index": number, readonly "audio_end_ms": number, readonly [x: string]: unknown }
export const RealtimeBetaClientEventConversationItemTruncate = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("conversation.item.truncate").annotate({ "description": "The event type, must be \`conversation.item.truncate\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the assistant message item to truncate. Only assistant message \\nitems can be truncated.\\n" }), "content_index": Schema.Number.annotate({ "description": "The index of the content part to truncate. Set this to 0." }).check(Schema.isInt()), "audio_end_ms": Schema.Number.annotate({ "description": "Inclusive duration up to which audio is truncated, in milliseconds. If \\nthe audio_end_ms is greater than the actual audio duration, the server \\nwill respond with an error.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to truncate a previous assistant messages audio. The server \\nwill produce audio faster than realtime, so this event is useful when the user \\ninterrupts to truncate audio that has already been sent to the client but not \\nyet played. This will synchronize the server's understanding of the audio with \\nthe client's playback.\\n\\nTruncating audio will delete the server-side text transcript to ensure there \\nis not text in the context that hasn't been heard by the user.\\n\\nIf successful, the server will respond with a \`conversation.item.truncated\` \\nevent. \\n", "identifier": "RealtimeBetaClientEventConversationItemTruncate" })
export type RealtimeBetaClientEventInputAudioBufferAppend = { readonly "event_id"?: string, readonly "type": "input_audio_buffer.append", readonly "audio": string, readonly [x: string]: unknown }
export const RealtimeBetaClientEventInputAudioBufferAppend = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("input_audio_buffer.append").annotate({ "description": "The event type, must be \`input_audio_buffer.append\`." }), "audio": Schema.String.annotate({ "description": "Base64-encoded audio bytes. This must be in the format specified by the \\n\`input_audio_format\` field in the session configuration.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to append audio bytes to the input audio buffer. The audio \\nbuffer is temporary storage you can write to and later commit. In Server VAD \\nmode, the audio buffer is used to detect speech and the server will decide \\nwhen to commit. When Server VAD is disabled, you must commit the audio buffer\\nmanually.\\n\\nThe client may choose how much audio to place in each event up to a maximum \\nof 15 MiB, for example streaming smaller chunks from the client may allow the \\nVAD to be more responsive. Unlike made other client events, the server will \\nnot send a confirmation response to this event.\\n", "identifier": "RealtimeBetaClientEventInputAudioBufferAppend" })
export type RealtimeBetaClientEventInputAudioBufferClear = { readonly "event_id"?: string, readonly "type": "input_audio_buffer.clear", readonly [x: string]: unknown }
export const RealtimeBetaClientEventInputAudioBufferClear = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("input_audio_buffer.clear").annotate({ "description": "The event type, must be \`input_audio_buffer.clear\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to clear the audio bytes in the buffer. The server will \\nrespond with an \`input_audio_buffer.cleared\` event.\\n", "identifier": "RealtimeBetaClientEventInputAudioBufferClear" })
export type RealtimeBetaClientEventInputAudioBufferCommit = { readonly "event_id"?: string, readonly "type": "input_audio_buffer.commit", readonly [x: string]: unknown }
export const RealtimeBetaClientEventInputAudioBufferCommit = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("input_audio_buffer.commit").annotate({ "description": "The event type, must be \`input_audio_buffer.commit\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to commit the user input audio buffer, which will create a \\nnew user message item in the conversation. This event will produce an error \\nif the input audio buffer is empty. When in Server VAD mode, the client does \\nnot need to send this event, the server will commit the audio buffer \\nautomatically.\\n\\nCommitting the input audio buffer will trigger input audio transcription \\n(if enabled in session configuration), but it will not create a response \\nfrom the model. The server will respond with an \`input_audio_buffer.committed\` \\nevent.\\n", "identifier": "RealtimeBetaClientEventInputAudioBufferCommit" })
export type RealtimeBetaClientEventOutputAudioBufferClear = { readonly "event_id"?: string, readonly "type": "output_audio_buffer.clear", readonly [x: string]: unknown }
export const RealtimeBetaClientEventOutputAudioBufferClear = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the client event used for error handling." })), "type": Schema.Literal("output_audio_buffer.clear").annotate({ "description": "The event type, must be \`output_audio_buffer.clear\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "**WebRTC/SIP Only:** Emit to cut off the current audio response. This will trigger the server to\\nstop generating audio and emit a \`output_audio_buffer.cleared\` event. This\\nevent should be preceded by a \`response.cancel\` client event to stop the\\ngeneration of the current response.\\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\\n", "identifier": "RealtimeBetaClientEventOutputAudioBufferClear" })
export type RealtimeBetaClientEventResponseCancel = { readonly "event_id"?: string, readonly "type": "response.cancel", readonly "response_id"?: string, readonly [x: string]: unknown }
export const RealtimeBetaClientEventResponseCancel = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("response.cancel").annotate({ "description": "The event type, must be \`response.cancel\`." }), "response_id": Schema.optionalKey(Schema.String.annotate({ "description": "A specific response ID to cancel - if not provided, will cancel an \\nin-progress response in the default conversation.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to cancel an in-progress response. The server will respond \\nwith a \`response.done\` event with a status of \`response.status=cancelled\`. If \\nthere is no response to cancel, the server will respond with an error.\\n", "identifier": "RealtimeBetaClientEventResponseCancel" })
export type RealtimeBetaServerEventConversationItemDeleted = { readonly "event_id": string, readonly "type": "conversation.item.deleted", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventConversationItemDeleted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.deleted").annotate({ "description": "The event type, must be \`conversation.item.deleted\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the item that was deleted." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an item in the conversation is deleted by the client with a \\n\`conversation.item.delete\` event. This event is used to synchronize the \\nserver's understanding of the conversation history with the client's view.\\n", "identifier": "RealtimeBetaServerEventConversationItemDeleted" })
export type RealtimeBetaServerEventConversationItemInputAudioTranscriptionFailed = { readonly "event_id": string, readonly "type": "conversation.item.input_audio_transcription.failed", readonly "item_id": string, readonly "content_index": number, readonly "error": { readonly "type"?: string, readonly "code"?: string, readonly "message"?: string, readonly "param"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeBetaServerEventConversationItemInputAudioTranscriptionFailed = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.input_audio_transcription.failed").annotate({ "description": "The event type, must be\\n\`conversation.item.input_audio_transcription.failed\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the user message item." }), "content_index": Schema.Number.annotate({ "description": "The index of the content part containing the audio." }).check(Schema.isInt()), "error": Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of error." })), "code": Schema.optionalKey(Schema.String.annotate({ "description": "Error code, if any." })), "message": Schema.optionalKey(Schema.String.annotate({ "description": "A human-readable error message." })), "param": Schema.optionalKey(Schema.String.annotate({ "description": "Parameter related to the error, if any." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details of the transcription error." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when input audio transcription is configured, and a transcription \\nrequest for a user message failed. These events are separate from other \\n\`error\` events so that the client can identify the related Item.\\n", "identifier": "RealtimeBetaServerEventConversationItemInputAudioTranscriptionFailed" })
export type RealtimeBetaServerEventConversationItemInputAudioTranscriptionSegment = { readonly "event_id": string, readonly "type": "conversation.item.input_audio_transcription.segment", readonly "item_id": string, readonly "content_index": number, readonly "text": string, readonly "id": string, readonly "speaker": string, readonly "start": number, readonly "end": number, readonly [x: string]: unknown }
export const RealtimeBetaServerEventConversationItemInputAudioTranscriptionSegment = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.input_audio_transcription.segment").annotate({ "description": "The event type, must be \`conversation.item.input_audio_transcription.segment\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the item containing the input audio content." }), "content_index": Schema.Number.annotate({ "description": "The index of the input audio content part within the item." }).check(Schema.isInt()), "text": Schema.String.annotate({ "description": "The text for this segment." }), "id": Schema.String.annotate({ "description": "The segment identifier." }), "speaker": Schema.String.annotate({ "description": "The detected speaker label for this segment." }), "start": Schema.Number.annotate({ "description": "Start time of the segment in seconds.", "format": "float" }).check(Schema.isFinite()), "end": Schema.Number.annotate({ "description": "End time of the segment in seconds.", "format": "float" }).check(Schema.isFinite()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an input audio transcription segment is identified for an item.", "identifier": "RealtimeBetaServerEventConversationItemInputAudioTranscriptionSegment" })
export type RealtimeBetaServerEventConversationItemTruncated = { readonly "event_id": string, readonly "type": "conversation.item.truncated", readonly "item_id": string, readonly "content_index": number, readonly "audio_end_ms": number, readonly [x: string]: unknown }
export const RealtimeBetaServerEventConversationItemTruncated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.truncated").annotate({ "description": "The event type, must be \`conversation.item.truncated\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the assistant message item that was truncated." }), "content_index": Schema.Number.annotate({ "description": "The index of the content part that was truncated." }).check(Schema.isInt()), "audio_end_ms": Schema.Number.annotate({ "description": "The duration up to which the audio was truncated, in milliseconds.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an earlier assistant audio message item is truncated by the \\nclient with a \`conversation.item.truncate\` event. This event is used to \\nsynchronize the server's understanding of the audio with the client's playback.\\n\\nThis action will truncate the audio and remove the server-side text transcript \\nto ensure there is no text in the context that hasn't been heard by the user.\\n", "identifier": "RealtimeBetaServerEventConversationItemTruncated" })
export type RealtimeBetaServerEventError = { readonly "event_id": string, readonly "type": "error", readonly "error": { readonly "type": string, readonly "code"?: string | null, readonly "message": string, readonly "param"?: string | null, readonly "event_id"?: string | null, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeBetaServerEventError = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("error").annotate({ "description": "The event type, must be \`error\`." }), "error": Schema.StructWithRest(Schema.Struct({ "type": Schema.String.annotate({ "description": "The type of error (e.g., \\"invalid_request_error\\", \\"server_error\\").\\n" }), "code": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Error code, if any." }), Schema.Null])), "message": Schema.String.annotate({ "description": "A human-readable error message." }), "param": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Parameter related to the error, if any." }), Schema.Null])), "event_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The event_id of the client event that caused the error, if applicable.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details of the error." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an error occurs, which could be a client problem or a server\\nproblem. Most errors are recoverable and the session will stay open, we\\nrecommend to implementors to monitor and log error messages by default.\\n", "identifier": "RealtimeBetaServerEventError" })
export type RealtimeBetaServerEventInputAudioBufferCleared = { readonly "event_id": string, readonly "type": "input_audio_buffer.cleared", readonly [x: string]: unknown }
export const RealtimeBetaServerEventInputAudioBufferCleared = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("input_audio_buffer.cleared").annotate({ "description": "The event type, must be \`input_audio_buffer.cleared\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the input audio buffer is cleared by the client with a \\n\`input_audio_buffer.clear\` event.\\n", "identifier": "RealtimeBetaServerEventInputAudioBufferCleared" })
export type RealtimeBetaServerEventInputAudioBufferCommitted = { readonly "event_id": string, readonly "type": "input_audio_buffer.committed", readonly "previous_item_id"?: string | null, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventInputAudioBufferCommitted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("input_audio_buffer.committed").annotate({ "description": "The event type, must be \`input_audio_buffer.committed\`." }), "previous_item_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the preceding item after which the new item will be inserted.\\nCan be \`null\` if the item has no predecessor.\\n" }), Schema.Null])), "item_id": Schema.String.annotate({ "description": "The ID of the user message item that will be created." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an input audio buffer is committed, either by the client or\\nautomatically in server VAD mode. The \`item_id\` property is the ID of the user\\nmessage item that will be created, thus a \`conversation.item.created\` event\\nwill also be sent to the client.\\n", "identifier": "RealtimeBetaServerEventInputAudioBufferCommitted" })
export type RealtimeBetaServerEventInputAudioBufferSpeechStarted = { readonly "event_id": string, readonly "type": "input_audio_buffer.speech_started", readonly "audio_start_ms": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventInputAudioBufferSpeechStarted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("input_audio_buffer.speech_started").annotate({ "description": "The event type, must be \`input_audio_buffer.speech_started\`." }), "audio_start_ms": Schema.Number.annotate({ "description": "Milliseconds from the start of all audio written to the buffer during the \\nsession when speech was first detected. This will correspond to the \\nbeginning of audio sent to the model, and thus includes the \\n\`prefix_padding_ms\` configured in the Session.\\n" }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the user message item that will be created when speech stops.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Sent by the server when in \`server_vad\` mode to indicate that speech has been \\ndetected in the audio buffer. This can happen any time audio is added to the \\nbuffer (unless speech is already detected). The client may want to use this \\nevent to interrupt audio playback or provide visual feedback to the user. \\n\\nThe client should expect to receive a \`input_audio_buffer.speech_stopped\` event \\nwhen speech stops. The \`item_id\` property is the ID of the user message item \\nthat will be created when speech stops and will also be included in the \\n\`input_audio_buffer.speech_stopped\` event (unless the client manually commits \\nthe audio buffer during VAD activation).\\n", "identifier": "RealtimeBetaServerEventInputAudioBufferSpeechStarted" })
export type RealtimeBetaServerEventInputAudioBufferSpeechStopped = { readonly "event_id": string, readonly "type": "input_audio_buffer.speech_stopped", readonly "audio_end_ms": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventInputAudioBufferSpeechStopped = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("input_audio_buffer.speech_stopped").annotate({ "description": "The event type, must be \`input_audio_buffer.speech_stopped\`." }), "audio_end_ms": Schema.Number.annotate({ "description": "Milliseconds since the session started when speech stopped. This will \\ncorrespond to the end of audio sent to the model, and thus includes the \\n\`min_silence_duration_ms\` configured in the Session.\\n" }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the user message item that will be created." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned in \`server_vad\` mode when the server detects the end of speech in \\nthe audio buffer. The server will also send an \`conversation.item.created\` \\nevent with the user message item that is created from the audio buffer.\\n", "identifier": "RealtimeBetaServerEventInputAudioBufferSpeechStopped" })
export type RealtimeBetaServerEventMCPListToolsCompleted = { readonly "event_id": string, readonly "type": "mcp_list_tools.completed", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventMCPListToolsCompleted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("mcp_list_tools.completed").annotate({ "description": "The event type, must be \`mcp_list_tools.completed\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP list tools item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when listing MCP tools has completed for an item.", "identifier": "RealtimeBetaServerEventMCPListToolsCompleted" })
export type RealtimeBetaServerEventMCPListToolsFailed = { readonly "event_id": string, readonly "type": "mcp_list_tools.failed", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventMCPListToolsFailed = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("mcp_list_tools.failed").annotate({ "description": "The event type, must be \`mcp_list_tools.failed\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP list tools item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when listing MCP tools has failed for an item.", "identifier": "RealtimeBetaServerEventMCPListToolsFailed" })
export type RealtimeBetaServerEventMCPListToolsInProgress = { readonly "event_id": string, readonly "type": "mcp_list_tools.in_progress", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventMCPListToolsInProgress = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("mcp_list_tools.in_progress").annotate({ "description": "The event type, must be \`mcp_list_tools.in_progress\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP list tools item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when listing MCP tools is in progress for an item.", "identifier": "RealtimeBetaServerEventMCPListToolsInProgress" })
export type RealtimeBetaServerEventRateLimitsUpdated = { readonly "event_id": string, readonly "type": "rate_limits.updated", readonly "rate_limits": ReadonlyArray<{ readonly "name"?: "requests" | "tokens", readonly "limit"?: number, readonly "remaining"?: number, readonly "reset_seconds"?: number, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const RealtimeBetaServerEventRateLimitsUpdated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("rate_limits.updated").annotate({ "description": "The event type, must be \`rate_limits.updated\`." }), "rate_limits": Schema.Array(Schema.StructWithRest(Schema.Struct({ "name": Schema.optionalKey(Schema.Literals(["requests", "tokens"]).annotate({ "description": "The name of the rate limit (\`requests\`, \`tokens\`).\\n" })), "limit": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum allowed value for the rate limit." }).check(Schema.isInt())), "remaining": Schema.optionalKey(Schema.Number.annotate({ "description": "The remaining value before the limit is reached." }).check(Schema.isInt())), "reset_seconds": Schema.optionalKey(Schema.Number.annotate({ "description": "Seconds until the rate limit resets." }).check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "List of rate limit information." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted at the beginning of a Response to indicate the updated rate limits. \\nWhen a Response is created some tokens will be \\"reserved\\" for the output \\ntokens, the rate limits shown here reflect that reservation, which is then \\nadjusted accordingly once the Response is completed.\\n", "identifier": "RealtimeBetaServerEventRateLimitsUpdated" })
export type RealtimeBetaServerEventResponseAudioDelta = { readonly "event_id": string, readonly "type": "response.output_audio.delta", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "delta": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseAudioDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_audio.delta").annotate({ "description": "The event type, must be \`response.output_audio.delta\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "Base64-encoded audio data delta." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated audio is updated.", "identifier": "RealtimeBetaServerEventResponseAudioDelta" })
export type RealtimeBetaServerEventResponseAudioDone = { readonly "event_id": string, readonly "type": "response.output_audio.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseAudioDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_audio.done").annotate({ "description": "The event type, must be \`response.output_audio.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated audio is done. Also emitted when a Response\\nis interrupted, incomplete, or cancelled.\\n", "identifier": "RealtimeBetaServerEventResponseAudioDone" })
export type RealtimeBetaServerEventResponseAudioTranscriptDelta = { readonly "event_id": string, readonly "type": "response.output_audio_transcript.delta", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "delta": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseAudioTranscriptDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_audio_transcript.delta").annotate({ "description": "The event type, must be \`response.output_audio_transcript.delta\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The transcript delta." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated transcription of audio output is updated.\\n", "identifier": "RealtimeBetaServerEventResponseAudioTranscriptDelta" })
export type RealtimeBetaServerEventResponseAudioTranscriptDone = { readonly "event_id": string, readonly "type": "response.output_audio_transcript.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "transcript": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseAudioTranscriptDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_audio_transcript.done").annotate({ "description": "The event type, must be \`response.output_audio_transcript.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "transcript": Schema.String.annotate({ "description": "The final transcript of the audio." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated transcription of audio output is done\\nstreaming. Also emitted when a Response is interrupted, incomplete, or\\ncancelled.\\n", "identifier": "RealtimeBetaServerEventResponseAudioTranscriptDone" })
export type RealtimeBetaServerEventResponseContentPartAdded = { readonly "event_id": string, readonly "type": "response.content_part.added", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "part": { readonly "type"?: "text" | "audio", readonly "text"?: string, readonly "audio"?: string, readonly "transcript"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseContentPartAdded = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.content_part.added").annotate({ "description": "The event type, must be \`response.content_part.added\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item to which the content part was added." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "part": Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["text", "audio"]).annotate({ "description": "The content type (\\"text\\", \\"audio\\")." })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content (if type is \\"text\\")." })), "audio": Schema.optionalKey(Schema.String.annotate({ "description": "Base64-encoded audio data (if type is \\"audio\\")." })), "transcript": Schema.optionalKey(Schema.String.annotate({ "description": "The transcript of the audio (if type is \\"audio\\")." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The content part that was added." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a new content part is added to an assistant message item during\\nresponse generation.\\n", "identifier": "RealtimeBetaServerEventResponseContentPartAdded" })
export type RealtimeBetaServerEventResponseContentPartDone = { readonly "event_id": string, readonly "type": "response.content_part.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "part": { readonly "type"?: "text" | "audio", readonly "text"?: string, readonly "audio"?: string, readonly "transcript"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseContentPartDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.content_part.done").annotate({ "description": "The event type, must be \`response.content_part.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "part": Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["text", "audio"]).annotate({ "description": "The content type (\\"text\\", \\"audio\\")." })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content (if type is \\"text\\")." })), "audio": Schema.optionalKey(Schema.String.annotate({ "description": "Base64-encoded audio data (if type is \\"audio\\")." })), "transcript": Schema.optionalKey(Schema.String.annotate({ "description": "The transcript of the audio (if type is \\"audio\\")." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The content part that is done." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a content part is done streaming in an assistant message item.\\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\\n", "identifier": "RealtimeBetaServerEventResponseContentPartDone" })
export type RealtimeBetaServerEventResponseFunctionCallArgumentsDelta = { readonly "event_id": string, readonly "type": "response.function_call_arguments.delta", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "call_id": string, readonly "delta": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseFunctionCallArgumentsDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.function_call_arguments.delta").annotate({ "description": "The event type, must be \`response.function_call_arguments.delta\`.\\n" }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the function call item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "call_id": Schema.String.annotate({ "description": "The ID of the function call." }), "delta": Schema.String.annotate({ "description": "The arguments delta as a JSON string." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated function call arguments are updated.\\n", "identifier": "RealtimeBetaServerEventResponseFunctionCallArgumentsDelta" })
export type RealtimeBetaServerEventResponseFunctionCallArgumentsDone = { readonly "event_id": string, readonly "type": "response.function_call_arguments.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "call_id": string, readonly "arguments": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseFunctionCallArgumentsDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.function_call_arguments.done").annotate({ "description": "The event type, must be \`response.function_call_arguments.done\`.\\n" }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the function call item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "call_id": Schema.String.annotate({ "description": "The ID of the function call." }), "arguments": Schema.String.annotate({ "description": "The final arguments as a JSON string." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated function call arguments are done streaming.\\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\\n", "identifier": "RealtimeBetaServerEventResponseFunctionCallArgumentsDone" })
export type RealtimeBetaServerEventResponseMCPCallArgumentsDelta = { readonly "event_id": string, readonly "type": "response.mcp_call_arguments.delta", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "delta": string, readonly "obfuscation"?: string | null, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseMCPCallArgumentsDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.mcp_call_arguments.delta").annotate({ "description": "The event type, must be \`response.mcp_call_arguments.delta\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The JSON-encoded arguments delta." }), "obfuscation": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "If present, indicates the delta text was obfuscated." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when MCP tool call arguments are updated during response generation.", "identifier": "RealtimeBetaServerEventResponseMCPCallArgumentsDelta" })
export type RealtimeBetaServerEventResponseMCPCallArgumentsDone = { readonly "event_id": string, readonly "type": "response.mcp_call_arguments.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "arguments": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseMCPCallArgumentsDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.mcp_call_arguments.done").annotate({ "description": "The event type, must be \`response.mcp_call_arguments.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "arguments": Schema.String.annotate({ "description": "The final JSON-encoded arguments string." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when MCP tool call arguments are finalized during response generation.", "identifier": "RealtimeBetaServerEventResponseMCPCallArgumentsDone" })
export type RealtimeBetaServerEventResponseMCPCallCompleted = { readonly "event_id": string, readonly "type": "response.mcp_call.completed", readonly "output_index": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseMCPCallCompleted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.mcp_call.completed").annotate({ "description": "The event type, must be \`response.mcp_call.completed\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an MCP tool call has completed successfully.", "identifier": "RealtimeBetaServerEventResponseMCPCallCompleted" })
export type RealtimeBetaServerEventResponseMCPCallFailed = { readonly "event_id": string, readonly "type": "response.mcp_call.failed", readonly "output_index": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseMCPCallFailed = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.mcp_call.failed").annotate({ "description": "The event type, must be \`response.mcp_call.failed\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an MCP tool call has failed.", "identifier": "RealtimeBetaServerEventResponseMCPCallFailed" })
export type RealtimeBetaServerEventResponseMCPCallInProgress = { readonly "event_id": string, readonly "type": "response.mcp_call.in_progress", readonly "output_index": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseMCPCallInProgress = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.mcp_call.in_progress").annotate({ "description": "The event type, must be \`response.mcp_call.in_progress\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an MCP tool call has started and is in progress.", "identifier": "RealtimeBetaServerEventResponseMCPCallInProgress" })
export type RealtimeBetaServerEventResponseTextDelta = { readonly "event_id": string, readonly "type": "response.output_text.delta", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "delta": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseTextDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_text.delta").annotate({ "description": "The event type, must be \`response.output_text.delta\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The text delta." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the text value of an \\"output_text\\" content part is updated.", "identifier": "RealtimeBetaServerEventResponseTextDelta" })
export type RealtimeBetaServerEventResponseTextDone = { readonly "event_id": string, readonly "type": "response.output_text.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "text": string, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseTextDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_text.done").annotate({ "description": "The event type, must be \`response.output_text.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "text": Schema.String.annotate({ "description": "The final text content." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the text value of an \\"output_text\\" content part is done streaming. Also\\nemitted when a Response is interrupted, incomplete, or cancelled.\\n", "identifier": "RealtimeBetaServerEventResponseTextDone" })
export type RealtimeCallCreateRequest = { readonly "sdp": string, readonly "session"?: unknown }
export const RealtimeCallCreateRequest = Schema.Struct({ "sdp": Schema.String.annotate({ "description": "WebRTC Session Description Protocol (SDP) offer generated by the caller." }), "session": Schema.optionalKey(Schema.Unknown.annotate({ "title": "Session configuration", "description": "Optional session configuration to apply before the realtime session is\\ncreated. Use the same parameters you would send in a [\`create client secret\`](https://platform.openai.com/docs/api-reference/realtime-sessions/create-realtime-client-secret)\\nrequest." })) }).annotate({ "title": "Realtime call creation request", "description": "Parameters required to initiate a realtime call and receive the SDP answer\\nneeded to complete a WebRTC peer connection. Provide an SDP offer generated\\nby your client and optionally configure the session that will answer the call.", "identifier": "RealtimeCallCreateRequest" })
export type RealtimeCallReferRequest = { readonly "target_uri": string }
export const RealtimeCallReferRequest = Schema.Struct({ "target_uri": Schema.String.annotate({ "description": "URI that should appear in the SIP Refer-To header. Supports values like\\n\`tel:+14155550123\` or \`sip:agent@example.com\`." }) }).annotate({ "title": "Realtime call refer request", "description": "Parameters required to transfer a SIP call to a new destination using the\\nRealtime API.", "identifier": "RealtimeCallReferRequest" })
export type RealtimeCallRejectRequest = { readonly "status_code"?: number }
export const RealtimeCallRejectRequest = Schema.Struct({ "status_code": Schema.optionalKey(Schema.Number.annotate({ "description": "SIP response code to send back to the caller. Defaults to \`603\` (Decline)\\nwhen omitted." }).check(Schema.isInt())) }).annotate({ "title": "Realtime call reject request", "description": "Parameters used to decline an incoming SIP call handled by the Realtime API.", "identifier": "RealtimeCallRejectRequest" })
export type RealtimeClientEventConversationItemDelete = { readonly "event_id"?: string, readonly "type": "conversation.item.delete", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeClientEventConversationItemDelete = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("conversation.item.delete").annotate({ "description": "The event type, must be \`conversation.item.delete\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the item to delete." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event when you want to remove any item from the conversation \\nhistory. The server will respond with a \`conversation.item.deleted\` event, \\nunless the item does not exist in the conversation history, in which case the \\nserver will respond with an error.\\n", "identifier": "RealtimeClientEventConversationItemDelete" })
export type RealtimeClientEventConversationItemRetrieve = { readonly "event_id"?: string, readonly "type": "conversation.item.retrieve", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeClientEventConversationItemRetrieve = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("conversation.item.retrieve").annotate({ "description": "The event type, must be \`conversation.item.retrieve\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the item to retrieve." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event when you want to retrieve the server's representation of a specific item in the conversation history. This is useful, for example, to inspect user audio after noise cancellation and VAD.\\nThe server will respond with a \`conversation.item.retrieved\` event, \\nunless the item does not exist in the conversation history, in which case the \\nserver will respond with an error.\\n", "identifier": "RealtimeClientEventConversationItemRetrieve" })
export type RealtimeClientEventConversationItemTruncate = { readonly "event_id"?: string, readonly "type": "conversation.item.truncate", readonly "item_id": string, readonly "content_index": number, readonly "audio_end_ms": number, readonly [x: string]: unknown }
export const RealtimeClientEventConversationItemTruncate = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("conversation.item.truncate").annotate({ "description": "The event type, must be \`conversation.item.truncate\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the assistant message item to truncate. Only assistant message \\nitems can be truncated.\\n" }), "content_index": Schema.Number.annotate({ "description": "The index of the content part to truncate. Set this to \`0\`." }).check(Schema.isInt()), "audio_end_ms": Schema.Number.annotate({ "description": "Inclusive duration up to which audio is truncated, in milliseconds. If \\nthe audio_end_ms is greater than the actual audio duration, the server \\nwill respond with an error.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to truncate a previous assistant messages audio. The server \\nwill produce audio faster than realtime, so this event is useful when the user \\ninterrupts to truncate audio that has already been sent to the client but not \\nyet played. This will synchronize the server's understanding of the audio with \\nthe client's playback.\\n\\nTruncating audio will delete the server-side text transcript to ensure there \\nis not text in the context that hasn't been heard by the user.\\n\\nIf successful, the server will respond with a \`conversation.item.truncated\` \\nevent. \\n", "identifier": "RealtimeClientEventConversationItemTruncate" })
export type RealtimeClientEventInputAudioBufferAppend = { readonly "event_id"?: string, readonly "type": "input_audio_buffer.append", readonly "audio": string, readonly [x: string]: unknown }
export const RealtimeClientEventInputAudioBufferAppend = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("input_audio_buffer.append").annotate({ "description": "The event type, must be \`input_audio_buffer.append\`." }), "audio": Schema.String.annotate({ "description": "Base64-encoded audio bytes. This must be in the format specified by the \\n\`input_audio_format\` field in the session configuration.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to append audio bytes to the input audio buffer. The audio \\nbuffer is temporary storage you can write to and later commit. A \\"commit\\" will create a new\\nuser message item in the conversation history from the buffer content and clear the buffer.\\nInput audio transcription (if enabled) will be generated when the buffer is committed.\\n\\nIf VAD is enabled the audio buffer is used to detect speech and the server will decide \\nwhen to commit. When Server VAD is disabled, you must commit the audio buffer\\nmanually. Input audio noise reduction operates on writes to the audio buffer.\\n\\nThe client may choose how much audio to place in each event up to a maximum \\nof 15 MiB, for example streaming smaller chunks from the client may allow the \\nVAD to be more responsive. Unlike most other client events, the server will \\nnot send a confirmation response to this event.\\n", "identifier": "RealtimeClientEventInputAudioBufferAppend" })
export type RealtimeClientEventInputAudioBufferClear = { readonly "event_id"?: string, readonly "type": "input_audio_buffer.clear", readonly [x: string]: unknown }
export const RealtimeClientEventInputAudioBufferClear = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("input_audio_buffer.clear").annotate({ "description": "The event type, must be \`input_audio_buffer.clear\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to clear the audio bytes in the buffer. The server will \\nrespond with an \`input_audio_buffer.cleared\` event.\\n", "identifier": "RealtimeClientEventInputAudioBufferClear" })
export type RealtimeClientEventInputAudioBufferCommit = { readonly "event_id"?: string, readonly "type": "input_audio_buffer.commit", readonly [x: string]: unknown }
export const RealtimeClientEventInputAudioBufferCommit = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("input_audio_buffer.commit").annotate({ "description": "The event type, must be \`input_audio_buffer.commit\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to commit the user input audio buffer, which will create a  new user message item in the conversation. This event will produce an error  if the input audio buffer is empty. When in Server VAD mode, the client does  not need to send this event, the server will commit the audio buffer  automatically.\\n\\nCommitting the input audio buffer will trigger input audio transcription  (if enabled in session configuration), but it will not create a response  from the model. The server will respond with an \`input_audio_buffer.committed\` event.\\n", "identifier": "RealtimeClientEventInputAudioBufferCommit" })
export type RealtimeClientEventOutputAudioBufferClear = { readonly "event_id"?: string, readonly "type": "output_audio_buffer.clear", readonly [x: string]: unknown }
export const RealtimeClientEventOutputAudioBufferClear = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the client event used for error handling." })), "type": Schema.Literal("output_audio_buffer.clear").annotate({ "description": "The event type, must be \`output_audio_buffer.clear\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "**WebRTC/SIP Only:** Emit to cut off the current audio response. This will trigger the server to\\nstop generating audio and emit a \`output_audio_buffer.cleared\` event. This\\nevent should be preceded by a \`response.cancel\` client event to stop the\\ngeneration of the current response.\\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\\n", "identifier": "RealtimeClientEventOutputAudioBufferClear" })
export type RealtimeClientEventResponseCancel = { readonly "event_id"?: string, readonly "type": "response.cancel", readonly "response_id"?: string, readonly [x: string]: unknown }
export const RealtimeClientEventResponseCancel = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("response.cancel").annotate({ "description": "The event type, must be \`response.cancel\`." }), "response_id": Schema.optionalKey(Schema.String.annotate({ "description": "A specific response ID to cancel - if not provided, will cancel an \\nin-progress response in the default conversation.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to cancel an in-progress response. The server will respond \\nwith a \`response.done\` event with a status of \`response.status=cancelled\`. If \\nthere is no response to cancel, the server will respond with an error. It's safe\\nto call \`response.cancel\` even if no response is in progress, an error will be\\nreturned the session will remain unaffected.\\n", "identifier": "RealtimeClientEventResponseCancel" })
export type RealtimeConversationItemFunctionCall = { readonly "id"?: string, readonly "object"?: "realtime.item", readonly "type": "function_call", readonly "status"?: "completed" | "incomplete" | "in_progress", readonly "call_id"?: string, readonly "name": string, readonly "arguments": string, readonly [x: string]: unknown }
export const RealtimeConversationItemFunctionCall = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the item. This may be provided by the client or generated by the server." })), "object": Schema.optionalKey(Schema.Literal("realtime.item").annotate({ "description": "Identifier for the API object being returned - always \`realtime.item\`. Optional when creating a new item." })), "type": Schema.Literal("function_call").annotate({ "description": "The type of the item. Always \`function_call\`." }), "status": Schema.optionalKey(Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({ "description": "The status of the item. Has no effect on the conversation." })), "call_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the function call." })), "name": Schema.String.annotate({ "description": "The name of the function being called." }), "arguments": Schema.String.annotate({ "description": "The arguments of the function call. This is a JSON-encoded string representing the arguments passed to the function, for example \`{\\"arg1\\": \\"value1\\", \\"arg2\\": 42}\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime function call item", "description": "A function call item in a Realtime conversation.", "identifier": "RealtimeConversationItemFunctionCall" })
export type RealtimeConversationItemFunctionCallOutput = { readonly "id"?: string, readonly "object"?: "realtime.item", readonly "type": "function_call_output", readonly "status"?: "completed" | "incomplete" | "in_progress", readonly "call_id": string, readonly "output": string, readonly [x: string]: unknown }
export const RealtimeConversationItemFunctionCallOutput = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the item. This may be provided by the client or generated by the server." })), "object": Schema.optionalKey(Schema.Literal("realtime.item").annotate({ "description": "Identifier for the API object being returned - always \`realtime.item\`. Optional when creating a new item." })), "type": Schema.Literal("function_call_output").annotate({ "description": "The type of the item. Always \`function_call_output\`." }), "status": Schema.optionalKey(Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({ "description": "The status of the item. Has no effect on the conversation." })), "call_id": Schema.String.annotate({ "description": "The ID of the function call this output is for." }), "output": Schema.String.annotate({ "description": "The output of the function call, this is free text and can contain any information or simply be empty." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime function call output item", "description": "A function call output item in a Realtime conversation.", "identifier": "RealtimeConversationItemFunctionCallOutput" })
export type RealtimeConversationItemMessageAssistant = { readonly "id"?: string, readonly "object"?: "realtime.item", readonly "type": "message", readonly "status"?: "completed" | "incomplete" | "in_progress", readonly "role": "assistant", readonly "content": ReadonlyArray<{ readonly "type"?: "output_text" | "output_audio", readonly "text"?: string, readonly "audio"?: string, readonly "transcript"?: string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const RealtimeConversationItemMessageAssistant = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the item. This may be provided by the client or generated by the server." })), "object": Schema.optionalKey(Schema.Literal("realtime.item").annotate({ "description": "Identifier for the API object being returned - always \`realtime.item\`. Optional when creating a new item." })), "type": Schema.Literal("message").annotate({ "description": "The type of the item. Always \`message\`." }), "status": Schema.optionalKey(Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({ "description": "The status of the item. Has no effect on the conversation." })), "role": Schema.Literal("assistant").annotate({ "description": "The role of the message sender. Always \`assistant\`." }), "content": Schema.Array(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["output_text", "output_audio"]).annotate({ "description": "The content type, \`output_text\` or \`output_audio\` depending on the session \`output_modalities\` configuration." })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content." })), "audio": Schema.optionalKey(Schema.String.annotate({ "description": "Base64-encoded audio bytes, these will be parsed as the format specified in the session output audio type configuration. This defaults to PCM 16-bit 24kHz mono if not specified." })), "transcript": Schema.optionalKey(Schema.String.annotate({ "description": "The transcript of the audio content, this will always be present if the output type is \`audio\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The content of the message." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime assistant message item", "description": "An assistant message item in a Realtime conversation.", "identifier": "RealtimeConversationItemMessageAssistant" })
export type RealtimeConversationItemMessageSystem = { readonly "id"?: string, readonly "object"?: "realtime.item", readonly "type": "message", readonly "status"?: "completed" | "incomplete" | "in_progress", readonly "role": "system", readonly "content": ReadonlyArray<{ readonly "type"?: "input_text", readonly "text"?: string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const RealtimeConversationItemMessageSystem = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the item. This may be provided by the client or generated by the server." })), "object": Schema.optionalKey(Schema.Literal("realtime.item").annotate({ "description": "Identifier for the API object being returned - always \`realtime.item\`. Optional when creating a new item." })), "type": Schema.Literal("message").annotate({ "description": "The type of the item. Always \`message\`." }), "status": Schema.optionalKey(Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({ "description": "The status of the item. Has no effect on the conversation." })), "role": Schema.Literal("system").annotate({ "description": "The role of the message sender. Always \`system\`." }), "content": Schema.Array(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("input_text").annotate({ "description": "The content type. Always \`input_text\` for system messages." })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The content of the message." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime system message item", "description": "A system message in a Realtime conversation can be used to provide additional context or instructions to the model. This is similar but distinct from the instruction prompt provided at the start of a conversation, as system messages can be added at any point in the conversation. For major changes to the conversation's behavior, use instructions, but for smaller updates (e.g. \\"the user is now asking about a different topic\\"), use system messages.", "identifier": "RealtimeConversationItemMessageSystem" })
export type RealtimeConversationItemMessageUser = { readonly "id"?: string, readonly "object"?: "realtime.item", readonly "type": "message", readonly "status"?: "completed" | "incomplete" | "in_progress", readonly "role": "user", readonly "content": ReadonlyArray<{ readonly "type"?: "input_text" | "input_audio" | "input_image", readonly "text"?: string, readonly "audio"?: string, readonly "image_url"?: string, readonly "detail"?: "auto" | "low" | "high", readonly "transcript"?: string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const RealtimeConversationItemMessageUser = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the item. This may be provided by the client or generated by the server." })), "object": Schema.optionalKey(Schema.Literal("realtime.item").annotate({ "description": "Identifier for the API object being returned - always \`realtime.item\`. Optional when creating a new item." })), "type": Schema.Literal("message").annotate({ "description": "The type of the item. Always \`message\`." }), "status": Schema.optionalKey(Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({ "description": "The status of the item. Has no effect on the conversation." })), "role": Schema.Literal("user").annotate({ "description": "The role of the message sender. Always \`user\`." }), "content": Schema.Array(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["input_text", "input_audio", "input_image"]).annotate({ "description": "The content type (\`input_text\`, \`input_audio\`, or \`input_image\`)." })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content (for \`input_text\`)." })), "audio": Schema.optionalKey(Schema.String.annotate({ "description": "Base64-encoded audio bytes (for \`input_audio\`), these will be parsed as the format specified in the session input audio type configuration. This defaults to PCM 16-bit 24kHz mono if not specified." })), "image_url": Schema.optionalKey(Schema.String.annotate({ "description": "Base64-encoded image bytes (for \`input_image\`) as a data URI. For example \`data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...\`. Supported formats are PNG and JPEG." })), "detail": Schema.optionalKey(Schema.Literals(["auto", "low", "high"]).annotate({ "description": "The detail level of the image (for \`input_image\`). \`auto\` will default to \`high\`.", "default": "auto" })), "transcript": Schema.optionalKey(Schema.String.annotate({ "description": "Transcript of the audio (for \`input_audio\`). This is not sent to the model, but will be attached to the message item for reference." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The content of the message." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime user message item", "description": "A user message item in a Realtime conversation.", "identifier": "RealtimeConversationItemMessageUser" })
export type RealtimeConversationItemWithReference = { readonly "id"?: string, readonly "type"?: "message" | "function_call" | "function_call_output" | "item_reference", readonly "object"?: "realtime.item", readonly "status"?: "completed" | "incomplete" | "in_progress", readonly "role"?: "user" | "assistant" | "system", readonly "content"?: ReadonlyArray<{ readonly "type"?: "input_text" | "input_audio" | "item_reference" | "text", readonly "text"?: string, readonly "id"?: string, readonly "audio"?: string, readonly "transcript"?: string, readonly [x: string]: unknown }>, readonly "call_id"?: string, readonly "name"?: string, readonly "arguments"?: string, readonly "output"?: string, readonly [x: string]: unknown }
export const RealtimeConversationItemWithReference = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "For an item of type (\`message\` | \`function_call\` | \`function_call_output\`)\\nthis field allows the client to assign the unique ID of the item. It is\\nnot required because the server will generate one if not provided.\\n\\nFor an item of type \`item_reference\`, this field is required and is a\\nreference to any item that has previously existed in the conversation.\\n" })), "type": Schema.optionalKey(Schema.Literals(["message", "function_call", "function_call_output", "item_reference"]).annotate({ "description": "The type of the item (\`message\`, \`function_call\`, \`function_call_output\`, \`item_reference\`).\\n" })), "object": Schema.optionalKey(Schema.Literal("realtime.item").annotate({ "description": "Identifier for the API object being returned - always \`realtime.item\`.\\n" })), "status": Schema.optionalKey(Schema.Literals(["completed", "incomplete", "in_progress"]).annotate({ "description": "The status of the item (\`completed\`, \`incomplete\`, \`in_progress\`). These have no effect \\non the conversation, but are accepted for consistency with the \\n\`conversation.item.created\` event.\\n" })), "role": Schema.optionalKey(Schema.Literals(["user", "assistant", "system"]).annotate({ "description": "The role of the message sender (\`user\`, \`assistant\`, \`system\`), only \\napplicable for \`message\` items.\\n" })), "content": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["input_text", "input_audio", "item_reference", "text"]).annotate({ "description": "The content type (\`input_text\`, \`input_audio\`, \`item_reference\`, \`text\`).\\n" })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content, used for \`input_text\` and \`text\` content types.\\n" })), "id": Schema.optionalKey(Schema.String.annotate({ "description": "ID of a previous conversation item to reference (for \`item_reference\`\\ncontent types in \`response.create\` events). These can reference both\\nclient and server created items.\\n" })), "audio": Schema.optionalKey(Schema.String.annotate({ "description": "Base64-encoded audio bytes, used for \`input_audio\` content type.\\n" })), "transcript": Schema.optionalKey(Schema.String.annotate({ "description": "The transcript of the audio, used for \`input_audio\` content type.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The content of the message, applicable for \`message\` items. \\n- Message items of role \`system\` support only \`input_text\` content\\n- Message items of role \`user\` support \`input_text\` and \`input_audio\` \\n  content\\n- Message items of role \`assistant\` support \`text\` content.\\n" })), "call_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the function call (for \`function_call\` and \\n\`function_call_output\` items). If passed on a \`function_call_output\` \\nitem, the server will check that a \`function_call\` item with the same \\nID exists in the conversation history.\\n" })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function being called (for \`function_call\` items).\\n" })), "arguments": Schema.optionalKey(Schema.String.annotate({ "description": "The arguments of the function call (for \`function_call\` items).\\n" })), "output": Schema.optionalKey(Schema.String.annotate({ "description": "The output of the function call (for \`function_call_output\` items).\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The item to add to the conversation.", "identifier": "RealtimeConversationItemWithReference" })
export type RealtimeFunctionTool = { readonly "type"?: "function", readonly "name"?: string, readonly "description"?: string, readonly "parameters"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeFunctionTool = Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("function").annotate({ "description": "The type of the tool, i.e. \`function\`." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function." })), "description": Schema.optionalKey(Schema.String.annotate({ "description": "The description of the function, including guidance on when and how\\nto call it, and guidance about what to tell the user when calling\\n(if anything).\\n" })), "parameters": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "Parameters of the function in JSON Schema." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool", "identifier": "RealtimeFunctionTool" })
export type RealtimeMCPApprovalRequest = { readonly "type": "mcp_approval_request", readonly "id": string, readonly "server_label": string, readonly "name": string, readonly "arguments": string, readonly [x: string]: unknown }
export const RealtimeMCPApprovalRequest = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp_approval_request").annotate({ "description": "The type of the item. Always \`mcp_approval_request\`." }), "id": Schema.String.annotate({ "description": "The unique ID of the approval request." }), "server_label": Schema.String.annotate({ "description": "The label of the MCP server making the request." }), "name": Schema.String.annotate({ "description": "The name of the tool to run." }), "arguments": Schema.String.annotate({ "description": "A JSON string of arguments for the tool." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime MCP approval request", "description": "A Realtime item requesting human approval of a tool invocation.\\n", "identifier": "RealtimeMCPApprovalRequest" })
export type RealtimeMCPApprovalResponse = { readonly "type": "mcp_approval_response", readonly "id": string, readonly "approval_request_id": string, readonly "approve": boolean, readonly "reason"?: string | null, readonly [x: string]: unknown }
export const RealtimeMCPApprovalResponse = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp_approval_response").annotate({ "description": "The type of the item. Always \`mcp_approval_response\`." }), "id": Schema.String.annotate({ "description": "The unique ID of the approval response." }), "approval_request_id": Schema.String.annotate({ "description": "The ID of the approval request being answered." }), "approve": Schema.Boolean.annotate({ "description": "Whether the request was approved." }), "reason": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Optional reason for the decision." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime MCP approval response", "description": "A Realtime item responding to an MCP approval request.\\n", "identifier": "RealtimeMCPApprovalResponse" })
export type RealtimeMCPHTTPError = { readonly "type": "http_error", readonly "code": number, readonly "message": string, readonly [x: string]: unknown }
export const RealtimeMCPHTTPError = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("http_error"), "code": Schema.Number.check(Schema.isInt()), "message": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime MCP HTTP error", "identifier": "RealtimeMCPHTTPError" })
export type RealtimeMCPProtocolError = { readonly "type": "protocol_error", readonly "code": number, readonly "message": string, readonly [x: string]: unknown }
export const RealtimeMCPProtocolError = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("protocol_error"), "code": Schema.Number.check(Schema.isInt()), "message": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime MCP protocol error", "identifier": "RealtimeMCPProtocolError" })
export type RealtimeMCPToolExecutionError = { readonly "type": "tool_execution_error", readonly "message": string, readonly [x: string]: unknown }
export const RealtimeMCPToolExecutionError = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("tool_execution_error"), "message": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime MCP tool execution error", "identifier": "RealtimeMCPToolExecutionError" })
export type RealtimeServerEventConversationCreated = { readonly "event_id": string, readonly "type": "conversation.created", readonly "conversation": { readonly "id"?: string, readonly "object"?: "realtime.conversation", readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeServerEventConversationCreated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.created").annotate({ "description": "The event type, must be \`conversation.created\`." }), "conversation": Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the conversation." })), "object": Schema.optionalKey(Schema.Literal("realtime.conversation").annotate({ "description": "The object type, must be \`realtime.conversation\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The conversation resource." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a conversation is created. Emitted right after session creation.\\n", "identifier": "RealtimeServerEventConversationCreated" })
export type RealtimeServerEventConversationItemDeleted = { readonly "event_id": string, readonly "type": "conversation.item.deleted", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventConversationItemDeleted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.deleted").annotate({ "description": "The event type, must be \`conversation.item.deleted\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the item that was deleted." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an item in the conversation is deleted by the client with a \\n\`conversation.item.delete\` event. This event is used to synchronize the \\nserver's understanding of the conversation history with the client's view.\\n", "identifier": "RealtimeServerEventConversationItemDeleted" })
export type RealtimeServerEventConversationItemInputAudioTranscriptionFailed = { readonly "event_id": string, readonly "type": "conversation.item.input_audio_transcription.failed", readonly "item_id": string, readonly "content_index": number, readonly "error": { readonly "type"?: string, readonly "code"?: string, readonly "message"?: string, readonly "param"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeServerEventConversationItemInputAudioTranscriptionFailed = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.input_audio_transcription.failed").annotate({ "description": "The event type, must be\\n\`conversation.item.input_audio_transcription.failed\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the user message item." }), "content_index": Schema.Number.annotate({ "description": "The index of the content part containing the audio." }).check(Schema.isInt()), "error": Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of error." })), "code": Schema.optionalKey(Schema.String.annotate({ "description": "Error code, if any." })), "message": Schema.optionalKey(Schema.String.annotate({ "description": "A human-readable error message." })), "param": Schema.optionalKey(Schema.String.annotate({ "description": "Parameter related to the error, if any." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details of the transcription error." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when input audio transcription is configured, and a transcription \\nrequest for a user message failed. These events are separate from other \\n\`error\` events so that the client can identify the related Item.\\n", "identifier": "RealtimeServerEventConversationItemInputAudioTranscriptionFailed" })
export type RealtimeServerEventConversationItemInputAudioTranscriptionSegment = { readonly "event_id": string, readonly "type": "conversation.item.input_audio_transcription.segment", readonly "item_id": string, readonly "content_index": number, readonly "text": string, readonly "id": string, readonly "speaker": string, readonly "start": number, readonly "end": number, readonly [x: string]: unknown }
export const RealtimeServerEventConversationItemInputAudioTranscriptionSegment = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.input_audio_transcription.segment").annotate({ "description": "The event type, must be \`conversation.item.input_audio_transcription.segment\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the item containing the input audio content." }), "content_index": Schema.Number.annotate({ "description": "The index of the input audio content part within the item." }).check(Schema.isInt()), "text": Schema.String.annotate({ "description": "The text for this segment." }), "id": Schema.String.annotate({ "description": "The segment identifier." }), "speaker": Schema.String.annotate({ "description": "The detected speaker label for this segment." }), "start": Schema.Number.annotate({ "description": "Start time of the segment in seconds.", "format": "float" }).check(Schema.isFinite()), "end": Schema.Number.annotate({ "description": "End time of the segment in seconds.", "format": "float" }).check(Schema.isFinite()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an input audio transcription segment is identified for an item.", "identifier": "RealtimeServerEventConversationItemInputAudioTranscriptionSegment" })
export type RealtimeServerEventConversationItemTruncated = { readonly "event_id": string, readonly "type": "conversation.item.truncated", readonly "item_id": string, readonly "content_index": number, readonly "audio_end_ms": number, readonly [x: string]: unknown }
export const RealtimeServerEventConversationItemTruncated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.truncated").annotate({ "description": "The event type, must be \`conversation.item.truncated\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the assistant message item that was truncated." }), "content_index": Schema.Number.annotate({ "description": "The index of the content part that was truncated." }).check(Schema.isInt()), "audio_end_ms": Schema.Number.annotate({ "description": "The duration up to which the audio was truncated, in milliseconds.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an earlier assistant audio message item is truncated by the \\nclient with a \`conversation.item.truncate\` event. This event is used to \\nsynchronize the server's understanding of the audio with the client's playback.\\n\\nThis action will truncate the audio and remove the server-side text transcript \\nto ensure there is no text in the context that hasn't been heard by the user.\\n", "identifier": "RealtimeServerEventConversationItemTruncated" })
export type RealtimeServerEventError = { readonly "event_id": string, readonly "type": "error", readonly "error": { readonly "type": string, readonly "code"?: string | null, readonly "message": string, readonly "param"?: string | null, readonly "event_id"?: string | null, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeServerEventError = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("error").annotate({ "description": "The event type, must be \`error\`." }), "error": Schema.StructWithRest(Schema.Struct({ "type": Schema.String.annotate({ "description": "The type of error (e.g., \\"invalid_request_error\\", \\"server_error\\").\\n" }), "code": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Error code, if any." }), Schema.Null])), "message": Schema.String.annotate({ "description": "A human-readable error message." }), "param": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Parameter related to the error, if any." }), Schema.Null])), "event_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The event_id of the client event that caused the error, if applicable.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details of the error." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an error occurs, which could be a client problem or a server\\nproblem. Most errors are recoverable and the session will stay open, we\\nrecommend to implementors to monitor and log error messages by default.\\n", "identifier": "RealtimeServerEventError" })
export type RealtimeServerEventInputAudioBufferCleared = { readonly "event_id": string, readonly "type": "input_audio_buffer.cleared", readonly [x: string]: unknown }
export const RealtimeServerEventInputAudioBufferCleared = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("input_audio_buffer.cleared").annotate({ "description": "The event type, must be \`input_audio_buffer.cleared\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the input audio buffer is cleared by the client with a \\n\`input_audio_buffer.clear\` event.\\n", "identifier": "RealtimeServerEventInputAudioBufferCleared" })
export type RealtimeServerEventInputAudioBufferCommitted = { readonly "event_id": string, readonly "type": "input_audio_buffer.committed", readonly "previous_item_id"?: string | null, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventInputAudioBufferCommitted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("input_audio_buffer.committed").annotate({ "description": "The event type, must be \`input_audio_buffer.committed\`." }), "previous_item_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the preceding item after which the new item will be inserted.\\nCan be \`null\` if the item has no predecessor.\\n" }), Schema.Null])), "item_id": Schema.String.annotate({ "description": "The ID of the user message item that will be created." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an input audio buffer is committed, either by the client or\\nautomatically in server VAD mode. The \`item_id\` property is the ID of the user\\nmessage item that will be created, thus a \`conversation.item.created\` event\\nwill also be sent to the client.\\n", "identifier": "RealtimeServerEventInputAudioBufferCommitted" })
export type RealtimeServerEventInputAudioBufferDtmfEventReceived = { readonly "type": "input_audio_buffer.dtmf_event_received", readonly "event": string, readonly "received_at": number, readonly [x: string]: unknown }
export const RealtimeServerEventInputAudioBufferDtmfEventReceived = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_audio_buffer.dtmf_event_received").annotate({ "description": "The event type, must be \`input_audio_buffer.dtmf_event_received\`." }), "event": Schema.String.annotate({ "description": "The telephone keypad that was pressed by the user." }), "received_at": Schema.Number.annotate({ "description": "UTC Unix Timestamp when DTMF Event was received by server.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "**SIP Only:** Returned when an DTMF event is received. A DTMF event is a message that\\nrepresents a telephone keypad press (09, *, #, AD). The \`event\` property\\nis the keypad that the user press. The \`received_at\` is the UTC Unix Timestamp\\nthat the server received the event.\\n", "identifier": "RealtimeServerEventInputAudioBufferDtmfEventReceived" })
export type RealtimeServerEventInputAudioBufferSpeechStarted = { readonly "event_id": string, readonly "type": "input_audio_buffer.speech_started", readonly "audio_start_ms": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventInputAudioBufferSpeechStarted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("input_audio_buffer.speech_started").annotate({ "description": "The event type, must be \`input_audio_buffer.speech_started\`." }), "audio_start_ms": Schema.Number.annotate({ "description": "Milliseconds from the start of all audio written to the buffer during the \\nsession when speech was first detected. This will correspond to the \\nbeginning of audio sent to the model, and thus includes the \\n\`prefix_padding_ms\` configured in the Session.\\n" }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the user message item that will be created when speech stops.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Sent by the server when in \`server_vad\` mode to indicate that speech has been \\ndetected in the audio buffer. This can happen any time audio is added to the \\nbuffer (unless speech is already detected). The client may want to use this \\nevent to interrupt audio playback or provide visual feedback to the user. \\n\\nThe client should expect to receive a \`input_audio_buffer.speech_stopped\` event \\nwhen speech stops. The \`item_id\` property is the ID of the user message item \\nthat will be created when speech stops and will also be included in the \\n\`input_audio_buffer.speech_stopped\` event (unless the client manually commits \\nthe audio buffer during VAD activation).\\n", "identifier": "RealtimeServerEventInputAudioBufferSpeechStarted" })
export type RealtimeServerEventInputAudioBufferSpeechStopped = { readonly "event_id": string, readonly "type": "input_audio_buffer.speech_stopped", readonly "audio_end_ms": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventInputAudioBufferSpeechStopped = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("input_audio_buffer.speech_stopped").annotate({ "description": "The event type, must be \`input_audio_buffer.speech_stopped\`." }), "audio_end_ms": Schema.Number.annotate({ "description": "Milliseconds since the session started when speech stopped. This will \\ncorrespond to the end of audio sent to the model, and thus includes the \\n\`min_silence_duration_ms\` configured in the Session.\\n" }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the user message item that will be created." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned in \`server_vad\` mode when the server detects the end of speech in \\nthe audio buffer. The server will also send an \`conversation.item.created\` \\nevent with the user message item that is created from the audio buffer.\\n", "identifier": "RealtimeServerEventInputAudioBufferSpeechStopped" })
export type RealtimeServerEventInputAudioBufferTimeoutTriggered = { readonly "event_id": string, readonly "type": "input_audio_buffer.timeout_triggered", readonly "audio_start_ms": number, readonly "audio_end_ms": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventInputAudioBufferTimeoutTriggered = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("input_audio_buffer.timeout_triggered").annotate({ "description": "The event type, must be \`input_audio_buffer.timeout_triggered\`." }), "audio_start_ms": Schema.Number.annotate({ "description": "Millisecond offset of audio written to the input audio buffer that was after the playback time of the last model response." }).check(Schema.isInt()), "audio_end_ms": Schema.Number.annotate({ "description": "Millisecond offset of audio written to the input audio buffer at the time the timeout was triggered." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the item associated with this segment." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the Server VAD timeout is triggered for the input audio buffer. This is configured\\nwith \`idle_timeout_ms\` in the \`turn_detection\` settings of the session, and it indicates that\\nthere hasn't been any speech detected for the configured duration.\\n\\nThe \`audio_start_ms\` and \`audio_end_ms\` fields indicate the segment of audio after the last\\nmodel response up to the triggering time, as an offset from the beginning of audio written\\nto the input audio buffer. This means it demarcates the segment of audio that was silent and\\nthe difference between the start and end values will roughly match the configured timeout.\\n\\nThe empty audio will be committed to the conversation as an \`input_audio\` item (there will be a\\n\`input_audio_buffer.committed\` event) and a model response will be generated. There may be speech\\nthat didn't trigger VAD but is still detected by the model, so the model may respond with\\nsomething relevant to the conversation or a prompt to continue speaking.\\n", "identifier": "RealtimeServerEventInputAudioBufferTimeoutTriggered" })
export type RealtimeServerEventMCPListToolsCompleted = { readonly "event_id": string, readonly "type": "mcp_list_tools.completed", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventMCPListToolsCompleted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("mcp_list_tools.completed").annotate({ "description": "The event type, must be \`mcp_list_tools.completed\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP list tools item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when listing MCP tools has completed for an item.", "identifier": "RealtimeServerEventMCPListToolsCompleted" })
export type RealtimeServerEventMCPListToolsFailed = { readonly "event_id": string, readonly "type": "mcp_list_tools.failed", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventMCPListToolsFailed = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("mcp_list_tools.failed").annotate({ "description": "The event type, must be \`mcp_list_tools.failed\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP list tools item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when listing MCP tools has failed for an item.", "identifier": "RealtimeServerEventMCPListToolsFailed" })
export type RealtimeServerEventMCPListToolsInProgress = { readonly "event_id": string, readonly "type": "mcp_list_tools.in_progress", readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventMCPListToolsInProgress = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("mcp_list_tools.in_progress").annotate({ "description": "The event type, must be \`mcp_list_tools.in_progress\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP list tools item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when listing MCP tools is in progress for an item.", "identifier": "RealtimeServerEventMCPListToolsInProgress" })
export type RealtimeServerEventOutputAudioBufferCleared = { readonly "event_id": string, readonly "type": "output_audio_buffer.cleared", readonly "response_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventOutputAudioBufferCleared = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("output_audio_buffer.cleared").annotate({ "description": "The event type, must be \`output_audio_buffer.cleared\`." }), "response_id": Schema.String.annotate({ "description": "The unique ID of the response that produced the audio." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "**WebRTC/SIP Only:** Emitted when the output audio buffer is cleared. This happens either in VAD\\nmode when the user has interrupted (\`input_audio_buffer.speech_started\`),\\nor when the client has emitted the \`output_audio_buffer.clear\` event to manually\\ncut off the current audio response.\\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\\n", "identifier": "RealtimeServerEventOutputAudioBufferCleared" })
export type RealtimeServerEventOutputAudioBufferStarted = { readonly "event_id": string, readonly "type": "output_audio_buffer.started", readonly "response_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventOutputAudioBufferStarted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("output_audio_buffer.started").annotate({ "description": "The event type, must be \`output_audio_buffer.started\`." }), "response_id": Schema.String.annotate({ "description": "The unique ID of the response that produced the audio." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "**WebRTC/SIP Only:** Emitted when the server begins streaming audio to the client. This event is\\nemitted after an audio content part has been added (\`response.content_part.added\`)\\nto the response.\\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\\n", "identifier": "RealtimeServerEventOutputAudioBufferStarted" })
export type RealtimeServerEventOutputAudioBufferStopped = { readonly "event_id": string, readonly "type": "output_audio_buffer.stopped", readonly "response_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventOutputAudioBufferStopped = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("output_audio_buffer.stopped").annotate({ "description": "The event type, must be \`output_audio_buffer.stopped\`." }), "response_id": Schema.String.annotate({ "description": "The unique ID of the response that produced the audio." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "**WebRTC/SIP Only:** Emitted when the output audio buffer has been completely drained on the server,\\nand no more audio is forthcoming. This event is emitted after the full response\\ndata has been sent to the client (\`response.done\`).\\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\\n", "identifier": "RealtimeServerEventOutputAudioBufferStopped" })
export type RealtimeServerEventRateLimitsUpdated = { readonly "event_id": string, readonly "type": "rate_limits.updated", readonly "rate_limits": ReadonlyArray<{ readonly "name"?: "requests" | "tokens", readonly "limit"?: number, readonly "remaining"?: number, readonly "reset_seconds"?: number, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const RealtimeServerEventRateLimitsUpdated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("rate_limits.updated").annotate({ "description": "The event type, must be \`rate_limits.updated\`." }), "rate_limits": Schema.Array(Schema.StructWithRest(Schema.Struct({ "name": Schema.optionalKey(Schema.Literals(["requests", "tokens"]).annotate({ "description": "The name of the rate limit (\`requests\`, \`tokens\`).\\n" })), "limit": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum allowed value for the rate limit." }).check(Schema.isInt())), "remaining": Schema.optionalKey(Schema.Number.annotate({ "description": "The remaining value before the limit is reached." }).check(Schema.isInt())), "reset_seconds": Schema.optionalKey(Schema.Number.annotate({ "description": "Seconds until the rate limit resets." }).check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "List of rate limit information." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted at the beginning of a Response to indicate the updated rate limits. \\nWhen a Response is created some tokens will be \\"reserved\\" for the output \\ntokens, the rate limits shown here reflect that reservation, which is then \\nadjusted accordingly once the Response is completed.\\n", "identifier": "RealtimeServerEventRateLimitsUpdated" })
export type RealtimeServerEventResponseAudioDelta = { readonly "event_id": string, readonly "type": "response.output_audio.delta", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "delta": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseAudioDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_audio.delta").annotate({ "description": "The event type, must be \`response.output_audio.delta\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "Base64-encoded audio data delta." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated audio is updated.", "identifier": "RealtimeServerEventResponseAudioDelta" })
export type RealtimeServerEventResponseAudioDone = { readonly "event_id": string, readonly "type": "response.output_audio.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly [x: string]: unknown }
export const RealtimeServerEventResponseAudioDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_audio.done").annotate({ "description": "The event type, must be \`response.output_audio.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated audio is done. Also emitted when a Response\\nis interrupted, incomplete, or cancelled.\\n", "identifier": "RealtimeServerEventResponseAudioDone" })
export type RealtimeServerEventResponseAudioTranscriptDelta = { readonly "event_id": string, readonly "type": "response.output_audio_transcript.delta", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "delta": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseAudioTranscriptDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_audio_transcript.delta").annotate({ "description": "The event type, must be \`response.output_audio_transcript.delta\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The transcript delta." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated transcription of audio output is updated.\\n", "identifier": "RealtimeServerEventResponseAudioTranscriptDelta" })
export type RealtimeServerEventResponseAudioTranscriptDone = { readonly "event_id": string, readonly "type": "response.output_audio_transcript.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "transcript": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseAudioTranscriptDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_audio_transcript.done").annotate({ "description": "The event type, must be \`response.output_audio_transcript.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "transcript": Schema.String.annotate({ "description": "The final transcript of the audio." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated transcription of audio output is done\\nstreaming. Also emitted when a Response is interrupted, incomplete, or\\ncancelled.\\n", "identifier": "RealtimeServerEventResponseAudioTranscriptDone" })
export type RealtimeServerEventResponseContentPartAdded = { readonly "event_id": string, readonly "type": "response.content_part.added", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "part": { readonly "type"?: "text" | "audio", readonly "text"?: string, readonly "audio"?: string, readonly "transcript"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeServerEventResponseContentPartAdded = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.content_part.added").annotate({ "description": "The event type, must be \`response.content_part.added\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item to which the content part was added." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "part": Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["text", "audio"]).annotate({ "description": "The content type (\\"text\\", \\"audio\\")." })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content (if type is \\"text\\")." })), "audio": Schema.optionalKey(Schema.String.annotate({ "description": "Base64-encoded audio data (if type is \\"audio\\")." })), "transcript": Schema.optionalKey(Schema.String.annotate({ "description": "The transcript of the audio (if type is \\"audio\\")." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The content part that was added." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a new content part is added to an assistant message item during\\nresponse generation.\\n", "identifier": "RealtimeServerEventResponseContentPartAdded" })
export type RealtimeServerEventResponseContentPartDone = { readonly "event_id": string, readonly "type": "response.content_part.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "part": { readonly "type"?: "text" | "audio", readonly "text"?: string, readonly "audio"?: string, readonly "transcript"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeServerEventResponseContentPartDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.content_part.done").annotate({ "description": "The event type, must be \`response.content_part.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "part": Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["text", "audio"]).annotate({ "description": "The content type (\\"text\\", \\"audio\\")." })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content (if type is \\"text\\")." })), "audio": Schema.optionalKey(Schema.String.annotate({ "description": "Base64-encoded audio data (if type is \\"audio\\")." })), "transcript": Schema.optionalKey(Schema.String.annotate({ "description": "The transcript of the audio (if type is \\"audio\\")." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The content part that is done." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a content part is done streaming in an assistant message item.\\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\\n", "identifier": "RealtimeServerEventResponseContentPartDone" })
export type RealtimeServerEventResponseFunctionCallArgumentsDelta = { readonly "event_id": string, readonly "type": "response.function_call_arguments.delta", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "call_id": string, readonly "delta": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseFunctionCallArgumentsDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.function_call_arguments.delta").annotate({ "description": "The event type, must be \`response.function_call_arguments.delta\`.\\n" }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the function call item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "call_id": Schema.String.annotate({ "description": "The ID of the function call." }), "delta": Schema.String.annotate({ "description": "The arguments delta as a JSON string." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated function call arguments are updated.\\n", "identifier": "RealtimeServerEventResponseFunctionCallArgumentsDelta" })
export type RealtimeServerEventResponseFunctionCallArgumentsDone = { readonly "event_id": string, readonly "type": "response.function_call_arguments.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "call_id": string, readonly "arguments": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseFunctionCallArgumentsDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.function_call_arguments.done").annotate({ "description": "The event type, must be \`response.function_call_arguments.done\`.\\n" }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the function call item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "call_id": Schema.String.annotate({ "description": "The ID of the function call." }), "arguments": Schema.String.annotate({ "description": "The final arguments as a JSON string." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the model-generated function call arguments are done streaming.\\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\\n", "identifier": "RealtimeServerEventResponseFunctionCallArgumentsDone" })
export type RealtimeServerEventResponseMCPCallArgumentsDelta = { readonly "event_id": string, readonly "type": "response.mcp_call_arguments.delta", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "delta": string, readonly "obfuscation"?: string | null, readonly [x: string]: unknown }
export const RealtimeServerEventResponseMCPCallArgumentsDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.mcp_call_arguments.delta").annotate({ "description": "The event type, must be \`response.mcp_call_arguments.delta\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The JSON-encoded arguments delta." }), "obfuscation": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "If present, indicates the delta text was obfuscated." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when MCP tool call arguments are updated during response generation.", "identifier": "RealtimeServerEventResponseMCPCallArgumentsDelta" })
export type RealtimeServerEventResponseMCPCallArgumentsDone = { readonly "event_id": string, readonly "type": "response.mcp_call_arguments.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "arguments": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseMCPCallArgumentsDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.mcp_call_arguments.done").annotate({ "description": "The event type, must be \`response.mcp_call_arguments.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "arguments": Schema.String.annotate({ "description": "The final JSON-encoded arguments string." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when MCP tool call arguments are finalized during response generation.", "identifier": "RealtimeServerEventResponseMCPCallArgumentsDone" })
export type RealtimeServerEventResponseMCPCallCompleted = { readonly "event_id": string, readonly "type": "response.mcp_call.completed", readonly "output_index": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseMCPCallCompleted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.mcp_call.completed").annotate({ "description": "The event type, must be \`response.mcp_call.completed\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an MCP tool call has completed successfully.", "identifier": "RealtimeServerEventResponseMCPCallCompleted" })
export type RealtimeServerEventResponseMCPCallFailed = { readonly "event_id": string, readonly "type": "response.mcp_call.failed", readonly "output_index": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseMCPCallFailed = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.mcp_call.failed").annotate({ "description": "The event type, must be \`response.mcp_call.failed\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an MCP tool call has failed.", "identifier": "RealtimeServerEventResponseMCPCallFailed" })
export type RealtimeServerEventResponseMCPCallInProgress = { readonly "event_id": string, readonly "type": "response.mcp_call.in_progress", readonly "output_index": number, readonly "item_id": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseMCPCallInProgress = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.mcp_call.in_progress").annotate({ "description": "The event type, must be \`response.mcp_call.in_progress\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an MCP tool call has started and is in progress.", "identifier": "RealtimeServerEventResponseMCPCallInProgress" })
export type RealtimeServerEventResponseTextDelta = { readonly "event_id": string, readonly "type": "response.output_text.delta", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "delta": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseTextDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_text.delta").annotate({ "description": "The event type, must be \`response.output_text.delta\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The text delta." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the text value of an \\"output_text\\" content part is updated.", "identifier": "RealtimeServerEventResponseTextDelta" })
export type RealtimeServerEventResponseTextDone = { readonly "event_id": string, readonly "type": "response.output_text.done", readonly "response_id": string, readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "text": string, readonly [x: string]: unknown }
export const RealtimeServerEventResponseTextDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_text.done").annotate({ "description": "The event type, must be \`response.output_text.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the response." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt()), "text": Schema.String.annotate({ "description": "The final text content." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the text value of an \\"output_text\\" content part is done streaming. Also\\nemitted when a Response is interrupted, incomplete, or cancelled.\\n", "identifier": "RealtimeServerEventResponseTextDone" })
export type RealtimeTruncation = "auto" | "disabled" | { readonly "type": "retention_ratio", readonly "retention_ratio": number, readonly "token_limits"?: { readonly "post_instructions"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeTruncation = Schema.Union([Schema.Literals(["auto", "disabled"]).annotate({ "title": "RealtimeTruncationStrategy", "description": "The truncation strategy to use for the session. \`auto\` is the default truncation strategy. \`disabled\` will disable truncation and emit errors when the conversation exceeds the input token limit." }), Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("retention_ratio").annotate({ "description": "Use retention ratio truncation." }), "retention_ratio": Schema.Number.annotate({ "description": "Fraction of post-instruction conversation tokens to retain (\`0.0\` - \`1.0\`) when the conversation exceeds the input token limit. Setting this to \`0.8\` means that messages will be dropped until 80% of the maximum allowed tokens are used. This helps reduce the frequency of truncations and improve cache rates.\\n" }).check(Schema.isFinite()), "token_limits": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "post_instructions": Schema.optionalKey(Schema.Number.annotate({ "description": "Maximum tokens allowed in the conversation after instructions (which including tool definitions). For example, setting this to 5,000 would mean that truncation would occur when the conversation exceeds 5,000 tokens after instructions. This cannot be higher than the model's context window size minus the maximum output tokens." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Optional custom token limits for this truncation strategy. If not provided, the model's default token limits will be used." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Retention ratio truncation", "description": "Retain a fraction of the conversation tokens when the conversation exceeds the input token limit. This allows you to amortize truncations across multiple turns, which can help improve cached token usage." })]).annotate({ "title": "Realtime Truncation Controls", "description": "When the number of tokens in a conversation exceeds the model's input token limit, the conversation be truncated, meaning messages (starting from the oldest) will not be included in the model's context. A 32k context model with 4,096 max output tokens can only include 28,224 tokens in the context before truncation occurs.\\n\\nClients can configure truncation behavior to truncate with a lower max token limit, which is an effective way to control token usage and cost.\\n\\nTruncation will reduce the number of cached tokens on the next turn (busting the cache), since messages are dropped from the beginning of the context. However, clients can also configure truncation to retain messages up to a fraction of the maximum context size, which will reduce the need for future truncations and thus improve the cache rate.\\n\\nTruncation can be disabled entirely, which means the server will never truncate but would instead return an error if the conversation exceeds the model's input token limit.\\n", "identifier": "RealtimeTruncation" })
export type RealtimeTurnDetection = { readonly "type": "server_vad", readonly "threshold"?: number, readonly "prefix_padding_ms"?: number, readonly "silence_duration_ms"?: number, readonly "create_response"?: boolean, readonly "interrupt_response"?: boolean, readonly "idle_timeout_ms"?: number | null, readonly [x: string]: unknown } | { readonly "type": "semantic_vad", readonly "eagerness"?: "low" | "medium" | "high" | "auto", readonly "create_response"?: boolean, readonly "interrupt_response"?: boolean, readonly [x: string]: unknown } | null
export const RealtimeTurnDetection = Schema.Union([Schema.Union([Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("server_vad").annotate({ "description": "Type of turn detection, \`server_vad\` to turn on simple Server VAD.\\n", "default": "server_vad" }), "threshold": Schema.optionalKey(Schema.Number.annotate({ "description": "Used only for \`server_vad\` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\\nhigher threshold will require louder audio to activate the model, and\\nthus might perform better in noisy environments.\\n" }).check(Schema.isFinite())), "prefix_padding_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Used only for \`server_vad\` mode. Amount of audio to include before the VAD detected speech (in\\nmilliseconds). Defaults to 300ms.\\n" }).check(Schema.isInt())), "silence_duration_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Used only for \`server_vad\` mode. Duration of silence to detect speech stop (in milliseconds). Defaults\\nto 500ms. With shorter values the model will respond more quickly,\\nbut may jump in on short pauses from the user.\\n" }).check(Schema.isInt())), "create_response": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Whether or not to automatically generate a response when a VAD stop event occurs. If \`interrupt_response\` is set to \`false\` this may fail to create a response if the model is already responding.\\n\\nIf both \`create_response\` and \`interrupt_response\` are set to \`false\`, the model will never respond automatically but VAD events will still be emitted.\\n", "default": true })), "interrupt_response": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Whether or not to automatically interrupt (cancel) any ongoing response with output to the default\\nconversation (i.e. \`conversation\` of \`auto\`) when a VAD start event occurs. If \`true\` then the response will be cancelled, otherwise it will continue until complete.\\n\\nIf both \`create_response\` and \`interrupt_response\` are set to \`false\`, the model will never respond automatically but VAD events will still be emitted.\\n", "default": true })), "idle_timeout_ms": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "Optional timeout after which a model response will be triggered automatically. This is\\nuseful for situations in which a long pause from the user is unexpected, such as a phone\\ncall. The model will effectively prompt the user to continue the conversation based\\non the current context.\\n\\nThe timeout value will be applied after the last model response's audio has finished playing,\\ni.e. it's set to the \`response.done\` time plus audio playback duration.\\n\\nAn \`input_audio_buffer.timeout_triggered\` event (plus events\\nassociated with the Response) will be emitted when the timeout is reached.\\nIdle timeout is currently only supported for \`server_vad\` mode.\\n" }).check(Schema.isInt()), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Server VAD", "description": "Server-side voice activity detection (VAD) which flips on when user speech is detected and off after a period of silence." }), Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("semantic_vad").annotate({ "description": "Type of turn detection, \`semantic_vad\` to turn on Semantic VAD.\\n" }), "eagerness": Schema.optionalKey(Schema.Literals(["low", "medium", "high", "auto"]).annotate({ "description": "Used only for \`semantic_vad\` mode. The eagerness of the model to respond. \`low\` will wait longer for the user to continue speaking, \`high\` will respond more quickly. \`auto\` is the default and is equivalent to \`medium\`. \`low\`, \`medium\`, and \`high\` have max timeouts of 8s, 4s, and 2s respectively.\\n", "default": "auto" })), "create_response": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Whether or not to automatically generate a response when a VAD stop event occurs.\\n", "default": true })), "interrupt_response": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Whether or not to automatically interrupt any ongoing response with output to the default\\nconversation (i.e. \`conversation\` of \`auto\`) when a VAD start event occurs.\\n", "default": true })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Semantic VAD", "description": "Server-side semantic turn detection which uses a model to determine when the user has finished speaking." })]).annotate({ "title": "Realtime Turn Detection", "description": "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to \`null\` to turn off, in which case the client must manually trigger model response.\\n\\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\\n\\nSemantic VAD is more advanced and uses a turn detection model (in conjunction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \\"uhhm\\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\\n" }), Schema.Null]).annotate({ "identifier": "RealtimeTurnDetection" })
export type ReasoningEffort = "none" | "minimal" | "low" | "medium" | "high" | "xhigh" | null
export const ReasoningEffort = Schema.Union([Schema.Literals(["none", "minimal", "low", "medium", "high", "xhigh"]).annotate({ "description": "Constrains effort on reasoning for\\n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\\nCurrently supported values are \`none\`, \`minimal\`, \`low\`, \`medium\`, \`high\`, and \`xhigh\`. Reducing\\nreasoning effort can result in faster responses and fewer tokens used\\non reasoning in a response.\\n\\n- \`gpt-5.1\` defaults to \`none\`, which does not perform reasoning. The supported reasoning values for \`gpt-5.1\` are \`none\`, \`low\`, \`medium\`, and \`high\`. Tool calls are supported for all reasoning values in gpt-5.1.\\n- All models before \`gpt-5.1\` default to \`medium\` reasoning effort, and do not support \`none\`.\\n- The \`gpt-5-pro\` model defaults to (and only supports) \`high\` reasoning effort.\\n- \`xhigh\` is supported for all models after \`gpt-5.1-codex-max\`.\\n", "default": "medium" }), Schema.Null]).annotate({ "identifier": "ReasoningEffort" })
export type Response = never
export const Response = Schema.Never.annotate({ "identifier": "Response" })
export type ResponseAudioDeltaEvent = { readonly "type": "response.audio.delta", readonly "sequence_number": number, readonly "delta": string, readonly [x: string]: unknown }
export const ResponseAudioDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.audio.delta").annotate({ "description": "The type of the event. Always \`response.audio.delta\`.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "A sequence number for this chunk of the stream response.\\n" }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "A chunk of Base64 encoded response audio bytes.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when there is a partial audio response.", "identifier": "ResponseAudioDeltaEvent" })
export type ResponseAudioDoneEvent = { readonly "type": "response.audio.done", readonly "sequence_number": number, readonly "response_id": unknown, readonly [x: string]: unknown }
export const ResponseAudioDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.audio.done").annotate({ "description": "The type of the event. Always \`response.audio.done\`.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of the delta.\\n" }).check(Schema.isInt()), "response_id": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when the audio response is complete.", "identifier": "ResponseAudioDoneEvent" })
export type ResponseAudioTranscriptDeltaEvent = { readonly "type": "response.audio.transcript.delta", readonly "delta": string, readonly "sequence_number": number, readonly "response_id": unknown, readonly [x: string]: unknown }
export const ResponseAudioTranscriptDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.audio.transcript.delta").annotate({ "description": "The type of the event. Always \`response.audio.transcript.delta\`.\\n" }), "delta": Schema.String.annotate({ "description": "The partial transcript of the audio response.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "response_id": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when there is a partial transcript of audio.", "identifier": "ResponseAudioTranscriptDeltaEvent" })
export type ResponseAudioTranscriptDoneEvent = { readonly "type": "response.audio.transcript.done", readonly "sequence_number": number, readonly "response_id": unknown, readonly [x: string]: unknown }
export const ResponseAudioTranscriptDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.audio.transcript.done").annotate({ "description": "The type of the event. Always \`response.audio.transcript.done\`.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "response_id": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when the full audio transcript is completed.", "identifier": "ResponseAudioTranscriptDoneEvent" })
export type ResponseCodeInterpreterCallCodeDeltaEvent = { readonly "type": "response.code_interpreter_call_code.delta", readonly "output_index": number, readonly "item_id": string, readonly "delta": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseCodeInterpreterCallCodeDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.code_interpreter_call_code.delta").annotate({ "description": "The type of the event. Always \`response.code_interpreter_call_code.delta\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response for which the code is being streamed." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the code interpreter tool call item." }), "delta": Schema.String.annotate({ "description": "The partial code snippet being streamed by the code interpreter." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event, used to order streaming events." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a partial code snippet is streamed by the code interpreter.", "identifier": "ResponseCodeInterpreterCallCodeDeltaEvent" })
export type ResponseCodeInterpreterCallCodeDoneEvent = { readonly "type": "response.code_interpreter_call_code.done", readonly "output_index": number, readonly "item_id": string, readonly "code": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseCodeInterpreterCallCodeDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.code_interpreter_call_code.done").annotate({ "description": "The type of the event. Always \`response.code_interpreter_call_code.done\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response for which the code is finalized." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the code interpreter tool call item." }), "code": Schema.String.annotate({ "description": "The final code snippet output by the code interpreter." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event, used to order streaming events." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when the code snippet is finalized by the code interpreter.", "identifier": "ResponseCodeInterpreterCallCodeDoneEvent" })
export type ResponseCodeInterpreterCallCompletedEvent = { readonly "type": "response.code_interpreter_call.completed", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseCodeInterpreterCallCompletedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.code_interpreter_call.completed").annotate({ "description": "The type of the event. Always \`response.code_interpreter_call.completed\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response for which the code interpreter call is completed." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the code interpreter tool call item." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event, used to order streaming events." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when the code interpreter call is completed.", "identifier": "ResponseCodeInterpreterCallCompletedEvent" })
export type ResponseCodeInterpreterCallInProgressEvent = { readonly "type": "response.code_interpreter_call.in_progress", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseCodeInterpreterCallInProgressEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.code_interpreter_call.in_progress").annotate({ "description": "The type of the event. Always \`response.code_interpreter_call.in_progress\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response for which the code interpreter call is in progress." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the code interpreter tool call item." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event, used to order streaming events." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a code interpreter call is in progress.", "identifier": "ResponseCodeInterpreterCallInProgressEvent" })
export type ResponseCodeInterpreterCallInterpretingEvent = { readonly "type": "response.code_interpreter_call.interpreting", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseCodeInterpreterCallInterpretingEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.code_interpreter_call.interpreting").annotate({ "description": "The type of the event. Always \`response.code_interpreter_call.interpreting\`." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response for which the code interpreter is interpreting code." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the code interpreter tool call item." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event, used to order streaming events." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when the code interpreter is actively interpreting the code snippet.", "identifier": "ResponseCodeInterpreterCallInterpretingEvent" })
export type ResponseCustomToolCallInputDeltaEvent = { readonly "type": "response.custom_tool_call_input.delta", readonly "sequence_number": number, readonly "output_index": number, readonly "item_id": string, readonly "delta": string, readonly [x: string]: unknown }
export const ResponseCustomToolCallInputDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.custom_tool_call_input.delta").annotate({ "description": "The event type identifier." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "output_index": Schema.Number.annotate({ "description": "The index of the output this delta applies to." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "Unique identifier for the API item associated with this event." }), "delta": Schema.String.annotate({ "description": "The incremental input data (delta) for the custom tool call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseCustomToolCallInputDelta", "description": "Event representing a delta (partial update) to the input of a custom tool call.\\n", "identifier": "ResponseCustomToolCallInputDeltaEvent" })
export type ResponseCustomToolCallInputDoneEvent = { readonly "type": "response.custom_tool_call_input.done", readonly "sequence_number": number, readonly "output_index": number, readonly "item_id": string, readonly "input": string, readonly [x: string]: unknown }
export const ResponseCustomToolCallInputDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.custom_tool_call_input.done").annotate({ "description": "The event type identifier." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "output_index": Schema.Number.annotate({ "description": "The index of the output this event applies to." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "Unique identifier for the API item associated with this event." }), "input": Schema.String.annotate({ "description": "The complete input data for the custom tool call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseCustomToolCallInputDone", "description": "Event indicating that input for a custom tool call is complete.\\n", "identifier": "ResponseCustomToolCallInputDoneEvent" })
export type ResponseErrorCode = "server_error" | "rate_limit_exceeded" | "invalid_prompt" | "vector_store_timeout" | "invalid_image" | "invalid_image_format" | "invalid_base64_image" | "invalid_image_url" | "image_too_large" | "image_too_small" | "image_parse_error" | "image_content_policy_violation" | "invalid_image_mode" | "image_file_too_large" | "unsupported_image_media_type" | "empty_image_file" | "failed_to_download_image" | "image_file_not_found"
export const ResponseErrorCode = Schema.Literals(["server_error", "rate_limit_exceeded", "invalid_prompt", "vector_store_timeout", "invalid_image", "invalid_image_format", "invalid_base64_image", "invalid_image_url", "image_too_large", "image_too_small", "image_parse_error", "image_content_policy_violation", "invalid_image_mode", "image_file_too_large", "unsupported_image_media_type", "empty_image_file", "failed_to_download_image", "image_file_not_found"]).annotate({ "description": "The error code for the response.\\n", "identifier": "ResponseErrorCode" })
export type ResponseErrorEvent = { readonly "type": "error", readonly "code": string | null, readonly "message": string, readonly "param": string | null, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseErrorEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("error").annotate({ "description": "The type of the event. Always \`error\`.\\n" }), "code": Schema.Union([Schema.String.annotate({ "description": "The error code.\\n" }), Schema.Null]), "message": Schema.String.annotate({ "description": "The error message.\\n" }), "param": Schema.Union([Schema.String.annotate({ "description": "The error parameter.\\n" }), Schema.Null]), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when an error occurs.", "identifier": "ResponseErrorEvent" })
export type ResponseFileSearchCallCompletedEvent = { readonly "type": "response.file_search_call.completed", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseFileSearchCallCompletedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.file_search_call.completed").annotate({ "description": "The type of the event. Always \`response.file_search_call.completed\`.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the file search call is initiated.\\n" }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the output item that the file search call is initiated.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a file search call is completed (results found).", "identifier": "ResponseFileSearchCallCompletedEvent" })
export type ResponseFileSearchCallInProgressEvent = { readonly "type": "response.file_search_call.in_progress", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseFileSearchCallInProgressEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.file_search_call.in_progress").annotate({ "description": "The type of the event. Always \`response.file_search_call.in_progress\`.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the file search call is initiated.\\n" }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the output item that the file search call is initiated.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a file search call is initiated.", "identifier": "ResponseFileSearchCallInProgressEvent" })
export type ResponseFileSearchCallSearchingEvent = { readonly "type": "response.file_search_call.searching", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseFileSearchCallSearchingEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.file_search_call.searching").annotate({ "description": "The type of the event. Always \`response.file_search_call.searching\`.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the file search call is searching.\\n" }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The ID of the output item that the file search call is initiated.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a file search is currently searching.", "identifier": "ResponseFileSearchCallSearchingEvent" })
export type ResponseFormatJsonObject = { readonly "type": "json_object", readonly [x: string]: unknown }
export const ResponseFormatJsonObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("json_object").annotate({ "description": "The type of response format being defined. Always \`json_object\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "JSON object", "description": "JSON object response format. An older method of generating JSON responses.\\nUsing \`json_schema\` is recommended for models that support it. Note that the\\nmodel will not generate JSON without a system or user message instructing it\\nto do so.\\n", "identifier": "ResponseFormatJsonObject" })
export type ResponseFormatJsonSchemaSchema = { readonly [x: string]: unknown }
export const ResponseFormatJsonSchemaSchema = Schema.Record(Schema.String, Schema.Unknown).annotate({ "title": "JSON schema", "description": "The schema for the response format, described as a JSON Schema object.\\nLearn how to build JSON schemas [here](https://json-schema.org/).\\n", "identifier": "ResponseFormatJsonSchemaSchema" })
export type ResponseFormatText = { readonly "type": "text", readonly [x: string]: unknown }
export const ResponseFormatText = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("text").annotate({ "description": "The type of response format being defined. Always \`text\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Text", "description": "Default response format. Used to generate text responses.\\n", "identifier": "ResponseFormatText" })
export type ResponseFormatTextGrammar = { readonly "type": "grammar", readonly "grammar": string, readonly [x: string]: unknown }
export const ResponseFormatTextGrammar = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("grammar").annotate({ "description": "The type of response format being defined. Always \`grammar\`." }), "grammar": Schema.String.annotate({ "description": "The custom grammar for the model to follow." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Text grammar", "description": "A custom grammar for the model to follow when generating text.\\nLearn more in the [custom grammars guide](https://platform.openai.com/docs/guides/custom-grammars).\\n", "identifier": "ResponseFormatTextGrammar" })
export type ResponseFormatTextPython = { readonly "type": "python", readonly [x: string]: unknown }
export const ResponseFormatTextPython = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("python").annotate({ "description": "The type of response format being defined. Always \`python\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Python grammar", "description": "Configure the model to generate valid Python code. See the\\n[custom grammars guide](https://platform.openai.com/docs/guides/custom-grammars) for more details.\\n", "identifier": "ResponseFormatTextPython" })
export type ResponseFunctionCallArgumentsDeltaEvent = { readonly "type": "response.function_call_arguments.delta", readonly "item_id": string, readonly "output_index": number, readonly "sequence_number": number, readonly "delta": string, readonly [x: string]: unknown }
export const ResponseFunctionCallArgumentsDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.function_call_arguments.delta").annotate({ "description": "The type of the event. Always \`response.function_call_arguments.delta\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the output item that the function-call arguments delta is added to.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the function-call arguments delta is added to.\\n" }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The function-call arguments delta that is added.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when there is a partial function-call arguments delta.", "identifier": "ResponseFunctionCallArgumentsDeltaEvent" })
export type ResponseFunctionCallArgumentsDoneEvent = { readonly "type": "response.function_call_arguments.done", readonly "item_id": string, readonly "name": string, readonly "output_index": number, readonly "sequence_number": number, readonly "arguments": string, readonly [x: string]: unknown }
export const ResponseFunctionCallArgumentsDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.function_call_arguments.done"), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "name": Schema.String.annotate({ "description": "The name of the function that was called." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item." }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "arguments": Schema.String.annotate({ "description": "The function-call arguments." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when function-call arguments are finalized.", "identifier": "ResponseFunctionCallArgumentsDoneEvent" })
export type ResponseImageGenCallCompletedEvent = { readonly "type": "response.image_generation_call.completed", readonly "output_index": number, readonly "sequence_number": number, readonly "item_id": string, readonly [x: string]: unknown }
export const ResponseImageGenCallCompletedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.image_generation_call.completed").annotate({ "description": "The type of the event. Always 'response.image_generation_call.completed'." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response's output array." }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the image generation item being processed." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseImageGenCallCompletedEvent", "description": "Emitted when an image generation tool call has completed and the final image is available.\\n", "identifier": "ResponseImageGenCallCompletedEvent" })
export type ResponseImageGenCallGeneratingEvent = { readonly "type": "response.image_generation_call.generating", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseImageGenCallGeneratingEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.image_generation_call.generating").annotate({ "description": "The type of the event. Always 'response.image_generation_call.generating'." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response's output array." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the image generation item being processed." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of the image generation item being processed." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseImageGenCallGeneratingEvent", "description": "Emitted when an image generation tool call is actively generating an image (intermediate state).\\n", "identifier": "ResponseImageGenCallGeneratingEvent" })
export type ResponseImageGenCallInProgressEvent = { readonly "type": "response.image_generation_call.in_progress", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseImageGenCallInProgressEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.image_generation_call.in_progress").annotate({ "description": "The type of the event. Always 'response.image_generation_call.in_progress'." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response's output array." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the image generation item being processed." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of the image generation item being processed." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseImageGenCallInProgressEvent", "description": "Emitted when an image generation tool call is in progress.\\n", "identifier": "ResponseImageGenCallInProgressEvent" })
export type ResponseImageGenCallPartialImageEvent = { readonly "type": "response.image_generation_call.partial_image", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly "partial_image_index": number, readonly "partial_image_b64": string, readonly [x: string]: unknown }
export const ResponseImageGenCallPartialImageEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.image_generation_call.partial_image").annotate({ "description": "The type of the event. Always 'response.image_generation_call.partial_image'." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response's output array." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the image generation item being processed." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of the image generation item being processed." }).check(Schema.isInt()), "partial_image_index": Schema.Number.annotate({ "description": "0-based index for the partial image (backend is 1-based, but this is 0-based for the user)." }).check(Schema.isInt()), "partial_image_b64": Schema.String.annotate({ "description": "Base64-encoded partial image data, suitable for rendering as an image." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseImageGenCallPartialImageEvent", "description": "Emitted when a partial image is available during image generation streaming.\\n", "identifier": "ResponseImageGenCallPartialImageEvent" })
export type ResponseLogProb = { readonly "token": string, readonly "logprob": number, readonly "top_logprobs"?: ReadonlyArray<{ readonly "token"?: string, readonly "logprob"?: number, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const ResponseLogProb = Schema.StructWithRest(Schema.Struct({ "token": Schema.String.annotate({ "description": "A possible text token." }), "logprob": Schema.Number.annotate({ "description": "The log probability of this token.\\n" }).check(Schema.isFinite()), "top_logprobs": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "token": Schema.optionalKey(Schema.String.annotate({ "description": "A possible text token." })), "logprob": Schema.optionalKey(Schema.Number.annotate({ "description": "The log probability of this token." }).check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The log probability of the top 20 most likely tokens.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A logprob is the logarithmic probability that the model assigns to producing \\na particular token at a given position in the sequence. Less-negative (higher) \\nlogprob values indicate greater model confidence in that token choice.\\n", "identifier": "ResponseLogProb" })
export type ResponseMCPCallArgumentsDeltaEvent = { readonly "type": "response.mcp_call_arguments.delta", readonly "output_index": number, readonly "item_id": string, readonly "delta": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseMCPCallArgumentsDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.mcp_call_arguments.delta").annotate({ "description": "The type of the event. Always 'response.mcp_call_arguments.delta'." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response's output array." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the MCP tool call item being processed." }), "delta": Schema.String.annotate({ "description": "A JSON string containing the partial update to the arguments for the MCP tool call.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseMCPCallArgumentsDeltaEvent", "description": "Emitted when there is a delta (partial update) to the arguments of an MCP tool call.\\n", "identifier": "ResponseMCPCallArgumentsDeltaEvent" })
export type ResponseMCPCallArgumentsDoneEvent = { readonly "type": "response.mcp_call_arguments.done", readonly "output_index": number, readonly "item_id": string, readonly "arguments": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseMCPCallArgumentsDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.mcp_call_arguments.done").annotate({ "description": "The type of the event. Always 'response.mcp_call_arguments.done'." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response's output array." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the MCP tool call item being processed." }), "arguments": Schema.String.annotate({ "description": "A JSON string containing the finalized arguments for the MCP tool call.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseMCPCallArgumentsDoneEvent", "description": "Emitted when the arguments for an MCP tool call are finalized.\\n", "identifier": "ResponseMCPCallArgumentsDoneEvent" })
export type ResponseMCPCallCompletedEvent = { readonly "type": "response.mcp_call.completed", readonly "item_id": string, readonly "output_index": number, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseMCPCallCompletedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.mcp_call.completed").annotate({ "description": "The type of the event. Always 'response.mcp_call.completed'." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item that completed." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that completed." }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseMCPCallCompletedEvent", "description": "Emitted when an MCP  tool call has completed successfully.\\n", "identifier": "ResponseMCPCallCompletedEvent" })
export type ResponseMCPCallFailedEvent = { readonly "type": "response.mcp_call.failed", readonly "item_id": string, readonly "output_index": number, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseMCPCallFailedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.mcp_call.failed").annotate({ "description": "The type of the event. Always 'response.mcp_call.failed'." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item that failed." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that failed." }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseMCPCallFailedEvent", "description": "Emitted when an MCP  tool call has failed.\\n", "identifier": "ResponseMCPCallFailedEvent" })
export type ResponseMCPCallInProgressEvent = { readonly "type": "response.mcp_call.in_progress", readonly "sequence_number": number, readonly "output_index": number, readonly "item_id": string, readonly [x: string]: unknown }
export const ResponseMCPCallInProgressEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.mcp_call.in_progress").annotate({ "description": "The type of the event. Always 'response.mcp_call.in_progress'." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response's output array." }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "The unique identifier of the MCP tool call item being processed." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseMCPCallInProgressEvent", "description": "Emitted when an MCP  tool call is in progress.\\n", "identifier": "ResponseMCPCallInProgressEvent" })
export type ResponseMCPListToolsCompletedEvent = { readonly "type": "response.mcp_list_tools.completed", readonly "item_id": string, readonly "output_index": number, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseMCPListToolsCompletedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.mcp_list_tools.completed").annotate({ "description": "The type of the event. Always 'response.mcp_list_tools.completed'." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item that produced this output." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that was processed." }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseMCPListToolsCompletedEvent", "description": "Emitted when the list of available MCP tools has been successfully retrieved.\\n", "identifier": "ResponseMCPListToolsCompletedEvent" })
export type ResponseMCPListToolsFailedEvent = { readonly "type": "response.mcp_list_tools.failed", readonly "item_id": string, readonly "output_index": number, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseMCPListToolsFailedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.mcp_list_tools.failed").annotate({ "description": "The type of the event. Always 'response.mcp_list_tools.failed'." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item that failed." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that failed." }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseMCPListToolsFailedEvent", "description": "Emitted when the attempt to list available MCP tools has failed.\\n", "identifier": "ResponseMCPListToolsFailedEvent" })
export type ResponseMCPListToolsInProgressEvent = { readonly "type": "response.mcp_list_tools.in_progress", readonly "item_id": string, readonly "output_index": number, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseMCPListToolsInProgressEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.mcp_list_tools.in_progress").annotate({ "description": "The type of the event. Always 'response.mcp_list_tools.in_progress'." }), "item_id": Schema.String.annotate({ "description": "The ID of the MCP tool call item that is being processed." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that is being processed." }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseMCPListToolsInProgressEvent", "description": "Emitted when the system is in the process of retrieving the list of available MCP tools.\\n", "identifier": "ResponseMCPListToolsInProgressEvent" })
export type ResponseModalities = ReadonlyArray<"text" | "audio"> | null
export const ResponseModalities = Schema.Union([Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "Output types that you would like the model to generate.\\nMost models are capable of generating text, which is the default:\\n\\n\`[\\"text\\"]\`\\n\\nThe \`gpt-4o-audio-preview\` model can also be used to\\n[generate audio](https://platform.openai.com/docs/guides/audio). To request that this model generate\\nboth text and audio responses, you can use:\\n\\n\`[\\"text\\", \\"audio\\"]\`\\n" }), Schema.Null]).annotate({ "identifier": "ResponseModalities" })
export type ResponseOutputTextAnnotationAddedEvent = { readonly "type": "response.output_text.annotation.added", readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "annotation_index": number, readonly "sequence_number": number, readonly "annotation": { readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ResponseOutputTextAnnotationAddedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.output_text.annotation.added").annotate({ "description": "The type of the event. Always 'response.output_text.annotation.added'." }), "item_id": Schema.String.annotate({ "description": "The unique identifier of the item to which the annotation is being added." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the response's output array." }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part within the output item." }).check(Schema.isInt()), "annotation_index": Schema.Number.annotate({ "description": "The index of the annotation within the content part." }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "annotation": Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The annotation object being added. (See annotation schema for details.)" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseOutputTextAnnotationAddedEvent", "description": "Emitted when an annotation is added to output text content.\\n", "identifier": "ResponseOutputTextAnnotationAddedEvent" })
export type ResponseReasoningSummaryPartAddedEvent = { readonly "type": "response.reasoning_summary_part.added", readonly "item_id": string, readonly "output_index": number, readonly "summary_index": number, readonly "sequence_number": number, readonly "part": { readonly "type": "summary_text", readonly "text": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ResponseReasoningSummaryPartAddedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.reasoning_summary_part.added").annotate({ "description": "The type of the event. Always \`response.reasoning_summary_part.added\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the item this summary part is associated with.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item this summary part is associated with.\\n" }).check(Schema.isInt()), "summary_index": Schema.Number.annotate({ "description": "The index of the summary part within the reasoning summary.\\n" }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\\n" }).check(Schema.isInt()), "part": Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("summary_text").annotate({ "description": "The type of the summary part. Always \`summary_text\`." }), "text": Schema.String.annotate({ "description": "The text of the summary part." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The summary part that was added.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a new reasoning summary part is added.", "identifier": "ResponseReasoningSummaryPartAddedEvent" })
export type ResponseReasoningSummaryPartDoneEvent = { readonly "type": "response.reasoning_summary_part.done", readonly "item_id": string, readonly "output_index": number, readonly "summary_index": number, readonly "sequence_number": number, readonly "part": { readonly "type": "summary_text", readonly "text": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ResponseReasoningSummaryPartDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.reasoning_summary_part.done").annotate({ "description": "The type of the event. Always \`response.reasoning_summary_part.done\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the item this summary part is associated with.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item this summary part is associated with.\\n" }).check(Schema.isInt()), "summary_index": Schema.Number.annotate({ "description": "The index of the summary part within the reasoning summary.\\n" }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\\n" }).check(Schema.isInt()), "part": Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("summary_text").annotate({ "description": "The type of the summary part. Always \`summary_text\`." }), "text": Schema.String.annotate({ "description": "The text of the summary part." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The completed summary part.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a reasoning summary part is completed.", "identifier": "ResponseReasoningSummaryPartDoneEvent" })
export type ResponseReasoningSummaryTextDeltaEvent = { readonly "type": "response.reasoning_summary_text.delta", readonly "item_id": string, readonly "output_index": number, readonly "summary_index": number, readonly "delta": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseReasoningSummaryTextDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.reasoning_summary_text.delta").annotate({ "description": "The type of the event. Always \`response.reasoning_summary_text.delta\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the item this summary text delta is associated with.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item this summary text delta is associated with.\\n" }).check(Schema.isInt()), "summary_index": Schema.Number.annotate({ "description": "The index of the summary part within the reasoning summary.\\n" }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The text delta that was added to the summary.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a delta is added to a reasoning summary text.", "identifier": "ResponseReasoningSummaryTextDeltaEvent" })
export type ResponseReasoningSummaryTextDoneEvent = { readonly "type": "response.reasoning_summary_text.done", readonly "item_id": string, readonly "output_index": number, readonly "summary_index": number, readonly "text": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseReasoningSummaryTextDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.reasoning_summary_text.done").annotate({ "description": "The type of the event. Always \`response.reasoning_summary_text.done\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the item this summary text is associated with.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item this summary text is associated with.\\n" }).check(Schema.isInt()), "summary_index": Schema.Number.annotate({ "description": "The index of the summary part within the reasoning summary.\\n" }).check(Schema.isInt()), "text": Schema.String.annotate({ "description": "The full text of the completed reasoning summary.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a reasoning summary text is completed.", "identifier": "ResponseReasoningSummaryTextDoneEvent" })
export type ResponseReasoningTextDeltaEvent = { readonly "type": "response.reasoning_text.delta", readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "delta": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseReasoningTextDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.reasoning_text.delta").annotate({ "description": "The type of the event. Always \`response.reasoning_text.delta\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the item this reasoning text delta is associated with.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item this reasoning text delta is associated with.\\n" }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the reasoning content part this delta is associated with.\\n" }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The text delta that was added to the reasoning content.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a delta is added to a reasoning text.", "identifier": "ResponseReasoningTextDeltaEvent" })
export type ResponseReasoningTextDoneEvent = { readonly "type": "response.reasoning_text.done", readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "text": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseReasoningTextDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.reasoning_text.done").annotate({ "description": "The type of the event. Always \`response.reasoning_text.done\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the item this reasoning text is associated with.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item this reasoning text is associated with.\\n" }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the reasoning content part.\\n" }).check(Schema.isInt()), "text": Schema.String.annotate({ "description": "The full text of the completed reasoning content.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a reasoning text is completed.", "identifier": "ResponseReasoningTextDoneEvent" })
export type ResponseRefusalDeltaEvent = { readonly "type": "response.refusal.delta", readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "delta": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseRefusalDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.refusal.delta").annotate({ "description": "The type of the event. Always \`response.refusal.delta\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the output item that the refusal text is added to.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the refusal text is added to.\\n" }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part that the refusal text is added to.\\n" }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The refusal text that is added.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when there is a partial refusal text.", "identifier": "ResponseRefusalDeltaEvent" })
export type ResponseRefusalDoneEvent = { readonly "type": "response.refusal.done", readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "refusal": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseRefusalDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.refusal.done").annotate({ "description": "The type of the event. Always \`response.refusal.done\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the output item that the refusal text is finalized.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the refusal text is finalized.\\n" }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part that the refusal text is finalized.\\n" }).check(Schema.isInt()), "refusal": Schema.String.annotate({ "description": "The refusal text that is finalized.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when refusal text is finalized.", "identifier": "ResponseRefusalDoneEvent" })
export type ResponseStreamOptions = { readonly "include_obfuscation"?: boolean, readonly [x: string]: unknown } | null
export const ResponseStreamOptions = Schema.Union([Schema.StructWithRest(Schema.Struct({ "include_obfuscation": Schema.optionalKey(Schema.Boolean.annotate({ "description": "When true, stream obfuscation will be enabled. Stream obfuscation adds\\nrandom characters to an \`obfuscation\` field on streaming delta events to\\nnormalize payload sizes as a mitigation to certain side-channel attacks.\\nThese obfuscation fields are included by default, but add a small amount\\nof overhead to the data stream. You can set \`include_obfuscation\` to\\nfalse to optimize for bandwidth if you trust the network links between\\nyour application and the OpenAI API.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Options for streaming responses. Only set this when you set \`stream: true\`.\\n" }), Schema.Null]).annotate({ "identifier": "ResponseStreamOptions" })
export type ResponseUsage = { readonly "input_tokens": number, readonly "input_tokens_details": { readonly "cached_tokens": number, readonly [x: string]: unknown }, readonly "output_tokens": number, readonly "output_tokens_details": { readonly "reasoning_tokens": number, readonly [x: string]: unknown }, readonly "total_tokens": number, readonly [x: string]: unknown }
export const ResponseUsage = Schema.StructWithRest(Schema.Struct({ "input_tokens": Schema.Number.annotate({ "description": "The number of input tokens." }).check(Schema.isInt()), "input_tokens_details": Schema.StructWithRest(Schema.Struct({ "cached_tokens": Schema.Number.annotate({ "description": "The number of tokens that were retrieved from the cache. \\n[More on prompt caching](https://platform.openai.com/docs/guides/prompt-caching).\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A detailed breakdown of the input tokens." }), "output_tokens": Schema.Number.annotate({ "description": "The number of output tokens." }).check(Schema.isInt()), "output_tokens_details": Schema.StructWithRest(Schema.Struct({ "reasoning_tokens": Schema.Number.annotate({ "description": "The number of reasoning tokens." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A detailed breakdown of the output tokens." }), "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents token usage details including input tokens, output tokens,\\na breakdown of output tokens, and the total tokens used.\\n", "identifier": "ResponseUsage" })
export type ResponseWebSearchCallCompletedEvent = { readonly "type": "response.web_search_call.completed", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseWebSearchCallCompletedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.web_search_call.completed").annotate({ "description": "The type of the event. Always \`response.web_search_call.completed\`.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the web search call is associated with.\\n" }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "Unique ID for the output item associated with the web search call.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of the web search call being processed." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a web search call is completed.", "identifier": "ResponseWebSearchCallCompletedEvent" })
export type ResponseWebSearchCallInProgressEvent = { readonly "type": "response.web_search_call.in_progress", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseWebSearchCallInProgressEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.web_search_call.in_progress").annotate({ "description": "The type of the event. Always \`response.web_search_call.in_progress\`.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the web search call is associated with.\\n" }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "Unique ID for the output item associated with the web search call.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of the web search call being processed." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a web search call is initiated.", "identifier": "ResponseWebSearchCallInProgressEvent" })
export type ResponseWebSearchCallSearchingEvent = { readonly "type": "response.web_search_call.searching", readonly "output_index": number, readonly "item_id": string, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseWebSearchCallSearchingEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.web_search_call.searching").annotate({ "description": "The type of the event. Always \`response.web_search_call.searching\`.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the web search call is associated with.\\n" }).check(Schema.isInt()), "item_id": Schema.String.annotate({ "description": "Unique ID for the output item associated with the web search call.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of the web search call being processed." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a web search call is executing.", "identifier": "ResponseWebSearchCallSearchingEvent" })
export type Role = { readonly "object": "role", readonly "id": string, readonly "name": string, readonly "description": string | null, readonly "permissions": ReadonlyArray<string>, readonly "resource_type": string, readonly "predefined_role": boolean, readonly [x: string]: unknown }
export const Role = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("role").annotate({ "description": "Always \`role\`." }), "id": Schema.String.annotate({ "description": "Identifier for the role." }), "name": Schema.String.annotate({ "description": "Unique name for the role." }), "description": Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Optional description of the role." }), "permissions": Schema.Array(Schema.String).annotate({ "description": "Permissions granted by the role." }), "resource_type": Schema.String.annotate({ "description": "Resource type the role is bound to (for example \`api.organization\` or \`api.project\`)." }), "predefined_role": Schema.Boolean.annotate({ "description": "Whether the role is predefined and managed by OpenAI." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details about a role that can be assigned through the public Roles API.", "identifier": "Role" })
export type RoleDeletedResource = { readonly "object": "role.deleted", readonly "id": string, readonly "deleted": boolean, readonly [x: string]: unknown }
export const RoleDeletedResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("role.deleted").annotate({ "description": "Always \`role.deleted\`." }), "id": Schema.String.annotate({ "description": "Identifier of the deleted role." }), "deleted": Schema.Boolean.annotate({ "description": "Whether the role was deleted." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Confirmation payload returned after deleting a role.", "identifier": "RoleDeletedResource" })
export type RunCompletionUsage = { readonly "completion_tokens": number, readonly "prompt_tokens": number, readonly "total_tokens": number, readonly [x: string]: unknown } | null
export const RunCompletionUsage = Schema.Union([Schema.StructWithRest(Schema.Struct({ "completion_tokens": Schema.Number.annotate({ "description": "Number of completion tokens used over the course of the run." }).check(Schema.isInt()), "prompt_tokens": Schema.Number.annotate({ "description": "Number of prompt tokens used over the course of the run." }).check(Schema.isInt()), "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (prompt + completion)." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Usage statistics related to the run. This value will be \`null\` if the run is not in a terminal state (i.e. \`in_progress\`, \`queued\`, etc.)." }), Schema.Null]).annotate({ "identifier": "RunCompletionUsage" })
export type RunGraderResponse = { readonly "reward": number, readonly "metadata": { readonly "name": string, readonly "type": string, readonly "errors": { readonly "formula_parse_error": boolean, readonly "sample_parse_error": boolean, readonly "truncated_observation_error": boolean, readonly "unresponsive_reward_error": boolean, readonly "invalid_variable_error": boolean, readonly "other_error": boolean, readonly "python_grader_server_error": boolean, readonly "python_grader_server_error_type": string | null, readonly "python_grader_runtime_error": boolean, readonly "python_grader_runtime_error_details": string | null, readonly "model_grader_server_error": boolean, readonly "model_grader_refusal_error": boolean, readonly "model_grader_parse_error": boolean, readonly "model_grader_server_error_details": string | null, readonly [x: string]: unknown }, readonly "execution_time": number, readonly "scores": { readonly [x: string]: unknown }, readonly "token_usage": number | null, readonly "sampled_model_name": string | null, readonly [x: string]: unknown }, readonly "sub_rewards": { readonly [x: string]: unknown }, readonly "model_grader_token_usage_per_model": { readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunGraderResponse = Schema.StructWithRest(Schema.Struct({ "reward": Schema.Number.check(Schema.isFinite()), "metadata": Schema.StructWithRest(Schema.Struct({ "name": Schema.String, "type": Schema.String, "errors": Schema.StructWithRest(Schema.Struct({ "formula_parse_error": Schema.Boolean, "sample_parse_error": Schema.Boolean, "truncated_observation_error": Schema.Boolean, "unresponsive_reward_error": Schema.Boolean, "invalid_variable_error": Schema.Boolean, "other_error": Schema.Boolean, "python_grader_server_error": Schema.Boolean, "python_grader_server_error_type": Schema.Union([Schema.String, Schema.Null]), "python_grader_runtime_error": Schema.Boolean, "python_grader_runtime_error_details": Schema.Union([Schema.String, Schema.Null]), "model_grader_server_error": Schema.Boolean, "model_grader_refusal_error": Schema.Boolean, "model_grader_parse_error": Schema.Boolean, "model_grader_server_error_details": Schema.Union([Schema.String, Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]), "execution_time": Schema.Number.check(Schema.isFinite()), "scores": Schema.Record(Schema.String, Schema.Unknown), "token_usage": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]), "sampled_model_name": Schema.Union([Schema.String, Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]), "sub_rewards": Schema.Record(Schema.String, Schema.Unknown), "model_grader_token_usage_per_model": Schema.Record(Schema.String, Schema.Unknown) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "RunGraderResponse" })
export type RunStepCompletionUsage = { readonly "completion_tokens": number, readonly "prompt_tokens": number, readonly "total_tokens": number, readonly [x: string]: unknown } | null
export const RunStepCompletionUsage = Schema.Union([Schema.StructWithRest(Schema.Struct({ "completion_tokens": Schema.Number.annotate({ "description": "Number of completion tokens used over the course of the run step." }).check(Schema.isInt()), "prompt_tokens": Schema.Number.annotate({ "description": "Number of prompt tokens used over the course of the run step." }).check(Schema.isInt()), "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (prompt + completion)." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Usage statistics related to the run step. This value will be \`null\` while the run step's status is \`in_progress\`." }), Schema.Null]).annotate({ "identifier": "RunStepCompletionUsage" })
export type RunStepDeltaStepDetailsMessageCreationObject = { readonly "type": "message_creation", readonly "message_creation"?: { readonly "message_id"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunStepDeltaStepDetailsMessageCreationObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("message_creation").annotate({ "description": "Always \`message_creation\`." }), "message_creation": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "message_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the message that was created by this run step." })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Message creation", "description": "Details of the message creation by the run step.", "identifier": "RunStepDeltaStepDetailsMessageCreationObject" })
export type RunStepDeltaStepDetailsToolCallsCodeOutputImageObject = { readonly "index": number, readonly "type": "image", readonly "image"?: { readonly "file_id"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunStepDeltaStepDetailsToolCallsCodeOutputImageObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the output in the outputs array." }).check(Schema.isInt()), "type": Schema.Literal("image").annotate({ "description": "Always \`image\`." }), "image": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The [file](https://platform.openai.com/docs/api-reference/files) ID of the image." })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code interpreter image output", "identifier": "RunStepDeltaStepDetailsToolCallsCodeOutputImageObject" })
export type RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject = { readonly "index": number, readonly "type": "logs", readonly "logs"?: string, readonly [x: string]: unknown }
export const RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the output in the outputs array." }).check(Schema.isInt()), "type": Schema.Literal("logs").annotate({ "description": "Always \`logs\`." }), "logs": Schema.optionalKey(Schema.String.annotate({ "description": "The text output from the Code Interpreter tool call." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code interpreter log output", "description": "Text output from the Code Interpreter tool call as part of a run step.", "identifier": "RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject" })
export type RunStepDeltaStepDetailsToolCallsFileSearchObject = { readonly "index": number, readonly "id"?: string, readonly "type": "file_search", readonly "file_search": { readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunStepDeltaStepDetailsToolCallsFileSearchObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the tool call in the tool calls array." }).check(Schema.isInt()), "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the tool call object." })), "type": Schema.Literal("file_search").annotate({ "description": "The type of tool call. This is always going to be \`file_search\` for this type of tool call." }), "file_search": Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "For now, this is always going to be an empty object." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File search tool call", "identifier": "RunStepDeltaStepDetailsToolCallsFileSearchObject" })
export type RunStepDeltaStepDetailsToolCallsFunctionObject = { readonly "index": number, readonly "id"?: string, readonly "type": "function", readonly "function"?: { readonly "name"?: string, readonly "arguments"?: string, readonly "output"?: string | null, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunStepDeltaStepDetailsToolCallsFunctionObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the tool call in the tool calls array." }).check(Schema.isInt()), "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the tool call object." })), "type": Schema.Literal("function").annotate({ "description": "The type of tool call. This is always going to be \`function\` for this type of tool call." }), "function": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function." })), "arguments": Schema.optionalKey(Schema.String.annotate({ "description": "The arguments passed to the function." })), "output": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The output of the function. This will be \`null\` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The definition of the function that was called." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool call", "identifier": "RunStepDeltaStepDetailsToolCallsFunctionObject" })
export type RunStepDetailsMessageCreationObject = { readonly "type": "message_creation", readonly "message_creation": { readonly "message_id": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunStepDetailsMessageCreationObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("message_creation").annotate({ "description": "Always \`message_creation\`." }), "message_creation": Schema.StructWithRest(Schema.Struct({ "message_id": Schema.String.annotate({ "description": "The ID of the message that was created by this run step." }) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Message creation", "description": "Details of the message creation by the run step.", "identifier": "RunStepDetailsMessageCreationObject" })
export type RunStepDetailsToolCallsCodeOutputImageObject = { readonly "type": "image", readonly "image": { readonly "file_id": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunStepDetailsToolCallsCodeOutputImageObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image").annotate({ "description": "Always \`image\`." }), "image": Schema.StructWithRest(Schema.Struct({ "file_id": Schema.String.annotate({ "description": "The [file](https://platform.openai.com/docs/api-reference/files) ID of the image." }) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code Interpreter image output", "identifier": "RunStepDetailsToolCallsCodeOutputImageObject" })
export type RunStepDetailsToolCallsCodeOutputLogsObject = { readonly "type": "logs", readonly "logs": string, readonly [x: string]: unknown }
export const RunStepDetailsToolCallsCodeOutputLogsObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("logs").annotate({ "description": "Always \`logs\`." }), "logs": Schema.String.annotate({ "description": "The text output from the Code Interpreter tool call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code Interpreter log output", "description": "Text output from the Code Interpreter tool call as part of a run step.", "identifier": "RunStepDetailsToolCallsCodeOutputLogsObject" })
export type RunStepDetailsToolCallsFileSearchResultObject = { readonly "file_id": string, readonly "file_name": string, readonly "score": number, readonly "content"?: ReadonlyArray<{ readonly "type"?: "text", readonly "text"?: string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const RunStepDetailsToolCallsFileSearchResultObject = Schema.StructWithRest(Schema.Struct({ "file_id": Schema.String.annotate({ "description": "The ID of the file that result was found in." }), "file_name": Schema.String.annotate({ "description": "The name of the file that result was found in." }), "score": Schema.Number.annotate({ "description": "The score of the result. All values must be a floating point number between 0 and 1." }).check(Schema.isFinite()), "content": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("text").annotate({ "description": "The type of the content." })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content of the file." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The content of the result that was found. The content is only included if requested via the include query parameter." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File search tool call result", "description": "A result instance of the file search.", "identifier": "RunStepDetailsToolCallsFileSearchResultObject" })
export type RunStepDetailsToolCallsFunctionObject = { readonly "id": string, readonly "type": "function", readonly "function": { readonly "name": string, readonly "arguments": string, readonly "output": string | null, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunStepDetailsToolCallsFunctionObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The ID of the tool call object." }), "type": Schema.Literal("function").annotate({ "description": "The type of tool call. This is always going to be \`function\` for this type of tool call." }), "function": Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function." }), "arguments": Schema.String.annotate({ "description": "The arguments passed to the function." }), "output": Schema.Union([Schema.String.annotate({ "description": "The output of the function. This will be \`null\` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The definition of the function that was called." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool call", "identifier": "RunStepDetailsToolCallsFunctionObject" })
export type RunToolCallObject = { readonly "id": string, readonly "type": "function", readonly "function": { readonly "name": string, readonly "arguments": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunToolCallObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint." }), "type": Schema.Literal("function").annotate({ "description": "The type of tool call the output is required for. For now, this is always \`function\`." }), "function": Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "The name of the function." }), "arguments": Schema.String.annotate({ "description": "The arguments that the model expects you to pass to the function." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The function definition." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Tool call objects", "identifier": "RunToolCallObject" })
export type Screenshot = { readonly "type": "screenshot", readonly [x: string]: unknown }
export const Screenshot = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("screenshot").annotate({ "description": "Specifies the event type. For a screenshot action, this property is \\nalways set to \`screenshot\`.\\n", "default": "screenshot" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Screenshot", "description": "A screenshot action.\\n", "identifier": "Screenshot" })
export type Scroll = { readonly "type": "scroll", readonly "x": number, readonly "y": number, readonly "scroll_x": number, readonly "scroll_y": number, readonly [x: string]: unknown }
export const Scroll = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("scroll").annotate({ "description": "Specifies the event type. For a scroll action, this property is \\nalways set to \`scroll\`.\\n", "default": "scroll" }), "x": Schema.Number.annotate({ "description": "The x-coordinate where the scroll occurred.\\n" }).check(Schema.isInt()), "y": Schema.Number.annotate({ "description": "The y-coordinate where the scroll occurred.\\n" }).check(Schema.isInt()), "scroll_x": Schema.Number.annotate({ "description": "The horizontal scroll distance.\\n" }).check(Schema.isInt()), "scroll_y": Schema.Number.annotate({ "description": "The vertical scroll distance.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Scroll", "description": "A scroll action.\\n", "identifier": "Scroll" })
export type ServiceTier = "auto" | "default" | "flex" | "scale" | "priority" | null
export const ServiceTier = Schema.Union([Schema.Literals(["auto", "default", "flex", "scale", "priority"]).annotate({ "description": "Specifies the processing type used for serving the request.\\n  - If set to 'auto', then the request will be processed with the service tier configured in the Project settings. Unless otherwise configured, the Project will use 'default'.\\n  - If set to 'default', then the request will be processed with the standard pricing and performance for the selected model.\\n  - If set to '[flex](https://platform.openai.com/docs/guides/flex-processing)' or '[priority](https://openai.com/api-priority-processing/)', then the request will be processed with the corresponding service tier.\\n  - When not set, the default behavior is 'auto'.\\n\\n  When the \`service_tier\` parameter is set, the response body will include the \`service_tier\` value based on the processing mode actually used to serve the request. This response value may be different from the value set in the parameter.\\n", "default": "auto" }), Schema.Null]).annotate({ "identifier": "ServiceTier" })
export type SpeechAudioDeltaEvent = { readonly "type": "speech.audio.delta", readonly "audio": string, readonly [x: string]: unknown }
export const SpeechAudioDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("speech.audio.delta").annotate({ "description": "The type of the event. Always \`speech.audio.delta\`.\\n" }), "audio": Schema.String.annotate({ "description": "A chunk of Base64-encoded audio data.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted for each chunk of audio data generated during speech synthesis.", "identifier": "SpeechAudioDeltaEvent" })
export type SpeechAudioDoneEvent = { readonly "type": "speech.audio.done", readonly "usage": { readonly "input_tokens": number, readonly "output_tokens": number, readonly "total_tokens": number, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const SpeechAudioDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("speech.audio.done").annotate({ "description": "The type of the event. Always \`speech.audio.done\`.\\n" }), "usage": Schema.StructWithRest(Schema.Struct({ "input_tokens": Schema.Number.annotate({ "description": "Number of input tokens in the prompt." }).check(Schema.isInt()), "output_tokens": Schema.Number.annotate({ "description": "Number of output tokens generated." }).check(Schema.isInt()), "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (input + output)." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Token usage statistics for the request.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when the speech synthesis is complete and all audio has been streamed.", "identifier": "SpeechAudioDoneEvent" })
export type StaticChunkingStrategy = { readonly "max_chunk_size_tokens": number, readonly "chunk_overlap_tokens": number }
export const StaticChunkingStrategy = Schema.Struct({ "max_chunk_size_tokens": Schema.Number.annotate({ "description": "The maximum number of tokens in each chunk. The default value is \`800\`. The minimum value is \`100\` and the maximum value is \`4096\`." }).check(Schema.isInt()), "chunk_overlap_tokens": Schema.Number.annotate({ "description": "The number of tokens that overlap between chunks. The default value is \`400\`.\\n\\nNote that the overlap must not exceed half of \`max_chunk_size_tokens\`.\\n" }).check(Schema.isInt()) }).annotate({ "identifier": "StaticChunkingStrategy" })
export type StopConfiguration = string | null | ReadonlyArray<string> | null
export const StopConfiguration = Schema.Union([Schema.Union([Schema.Union([Schema.String, Schema.Null]).annotate({ "default": "<|endoftext|>" }), Schema.Array(Schema.String)]).annotate({ "description": "Not supported with latest reasoning models \`o3\` and \`o4-mini\`.\\n\\nUp to 4 sequences where the API will stop generating further tokens. The\\nreturned text will not contain the stop sequence.\\n" }), Schema.Null]).annotate({ "identifier": "StopConfiguration" })
export type SubmitToolOutputsRunRequest = { readonly "tool_outputs": ReadonlyArray<{ readonly "tool_call_id"?: string, readonly "output"?: string, readonly [x: string]: unknown }>, readonly "stream"?: boolean | null }
export const SubmitToolOutputsRunRequest = Schema.Struct({ "tool_outputs": Schema.Array(Schema.StructWithRest(Schema.Struct({ "tool_call_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the tool call in the \`required_action\` object within the run object the output is being submitted for." })), "output": Schema.optionalKey(Schema.String.annotate({ "description": "The output of the tool call to be submitted to continue the run." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "A list of tools for which the outputs are being submitted." }), "stream": Schema.optionalKey(Schema.Union([Schema.Boolean.annotate({ "description": "If \`true\`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a \`data: [DONE]\` message.\\n" }), Schema.Null])) }).annotate({ "identifier": "SubmitToolOutputsRunRequest" })
export type ToggleCertificatesRequest = { readonly "certificate_ids": ReadonlyArray<string>, readonly [x: string]: unknown }
export const ToggleCertificatesRequest = Schema.StructWithRest(Schema.Struct({ "certificate_ids": Schema.Array(Schema.String) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ToggleCertificatesRequest" })
export type ToolChoiceAllowed = { readonly "type": "allowed_tools", readonly "mode": "auto" | "required", readonly "tools": ReadonlyArray<{ readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const ToolChoiceAllowed = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("allowed_tools").annotate({ "description": "Allowed tool configuration type. Always \`allowed_tools\`." }), "mode": Schema.Literals(["auto", "required"]).annotate({ "description": "Constrains the tools available to the model to a pre-defined set.\\n\\n\`auto\` allows the model to pick from among the allowed tools and generate a\\nmessage.\\n\\n\`required\` requires the model to call one or more of the allowed tools.\\n" }), "tools": Schema.Array(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "A tool definition that the model should be allowed to call.\\n" })).annotate({ "description": "A list of tool definitions that the model should be allowed to call.\\n\\nFor the Responses API, the list of tool definitions might look like:\\n\`\`\`json\\n[\\n  { \\"type\\": \\"function\\", \\"name\\": \\"get_weather\\" },\\n  { \\"type\\": \\"mcp\\", \\"server_label\\": \\"deepwiki\\" },\\n  { \\"type\\": \\"image_generation\\" }\\n]\\n\`\`\`\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Allowed tools", "description": "Constrains the tools available to the model to a pre-defined set.\\n", "identifier": "ToolChoiceAllowed" })
export type ToolChoiceCustom = { readonly "type": "custom", readonly "name": string, readonly [x: string]: unknown }
export const ToolChoiceCustom = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("custom").annotate({ "description": "For custom tool calling, the type is always \`custom\`." }), "name": Schema.String.annotate({ "description": "The name of the custom tool to call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Custom tool", "description": "Use this option to force the model to call a specific custom tool.\\n", "identifier": "ToolChoiceCustom" })
export type ToolChoiceFunction = { readonly "type": "function", readonly "name": string, readonly [x: string]: unknown }
export const ToolChoiceFunction = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("function").annotate({ "description": "For function calling, the type is always \`function\`." }), "name": Schema.String.annotate({ "description": "The name of the function to call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool", "description": "Use this option to force the model to call a specific function.\\n", "identifier": "ToolChoiceFunction" })
export type ToolChoiceMCP = { readonly "type": "mcp", readonly "server_label": string, readonly "name"?: string | null, readonly [x: string]: unknown }
export const ToolChoiceMCP = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp").annotate({ "description": "For MCP tools, the type is always \`mcp\`." }), "server_label": Schema.String.annotate({ "description": "The label of the MCP server to use.\\n" }), "name": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The name of the tool to call on the server.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "MCP tool", "description": "Use this option to force the model to call a specific tool on a remote MCP server.\\n", "identifier": "ToolChoiceMCP" })
export type ToolChoiceOptions = "none" | "auto" | "required"
export const ToolChoiceOptions = Schema.Literals(["none", "auto", "required"]).annotate({ "title": "Tool choice mode", "description": "Controls which (if any) tool is called by the model.\\n\\n\`none\` means the model will not call any tool and instead generates a message.\\n\\n\`auto\` means the model can pick between generating a message or calling one or\\nmore tools.\\n\\n\`required\` means the model must call one or more tools.\\n", "identifier": "ToolChoiceOptions" })
export type ToolChoiceTypes = { readonly "type": "file_search" | "web_search_preview" | "computer_use_preview" | "web_search_preview_2025_03_11" | "image_generation" | "code_interpreter", readonly [x: string]: unknown }
export const ToolChoiceTypes = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literals(["file_search", "web_search_preview", "computer_use_preview", "web_search_preview_2025_03_11", "image_generation", "code_interpreter"]).annotate({ "description": "The type of hosted tool the model should to use. Learn more about\\n[built-in tools](https://platform.openai.com/docs/guides/tools).\\n\\nAllowed values are:\\n- \`file_search\`\\n- \`web_search_preview\`\\n- \`computer_use_preview\`\\n- \`code_interpreter\`\\n- \`image_generation\`\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Hosted tool", "description": "Indicates that the model should use a built-in tool to generate a response.\\n[Learn more about built-in tools](https://platform.openai.com/docs/guides/tools).\\n", "identifier": "ToolChoiceTypes" })
export type TranscriptTextDeltaEvent = { readonly "type": "transcript.text.delta", readonly "delta": string, readonly "logprobs"?: ReadonlyArray<{ readonly "token"?: string, readonly "logprob"?: number, readonly "bytes"?: ReadonlyArray<number>, readonly [x: string]: unknown }>, readonly "segment_id"?: string, readonly [x: string]: unknown }
export const TranscriptTextDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("transcript.text.delta").annotate({ "description": "The type of the event. Always \`transcript.text.delta\`.\\n" }), "delta": Schema.String.annotate({ "description": "The text delta that was additionally transcribed.\\n" }), "logprobs": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "token": Schema.optionalKey(Schema.String.annotate({ "description": "The token that was used to generate the log probability.\\n" })), "logprob": Schema.optionalKey(Schema.Number.annotate({ "description": "The log probability of the token.\\n" }).check(Schema.isFinite())), "bytes": Schema.optionalKey(Schema.Array(Schema.Number.check(Schema.isInt())).annotate({ "description": "The bytes that were used to generate the log probability.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The log probabilities of the delta. Only included if you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the \`include[]\` parameter set to \`logprobs\`.\\n" })), "segment_id": Schema.optionalKey(Schema.String.annotate({ "description": "Identifier of the diarized segment that this delta belongs to. Only present when using \`gpt-4o-transcribe-diarize\`.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when there is an additional text delta. This is also the first event emitted when the transcription starts. Only emitted when you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the \`Stream\` parameter set to \`true\`.", "identifier": "TranscriptTextDeltaEvent" })
export type TranscriptTextSegmentEvent = { readonly "type": "transcript.text.segment", readonly "id": string, readonly "start": number, readonly "end": number, readonly "text": string, readonly "speaker": string, readonly [x: string]: unknown }
export const TranscriptTextSegmentEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("transcript.text.segment").annotate({ "description": "The type of the event. Always \`transcript.text.segment\`." }), "id": Schema.String.annotate({ "description": "Unique identifier for the segment." }), "start": Schema.Number.annotate({ "description": "Start timestamp of the segment in seconds.", "format": "float" }).check(Schema.isFinite()), "end": Schema.Number.annotate({ "description": "End timestamp of the segment in seconds.", "format": "float" }).check(Schema.isFinite()), "text": Schema.String.annotate({ "description": "Transcript text for this segment." }), "speaker": Schema.String.annotate({ "description": "Speaker label for this segment." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a diarized transcription returns a completed segment with speaker information. Only emitted when you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with \`stream\` set to \`true\` and \`response_format\` set to \`diarized_json\`.\\n", "identifier": "TranscriptTextSegmentEvent" })
export type TranscriptTextUsageDuration = { readonly "type": "duration", readonly "seconds": number, readonly [x: string]: unknown }
export const TranscriptTextUsageDuration = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("duration").annotate({ "description": "The type of the usage object. Always \`duration\` for this variant." }), "seconds": Schema.Number.annotate({ "description": "Duration of the input audio in seconds." }).check(Schema.isFinite()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "TranscriptTextUsageDuration", "description": "Usage statistics for models billed by audio input duration.", "identifier": "TranscriptTextUsageDuration" })
export type TranscriptTextUsageTokens = { readonly "type": "tokens", readonly "input_tokens": number, readonly "input_token_details"?: { readonly "text_tokens"?: number, readonly "audio_tokens"?: number, readonly [x: string]: unknown }, readonly "output_tokens": number, readonly "total_tokens": number, readonly [x: string]: unknown }
export const TranscriptTextUsageTokens = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("tokens").annotate({ "description": "The type of the usage object. Always \`tokens\` for this variant." }), "input_tokens": Schema.Number.annotate({ "description": "Number of input tokens billed for this request." }).check(Schema.isInt()), "input_token_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "text_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "Number of text tokens billed for this request." }).check(Schema.isInt())), "audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "Number of audio tokens billed for this request." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details about the input tokens billed for this request." })), "output_tokens": Schema.Number.annotate({ "description": "Number of output tokens generated." }).check(Schema.isInt()), "total_tokens": Schema.Number.annotate({ "description": "Total number of tokens used (input + output)." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "TranscriptTextUsageTokens", "description": "Usage statistics for models billed by token usage.", "identifier": "TranscriptTextUsageTokens" })
export type TranscriptionDiarizedSegment = { readonly "type": "transcript.text.segment", readonly "id": string, readonly "start": number, readonly "end": number, readonly "text": string, readonly "speaker": string, readonly [x: string]: unknown }
export const TranscriptionDiarizedSegment = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("transcript.text.segment").annotate({ "description": "The type of the segment. Always \`transcript.text.segment\`.\\n" }), "id": Schema.String.annotate({ "description": "Unique identifier for the segment." }), "start": Schema.Number.annotate({ "description": "Start timestamp of the segment in seconds.", "format": "float" }).check(Schema.isFinite()), "end": Schema.Number.annotate({ "description": "End timestamp of the segment in seconds.", "format": "float" }).check(Schema.isFinite()), "text": Schema.String.annotate({ "description": "Transcript text for this segment." }), "speaker": Schema.String.annotate({ "description": "Speaker label for this segment. When known speakers are provided, the label matches \`known_speaker_names[]\`. Otherwise speakers are labeled sequentially using capital letters (\`A\`, \`B\`, ...).\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A segment of diarized transcript text with speaker metadata.", "identifier": "TranscriptionDiarizedSegment" })
export type TranscriptionInclude = "logprobs"
export const TranscriptionInclude = Schema.Literal("logprobs").annotate({ "identifier": "TranscriptionInclude" })
export type TranscriptionSegment = { readonly "id": number, readonly "seek": number, readonly "start": number, readonly "end": number, readonly "text": string, readonly "tokens": ReadonlyArray<number>, readonly "temperature": number, readonly "avg_logprob": number, readonly "compression_ratio": number, readonly "no_speech_prob": number, readonly [x: string]: unknown }
export const TranscriptionSegment = Schema.StructWithRest(Schema.Struct({ "id": Schema.Number.annotate({ "description": "Unique identifier of the segment." }).check(Schema.isInt()), "seek": Schema.Number.annotate({ "description": "Seek offset of the segment." }).check(Schema.isInt()), "start": Schema.Number.annotate({ "description": "Start time of the segment in seconds.", "format": "float" }).check(Schema.isFinite()), "end": Schema.Number.annotate({ "description": "End time of the segment in seconds.", "format": "float" }).check(Schema.isFinite()), "text": Schema.String.annotate({ "description": "Text content of the segment." }), "tokens": Schema.Array(Schema.Number.check(Schema.isInt())).annotate({ "description": "Array of token IDs for the text content." }), "temperature": Schema.Number.annotate({ "description": "Temperature parameter used for generating the segment.", "format": "float" }).check(Schema.isFinite()), "avg_logprob": Schema.Number.annotate({ "description": "Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.", "format": "float" }).check(Schema.isFinite()), "compression_ratio": Schema.Number.annotate({ "description": "Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.", "format": "float" }).check(Schema.isFinite()), "no_speech_prob": Schema.Number.annotate({ "description": "Probability of no speech in the segment. If the value is higher than 1.0 and the \`avg_logprob\` is below -1, consider this segment silent.", "format": "float" }).check(Schema.isFinite()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "TranscriptionSegment" })
export type TranscriptionWord = { readonly "word": string, readonly "start": number, readonly "end": number, readonly [x: string]: unknown }
export const TranscriptionWord = Schema.StructWithRest(Schema.Struct({ "word": Schema.String.annotate({ "description": "The text content of the word." }), "start": Schema.Number.annotate({ "description": "Start time of the word in seconds.", "format": "float" }).check(Schema.isFinite()), "end": Schema.Number.annotate({ "description": "End time of the word in seconds.", "format": "float" }).check(Schema.isFinite()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "TranscriptionWord" })
export type TruncationObject = { readonly "type": "auto" | "last_messages", readonly "last_messages"?: number | null, readonly [x: string]: unknown }
export const TruncationObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literals(["auto", "last_messages"]).annotate({ "description": "The truncation strategy to use for the thread. The default is \`auto\`. If set to \`last_messages\`, the thread will be truncated to the n most recent messages in the thread. When set to \`auto\`, messages in the middle of the thread will be dropped to fit the context length of the model, \`max_prompt_tokens\`." }), "last_messages": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "The number of most recent messages from the thread when constructing the context for the run." }).check(Schema.isInt()), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Thread Truncation Controls", "description": "Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run.", "identifier": "TruncationObject" })
export type Type = { readonly "type": "type", readonly "text": string, readonly [x: string]: unknown }
export const Type = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("type").annotate({ "description": "Specifies the event type. For a type action, this property is \\nalways set to \`type\`.\\n", "default": "type" }), "text": Schema.String.annotate({ "description": "The text to type.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Type", "description": "An action to type in text.\\n", "identifier": "Type" })
export type UpdateGroupBody = { readonly "name": string, readonly [x: string]: unknown }
export const UpdateGroupBody = Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "New display name for the group." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Request payload for updating the details of an existing group.", "identifier": "UpdateGroupBody" })
export type UpdateVoiceConsentRequest = { readonly "name": string }
export const UpdateVoiceConsentRequest = Schema.Struct({ "name": Schema.String.annotate({ "description": "The updated label for this consent recording." }) }).annotate({ "identifier": "UpdateVoiceConsentRequest" })
export type Upload = { readonly "id": string, readonly "created_at": number, readonly "filename": string, readonly "bytes": number, readonly "purpose": string, readonly "status": "pending" | "completed" | "cancelled" | "expired", readonly "expires_at": number, readonly "object": "upload", readonly "file"?: never, readonly [x: string]: unknown }
export const Upload = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The Upload unique identifier, which can be referenced in API endpoints." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the Upload was created." }).check(Schema.isInt()), "filename": Schema.String.annotate({ "description": "The name of the file to be uploaded." }), "bytes": Schema.Number.annotate({ "description": "The intended number of bytes to be uploaded." }).check(Schema.isInt()), "purpose": Schema.String.annotate({ "description": "The intended purpose of the file. [Please refer here](https://platform.openai.com/docs/api-reference/files/object#files/object-purpose) for acceptable values." }), "status": Schema.Literals(["pending", "completed", "cancelled", "expired"]).annotate({ "description": "The status of the Upload." }), "expires_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the Upload will expire." }).check(Schema.isInt()), "object": Schema.Literal("upload").annotate({ "description": "The object type, which is always \\"upload\\"." }), "file": Schema.optionalKey(Schema.Never) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Upload", "description": "The Upload object can accept byte chunks in the form of Parts.\\n", "identifier": "Upload" })
export type UploadCertificateRequest = { readonly "name"?: string, readonly "content": string, readonly [x: string]: unknown }
export const UploadCertificateRequest = Schema.StructWithRest(Schema.Struct({ "name": Schema.optionalKey(Schema.String.annotate({ "description": "An optional name for the certificate" })), "content": Schema.String.annotate({ "description": "The certificate content in PEM format" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "UploadCertificateRequest" })
export type UploadPart = { readonly "id": string, readonly "created_at": number, readonly "upload_id": string, readonly "object": "upload.part", readonly [x: string]: unknown }
export const UploadPart = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The upload Part unique identifier, which can be referenced in API endpoints." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the Part was created." }).check(Schema.isInt()), "upload_id": Schema.String.annotate({ "description": "The ID of the Upload object that this Part was added to." }), "object": Schema.Literal("upload.part").annotate({ "description": "The object type, which is always \`upload.part\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "UploadPart", "description": "The upload Part represents a chunk of bytes we can add to an Upload object.\\n", "identifier": "UploadPart" })
export type UsageAudioSpeechesResult = { readonly "object": "organization.usage.audio_speeches.result", readonly "characters": number, readonly "num_model_requests": number, readonly "project_id"?: string | null, readonly "user_id"?: string | null, readonly "api_key_id"?: string | null, readonly "model"?: string | null, readonly [x: string]: unknown }
export const UsageAudioSpeechesResult = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.usage.audio_speeches.result"), "characters": Schema.Number.annotate({ "description": "The number of characters processed." }).check(Schema.isInt()), "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(Schema.isInt()), "project_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=project_id\`, this field provides the project ID of the grouped usage result." }), Schema.Null])), "user_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=user_id\`, this field provides the user ID of the grouped usage result." }), Schema.Null])), "api_key_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=api_key_id\`, this field provides the API key ID of the grouped usage result." }), Schema.Null])), "model": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=model\`, this field provides the model name of the grouped usage result." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The aggregated audio speeches usage details of the specific time bucket.", "identifier": "UsageAudioSpeechesResult" })
export type UsageAudioTranscriptionsResult = { readonly "object": "organization.usage.audio_transcriptions.result", readonly "seconds": number, readonly "num_model_requests": number, readonly "project_id"?: string | null, readonly "user_id"?: string | null, readonly "api_key_id"?: string | null, readonly "model"?: string | null, readonly [x: string]: unknown }
export const UsageAudioTranscriptionsResult = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.usage.audio_transcriptions.result"), "seconds": Schema.Number.annotate({ "description": "The number of seconds processed." }).check(Schema.isInt()), "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(Schema.isInt()), "project_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=project_id\`, this field provides the project ID of the grouped usage result." }), Schema.Null])), "user_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=user_id\`, this field provides the user ID of the grouped usage result." }), Schema.Null])), "api_key_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=api_key_id\`, this field provides the API key ID of the grouped usage result." }), Schema.Null])), "model": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=model\`, this field provides the model name of the grouped usage result." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The aggregated audio transcriptions usage details of the specific time bucket.", "identifier": "UsageAudioTranscriptionsResult" })
export type UsageCodeInterpreterSessionsResult = { readonly "object": "organization.usage.code_interpreter_sessions.result", readonly "num_sessions"?: number, readonly "project_id"?: string | null, readonly "sessions": unknown, readonly [x: string]: unknown }
export const UsageCodeInterpreterSessionsResult = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.usage.code_interpreter_sessions.result"), "num_sessions": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of code interpreter sessions." }).check(Schema.isInt())), "project_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=project_id\`, this field provides the project ID of the grouped usage result." }), Schema.Null])), "sessions": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The aggregated code interpreter sessions usage details of the specific time bucket.", "identifier": "UsageCodeInterpreterSessionsResult" })
export type UsageCompletionsResult = { readonly "object": "organization.usage.completions.result", readonly "input_tokens": number, readonly "input_cached_tokens"?: number, readonly "output_tokens": number, readonly "input_audio_tokens"?: number, readonly "output_audio_tokens"?: number, readonly "num_model_requests": number, readonly "project_id"?: string | null, readonly "user_id"?: string | null, readonly "api_key_id"?: string | null, readonly "model"?: string | null, readonly "batch"?: boolean | null, readonly "service_tier"?: string | null, readonly [x: string]: unknown }
export const UsageCompletionsResult = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.usage.completions.result"), "input_tokens": Schema.Number.annotate({ "description": "The aggregated number of text input tokens used, including cached tokens. For customers subscribe to scale tier, this includes scale tier tokens." }).check(Schema.isInt()), "input_cached_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The aggregated number of text input tokens that has been cached from previous requests. For customers subscribe to scale tier, this includes scale tier tokens." }).check(Schema.isInt())), "output_tokens": Schema.Number.annotate({ "description": "The aggregated number of text output tokens used. For customers subscribe to scale tier, this includes scale tier tokens." }).check(Schema.isInt()), "input_audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The aggregated number of audio input tokens used, including cached tokens." }).check(Schema.isInt())), "output_audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The aggregated number of audio output tokens used." }).check(Schema.isInt())), "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(Schema.isInt()), "project_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=project_id\`, this field provides the project ID of the grouped usage result." }), Schema.Null])), "user_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=user_id\`, this field provides the user ID of the grouped usage result." }), Schema.Null])), "api_key_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=api_key_id\`, this field provides the API key ID of the grouped usage result." }), Schema.Null])), "model": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=model\`, this field provides the model name of the grouped usage result." }), Schema.Null])), "batch": Schema.optionalKey(Schema.Union([Schema.Boolean.annotate({ "description": "When \`group_by=batch\`, this field tells whether the grouped usage result is batch or not." }), Schema.Null])), "service_tier": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=service_tier\`, this field provides the service tier of the grouped usage result." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The aggregated completions usage details of the specific time bucket.", "identifier": "UsageCompletionsResult" })
export type UsageEmbeddingsResult = { readonly "object": "organization.usage.embeddings.result", readonly "input_tokens": number, readonly "num_model_requests": number, readonly "project_id"?: string | null, readonly "user_id"?: string | null, readonly "api_key_id"?: string | null, readonly "model"?: string | null, readonly [x: string]: unknown }
export const UsageEmbeddingsResult = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.usage.embeddings.result"), "input_tokens": Schema.Number.annotate({ "description": "The aggregated number of input tokens used." }).check(Schema.isInt()), "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(Schema.isInt()), "project_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=project_id\`, this field provides the project ID of the grouped usage result." }), Schema.Null])), "user_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=user_id\`, this field provides the user ID of the grouped usage result." }), Schema.Null])), "api_key_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=api_key_id\`, this field provides the API key ID of the grouped usage result." }), Schema.Null])), "model": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=model\`, this field provides the model name of the grouped usage result." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The aggregated embeddings usage details of the specific time bucket.", "identifier": "UsageEmbeddingsResult" })
export type UsageImagesResult = { readonly "object": "organization.usage.images.result", readonly "images": number, readonly "num_model_requests": number, readonly "source"?: string | null, readonly "size"?: string | null, readonly "project_id"?: string | null, readonly "user_id"?: string | null, readonly "api_key_id"?: string | null, readonly "model"?: string | null, readonly [x: string]: unknown }
export const UsageImagesResult = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.usage.images.result"), "images": Schema.Number.annotate({ "description": "The number of images processed." }).check(Schema.isInt()), "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(Schema.isInt()), "source": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=source\`, this field provides the source of the grouped usage result, possible values are \`image.generation\`, \`image.edit\`, \`image.variation\`." }), Schema.Null])), "size": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=size\`, this field provides the image size of the grouped usage result." }), Schema.Null])), "project_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=project_id\`, this field provides the project ID of the grouped usage result." }), Schema.Null])), "user_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=user_id\`, this field provides the user ID of the grouped usage result." }), Schema.Null])), "api_key_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=api_key_id\`, this field provides the API key ID of the grouped usage result." }), Schema.Null])), "model": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=model\`, this field provides the model name of the grouped usage result." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The aggregated images usage details of the specific time bucket.", "identifier": "UsageImagesResult" })
export type UsageModerationsResult = { readonly "object": "organization.usage.moderations.result", readonly "input_tokens": number, readonly "num_model_requests": number, readonly "project_id"?: string | null, readonly "user_id"?: string | null, readonly "api_key_id"?: string | null, readonly "model"?: string | null, readonly [x: string]: unknown }
export const UsageModerationsResult = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.usage.moderations.result"), "input_tokens": Schema.Number.annotate({ "description": "The aggregated number of input tokens used." }).check(Schema.isInt()), "num_model_requests": Schema.Number.annotate({ "description": "The count of requests made to the model." }).check(Schema.isInt()), "project_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=project_id\`, this field provides the project ID of the grouped usage result." }), Schema.Null])), "user_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=user_id\`, this field provides the user ID of the grouped usage result." }), Schema.Null])), "api_key_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=api_key_id\`, this field provides the API key ID of the grouped usage result." }), Schema.Null])), "model": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=model\`, this field provides the model name of the grouped usage result." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The aggregated moderations usage details of the specific time bucket.", "identifier": "UsageModerationsResult" })
export type UsageVectorStoresResult = { readonly "object": "organization.usage.vector_stores.result", readonly "usage_bytes": number, readonly "project_id"?: string | null, readonly [x: string]: unknown }
export const UsageVectorStoresResult = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.usage.vector_stores.result"), "usage_bytes": Schema.Number.annotate({ "description": "The vector stores usage in bytes." }).check(Schema.isInt()), "project_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "When \`group_by=project_id\`, this field provides the project ID of the grouped usage result." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The aggregated vector stores usage details of the specific time bucket.", "identifier": "UsageVectorStoresResult" })
export type User = { readonly "object": "organization.user", readonly "id": string, readonly "name": string, readonly "email": string, readonly "role": "owner" | "reader", readonly "added_at": number, readonly [x: string]: unknown }
export const User = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.user").annotate({ "description": "The object type, which is always \`organization.user\`" }), "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }), "name": Schema.String.annotate({ "description": "The name of the user" }), "email": Schema.String.annotate({ "description": "The email address of the user" }), "role": Schema.Literals(["owner", "reader"]).annotate({ "description": "\`owner\` or \`reader\`" }), "added_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the user was added." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents an individual \`user\` within an organization.", "identifier": "User" })
export type UserDeleteResponse = { readonly "object": "organization.user.deleted", readonly "id": string, readonly "deleted": boolean, readonly [x: string]: unknown }
export const UserDeleteResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.user.deleted"), "id": Schema.String, "deleted": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "UserDeleteResponse" })
export type UserRoleUpdateRequest = { readonly "role": "owner" | "reader", readonly [x: string]: unknown }
export const UserRoleUpdateRequest = Schema.StructWithRest(Schema.Struct({ "role": Schema.Literals(["owner", "reader"]).annotate({ "description": "\`owner\` or \`reader\`" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "UserRoleUpdateRequest" })
export type VadConfig = { readonly "type": "server_vad", readonly "prefix_padding_ms"?: number, readonly "silence_duration_ms"?: number, readonly "threshold"?: number }
export const VadConfig = Schema.Struct({ "type": Schema.Literal("server_vad").annotate({ "description": "Must be set to \`server_vad\` to enable manual chunking using server side VAD." }), "prefix_padding_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Amount of audio to include before the VAD detected speech (in \\nmilliseconds).\\n", "default": 300 }).check(Schema.isInt())), "silence_duration_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Duration of silence to detect speech stop (in milliseconds).\\nWith shorter values the model will respond more quickly, \\nbut may jump in on short pauses from the user.\\n", "default": 200 }).check(Schema.isInt())), "threshold": Schema.optionalKey(Schema.Number.annotate({ "description": "Sensitivity threshold (0.0 to 1.0) for voice activity detection. A \\nhigher threshold will require louder audio to activate the model, and \\nthus might perform better in noisy environments.\\n", "default": 0.5 }).check(Schema.isFinite())) }).annotate({ "identifier": "VadConfig" })
export type VectorStoreExpirationAfter = { readonly "anchor": "last_active_at", readonly "days": number, readonly [x: string]: unknown }
export const VectorStoreExpirationAfter = Schema.StructWithRest(Schema.Struct({ "anchor": Schema.Literal("last_active_at").annotate({ "description": "Anchor timestamp after which the expiration policy applies. Supported anchors: \`last_active_at\`." }), "days": Schema.Number.annotate({ "description": "The number of days after the anchor time that the vector store will expire." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Vector store expiration policy", "description": "The expiration policy for a vector store.", "identifier": "VectorStoreExpirationAfter" })
export type VectorStoreFileAttributes = { readonly [x: string]: string | number | boolean } | null
export const VectorStoreFileAttributes = Schema.Union([Schema.Record(Schema.String, Schema.Union([Schema.String, Schema.Number.check(Schema.isFinite()), Schema.Boolean])).annotate({ "description": "Set of 16 key-value pairs that can be attached to an object. This can be\\nuseful for storing additional information about the object in a structured\\nformat, and querying for objects via API or the dashboard. Keys are strings\\nwith a maximum length of 64 characters. Values are strings with a maximum\\nlength of 512 characters, booleans, or numbers.\\n" }), Schema.Null]).annotate({ "identifier": "VectorStoreFileAttributes" })
export type VectorStoreFileBatchObject = { readonly "id": string, readonly "object": "vector_store.files_batch", readonly "created_at": number, readonly "vector_store_id": string, readonly "status": "in_progress" | "completed" | "cancelled" | "failed", readonly "file_counts": { readonly "in_progress": number, readonly "completed": number, readonly "failed": number, readonly "cancelled": number, readonly "total": number, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const VectorStoreFileBatchObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }), "object": Schema.Literal("vector_store.files_batch").annotate({ "description": "The object type, which is always \`vector_store.file_batch\`." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the vector store files batch was created." }).check(Schema.isInt()), "vector_store_id": Schema.String.annotate({ "description": "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to." }), "status": Schema.Literals(["in_progress", "completed", "cancelled", "failed"]).annotate({ "description": "The status of the vector store files batch, which can be either \`in_progress\`, \`completed\`, \`cancelled\` or \`failed\`." }), "file_counts": Schema.StructWithRest(Schema.Struct({ "in_progress": Schema.Number.annotate({ "description": "The number of files that are currently being processed." }).check(Schema.isInt()), "completed": Schema.Number.annotate({ "description": "The number of files that have been processed." }).check(Schema.isInt()), "failed": Schema.Number.annotate({ "description": "The number of files that have failed to process." }).check(Schema.isInt()), "cancelled": Schema.Number.annotate({ "description": "The number of files that where cancelled." }).check(Schema.isInt()), "total": Schema.Number.annotate({ "description": "The total number of files." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Vector store file batch", "description": "A batch of files attached to a vector store.", "identifier": "VectorStoreFileBatchObject" })
export type VectorStoreFileContentResponse = { readonly "object": "vector_store.file_content.page", readonly "data": ReadonlyArray<{ readonly "type"?: string, readonly "text"?: string, readonly [x: string]: unknown }>, readonly "has_more": boolean, readonly "next_page": string | null, readonly [x: string]: unknown }
export const VectorStoreFileContentResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("vector_store.file_content.page").annotate({ "description": "The object type, which is always \`vector_store.file_content.page\`" }), "data": Schema.Array(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "The content type (currently only \`\\"text\\"\`)" })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text content" })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "Parsed content of the file." }), "has_more": Schema.Boolean.annotate({ "description": "Indicates if there are more content pages to fetch." }), "next_page": Schema.Union([Schema.String.annotate({ "description": "The token for the next page, if any." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents the parsed content of a vector store file.", "identifier": "VectorStoreFileContentResponse" })
export type VectorStoreSearchResultContentObject = { readonly "type": "text", readonly "text": string }
export const VectorStoreSearchResultContentObject = Schema.Struct({ "type": Schema.Literal("text").annotate({ "description": "The type of content." }), "text": Schema.String.annotate({ "description": "The text content returned from search." }) }).annotate({ "identifier": "VectorStoreSearchResultContentObject" })
export type Verbosity = "low" | "medium" | "high" | null
export const Verbosity = Schema.Union([Schema.Literals(["low", "medium", "high"]).annotate({ "description": "Constrains the verbosity of the model's response. Lower values will result in\\nmore concise responses, while higher values will result in more verbose responses.\\nCurrently supported values are \`low\`, \`medium\`, and \`high\`.\\n", "default": "medium" }), Schema.Null]).annotate({ "identifier": "Verbosity" })
export type VoiceConsentDeletedResource = { readonly "id": string, readonly "object": "audio.voice_consent", readonly "deleted": boolean }
export const VoiceConsentDeletedResource = Schema.Struct({ "id": Schema.String.annotate({ "description": "The consent recording identifier." }), "object": Schema.Literal("audio.voice_consent"), "deleted": Schema.Boolean }).annotate({ "identifier": "VoiceConsentDeletedResource" })
export type VoiceConsentResource = { readonly "object": "audio.voice_consent", readonly "id": string, readonly "name": string, readonly "language": string, readonly "created_at": number }
export const VoiceConsentResource = Schema.Struct({ "object": Schema.Literal("audio.voice_consent").annotate({ "description": "The object type, which is always \`audio.voice_consent\`." }), "id": Schema.String.annotate({ "description": "The consent recording identifier." }), "name": Schema.String.annotate({ "description": "The label provided when the consent recording was uploaded." }), "language": Schema.String.annotate({ "description": "The BCP 47 language tag for the consent phrase (for example, \`en-US\`)." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the consent recording was created." }).check(Schema.isInt()) }).annotate({ "title": "Voice consent", "description": "A consent recording used to authorize creation of a custom voice.", "identifier": "VoiceConsentResource" })
export type VoiceIdsShared = string | "alloy" | "ash" | "ballad" | "coral" | "echo" | "sage" | "shimmer" | "verse" | "marin" | "cedar"
export const VoiceIdsShared = Schema.Union([Schema.String, Schema.Literals(["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse", "marin", "cedar"])]).annotate({ "identifier": "VoiceIdsShared" })
export type VoiceResource = { readonly "object": "audio.voice", readonly "id": string, readonly "name": string, readonly "created_at": number }
export const VoiceResource = Schema.Struct({ "object": Schema.Literal("audio.voice").annotate({ "description": "The object type, which is always \`audio.voice\`." }), "id": Schema.String.annotate({ "description": "The voice identifier, which can be referenced in API endpoints." }), "name": Schema.String.annotate({ "description": "The name of the voice." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the voice was created." }).check(Schema.isInt()) }).annotate({ "title": "Voice", "description": "A custom voice that can be used for audio output.", "identifier": "VoiceResource" })
export type Wait = { readonly "type": "wait", readonly [x: string]: unknown }
export const Wait = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("wait").annotate({ "description": "Specifies the event type. For a wait action, this property is \\nalways set to \`wait\`.\\n", "default": "wait" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Wait", "description": "A wait action.\\n", "identifier": "Wait" })
export type WebSearchActionFind = { readonly "type": "find", readonly "url": string, readonly "pattern": string, readonly [x: string]: unknown }
export const WebSearchActionFind = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("find").annotate({ "description": "The action type.\\n" }), "url": Schema.String.annotate({ "description": "The URL of the page searched for the pattern.\\n", "format": "uri" }), "pattern": Schema.String.annotate({ "description": "The pattern or text to search for within the page.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Find action", "description": "Action type \\"find\\": Searches for a pattern within a loaded page.\\n", "identifier": "WebSearchActionFind" })
export type WebSearchActionOpenPage = { readonly "type": "open_page", readonly "url": string, readonly [x: string]: unknown }
export const WebSearchActionOpenPage = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("open_page").annotate({ "description": "The action type.\\n" }), "url": Schema.String.annotate({ "description": "The URL opened by the model.\\n", "format": "uri" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Open page action", "description": "Action type \\"open_page\\" - Opens a specific URL from search results.\\n", "identifier": "WebSearchActionOpenPage" })
export type WebSearchActionSearch = { readonly "type": "search", readonly "query": string, readonly "sources"?: ReadonlyArray<{ readonly "type": "url", readonly "url": string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }
export const WebSearchActionSearch = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("search").annotate({ "description": "The action type.\\n" }), "query": Schema.String.annotate({ "description": "The search query.\\n" }), "sources": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("url").annotate({ "description": "The type of source. Always \`url\`.\\n" }), "url": Schema.String.annotate({ "description": "The URL of the source.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Web search source", "description": "A source used in the search.\\n" })).annotate({ "title": "Web search sources", "description": "The sources used in the search.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Search action", "description": "Action type \\"search\\" - Performs a web search query.\\n", "identifier": "WebSearchActionSearch" })
export type WebSearchApproximateLocation = { readonly "type"?: "approximate", readonly "country"?: string | null, readonly "region"?: string | null, readonly "city"?: string | null, readonly "timezone"?: string | null, readonly [x: string]: unknown } | null
export const WebSearchApproximateLocation = Schema.Union([Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("approximate").annotate({ "description": "The type of location approximation. Always \`approximate\`.", "default": "approximate" })), "country": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. \`US\`." }), Schema.Null])), "region": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Free text input for the region of the user, e.g. \`California\`." }), Schema.Null])), "city": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Free text input for the city of the user, e.g. \`San Francisco\`." }), Schema.Null])), "timezone": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. \`America/Los_Angeles\`." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Web search approximate location", "description": "The approximate location of the user.\\n" }), Schema.Null]).annotate({ "identifier": "WebSearchApproximateLocation" })
export type WebSearchContextSize = "low" | "medium" | "high"
export const WebSearchContextSize = Schema.Literals(["low", "medium", "high"]).annotate({ "description": "High level guidance for the amount of context window space to use for the \\nsearch. One of \`low\`, \`medium\`, or \`high\`. \`medium\` is the default.\\n", "default": "medium", "identifier": "WebSearchContextSize" })
export type WebSearchLocation = { readonly "country"?: string, readonly "region"?: string, readonly "city"?: string, readonly "timezone"?: string, readonly [x: string]: unknown }
export const WebSearchLocation = Schema.StructWithRest(Schema.Struct({ "country": Schema.optionalKey(Schema.String.annotate({ "description": "The two-letter \\n[ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user,\\ne.g. \`US\`.\\n" })), "region": Schema.optionalKey(Schema.String.annotate({ "description": "Free text input for the region of the user, e.g. \`California\`.\\n" })), "city": Schema.optionalKey(Schema.String.annotate({ "description": "Free text input for the city of the user, e.g. \`San Francisco\`.\\n" })), "timezone": Schema.optionalKey(Schema.String.annotate({ "description": "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) \\nof the user, e.g. \`America/Los_Angeles\`.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Web search location", "description": "Approximate location parameters for the search.", "identifier": "WebSearchLocation" })
export type WebhookBatchCancelled = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "batch.cancelled", readonly [x: string]: unknown }
export const WebhookBatchCancelled = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the batch API request was cancelled.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the batch API request.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("batch.cancelled").annotate({ "description": "The type of the event. Always \`batch.cancelled\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "batch.cancelled", "description": "Sent when a batch API request has been cancelled.\\n", "identifier": "WebhookBatchCancelled" })
export type WebhookBatchCompleted = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "batch.completed", readonly [x: string]: unknown }
export const WebhookBatchCompleted = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the batch API request was completed.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the batch API request.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("batch.completed").annotate({ "description": "The type of the event. Always \`batch.completed\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "batch.completed", "description": "Sent when a batch API request has been completed.\\n", "identifier": "WebhookBatchCompleted" })
export type WebhookBatchExpired = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "batch.expired", readonly [x: string]: unknown }
export const WebhookBatchExpired = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the batch API request expired.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the batch API request.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("batch.expired").annotate({ "description": "The type of the event. Always \`batch.expired\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "batch.expired", "description": "Sent when a batch API request has expired.\\n", "identifier": "WebhookBatchExpired" })
export type WebhookBatchFailed = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "batch.failed", readonly [x: string]: unknown }
export const WebhookBatchFailed = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the batch API request failed.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the batch API request.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("batch.failed").annotate({ "description": "The type of the event. Always \`batch.failed\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "batch.failed", "description": "Sent when a batch API request has failed.\\n", "identifier": "WebhookBatchFailed" })
export type WebhookEvalRunCanceled = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "eval.run.canceled", readonly [x: string]: unknown }
export const WebhookEvalRunCanceled = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the eval run was canceled.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the eval run.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("eval.run.canceled").annotate({ "description": "The type of the event. Always \`eval.run.canceled\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "eval.run.canceled", "description": "Sent when an eval run has been canceled.\\n", "identifier": "WebhookEvalRunCanceled" })
export type WebhookEvalRunFailed = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "eval.run.failed", readonly [x: string]: unknown }
export const WebhookEvalRunFailed = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the eval run failed.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the eval run.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("eval.run.failed").annotate({ "description": "The type of the event. Always \`eval.run.failed\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "eval.run.failed", "description": "Sent when an eval run has failed.\\n", "identifier": "WebhookEvalRunFailed" })
export type WebhookEvalRunSucceeded = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "eval.run.succeeded", readonly [x: string]: unknown }
export const WebhookEvalRunSucceeded = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the eval run succeeded.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the eval run.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("eval.run.succeeded").annotate({ "description": "The type of the event. Always \`eval.run.succeeded\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "eval.run.succeeded", "description": "Sent when an eval run has succeeded.\\n", "identifier": "WebhookEvalRunSucceeded" })
export type WebhookFineTuningJobCancelled = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "fine_tuning.job.cancelled", readonly [x: string]: unknown }
export const WebhookFineTuningJobCancelled = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the fine-tuning job was cancelled.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the fine-tuning job.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("fine_tuning.job.cancelled").annotate({ "description": "The type of the event. Always \`fine_tuning.job.cancelled\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "fine_tuning.job.cancelled", "description": "Sent when a fine-tuning job has been cancelled.\\n", "identifier": "WebhookFineTuningJobCancelled" })
export type WebhookFineTuningJobFailed = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "fine_tuning.job.failed", readonly [x: string]: unknown }
export const WebhookFineTuningJobFailed = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the fine-tuning job failed.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the fine-tuning job.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("fine_tuning.job.failed").annotate({ "description": "The type of the event. Always \`fine_tuning.job.failed\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "fine_tuning.job.failed", "description": "Sent when a fine-tuning job has failed.\\n", "identifier": "WebhookFineTuningJobFailed" })
export type WebhookFineTuningJobSucceeded = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "fine_tuning.job.succeeded", readonly [x: string]: unknown }
export const WebhookFineTuningJobSucceeded = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the fine-tuning job succeeded.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the fine-tuning job.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("fine_tuning.job.succeeded").annotate({ "description": "The type of the event. Always \`fine_tuning.job.succeeded\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "fine_tuning.job.succeeded", "description": "Sent when a fine-tuning job has succeeded.\\n", "identifier": "WebhookFineTuningJobSucceeded" })
export type WebhookRealtimeCallIncoming = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "call_id": string, readonly "sip_headers": ReadonlyArray<{ readonly "name": string, readonly "value": string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "realtime.call.incoming", readonly [x: string]: unknown }
export const WebhookRealtimeCallIncoming = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the model response was completed.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "call_id": Schema.String.annotate({ "description": "The unique ID of this call.\\n" }), "sip_headers": Schema.Array(Schema.StructWithRest(Schema.Struct({ "name": Schema.String.annotate({ "description": "Name of the SIP Header.\\n" }), "value": Schema.String.annotate({ "description": "Value of the SIP Header.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A header from the SIP Invite.\\n" })).annotate({ "description": "Headers from the SIP Invite.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("realtime.call.incoming").annotate({ "description": "The type of the event. Always \`realtime.call.incoming\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "realtime.call.incoming", "description": "Sent when Realtime API Receives a incoming SIP call.\\n", "identifier": "WebhookRealtimeCallIncoming" })
export type WebhookResponseCancelled = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "response.cancelled", readonly [x: string]: unknown }
export const WebhookResponseCancelled = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the model response was cancelled.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the model response.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("response.cancelled").annotate({ "description": "The type of the event. Always \`response.cancelled\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "response.cancelled", "description": "Sent when a background response has been cancelled.\\n", "identifier": "WebhookResponseCancelled" })
export type WebhookResponseCompleted = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "response.completed", readonly [x: string]: unknown }
export const WebhookResponseCompleted = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the model response was completed.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the model response.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("response.completed").annotate({ "description": "The type of the event. Always \`response.completed\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "response.completed", "description": "Sent when a background response has been completed.\\n", "identifier": "WebhookResponseCompleted" })
export type WebhookResponseFailed = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "response.failed", readonly [x: string]: unknown }
export const WebhookResponseFailed = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the model response failed.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the model response.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("response.failed").annotate({ "description": "The type of the event. Always \`response.failed\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "response.failed", "description": "Sent when a background response has failed.\\n", "identifier": "WebhookResponseFailed" })
export type WebhookResponseIncomplete = { readonly "created_at": number, readonly "id": string, readonly "data": { readonly "id": string, readonly [x: string]: unknown }, readonly "object"?: "event", readonly "type": "response.incomplete", readonly [x: string]: unknown }
export const WebhookResponseIncomplete = Schema.StructWithRest(Schema.Struct({ "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the model response was interrupted.\\n" }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The unique ID of the event.\\n" }), "data": Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the model response.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Event data payload.\\n" }), "object": Schema.optionalKey(Schema.Literal("event").annotate({ "description": "The object of the event. Always \`event\`.\\n" })), "type": Schema.Literal("response.incomplete").annotate({ "description": "The type of the event. Always \`response.incomplete\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "response.incomplete", "description": "Sent when a background response has been interrupted.\\n", "identifier": "WebhookResponseIncomplete" })
export type IncludeEnum = "file_search_call.results" | "web_search_call.results" | "web_search_call.action.sources" | "message.input_image.image_url" | "computer_call_output.output.image_url" | "code_interpreter_call.outputs" | "reasoning.encrypted_content" | "message.output_text.logprobs"
export const IncludeEnum = Schema.Literals(["file_search_call.results", "web_search_call.results", "web_search_call.action.sources", "message.input_image.image_url", "computer_call_output.output.image_url", "code_interpreter_call.outputs", "reasoning.encrypted_content", "message.output_text.logprobs"]).annotate({ "description": "Specify additional output data to include in the model response. Currently supported values are:\\n- \`web_search_call.action.sources\`: Include the sources of the web search tool call.\\n- \`code_interpreter_call.outputs\`: Includes the outputs of python code execution in code interpreter tool call items.\\n- \`computer_call_output.output.image_url\`: Include image urls from the computer call output.\\n- \`file_search_call.results\`: Include the search results of the file search tool call.\\n- \`message.input_image.image_url\`: Include image urls from the input message.\\n- \`message.output_text.logprobs\`: Include logprobs with assistant messages.\\n- \`reasoning.encrypted_content\`: Includes an encrypted version of reasoning tokens in reasoning item outputs. This enables reasoning items to be used in multi-turn conversations when using the Responses API statelessly (like when the \`store\` parameter is set to \`false\`, or when an organization is enrolled in the zero data retention program).", "identifier": "IncludeEnum" })
export type MessageStatus = "in_progress" | "completed" | "incomplete"
export const MessageStatus = Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "identifier": "MessageStatus" })
export type MessageRole = "unknown" | "user" | "assistant" | "system" | "critic" | "discriminator" | "developer" | "tool"
export const MessageRole = Schema.Literals(["unknown", "user", "assistant", "system", "critic", "discriminator", "developer", "tool"]).annotate({ "identifier": "MessageRole" })
export type InputTextContent = { readonly "type": "input_text", readonly "text": string, readonly [x: string]: unknown }
export const InputTextContent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_text").annotate({ "description": "The type of the input item. Always \`input_text\`.", "default": "input_text" }), "text": Schema.String.annotate({ "description": "The text input to the model." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input text", "description": "A text input to the model.", "identifier": "InputTextContent" })
export type FileCitationBody = { readonly "type": "file_citation", readonly "file_id": string, readonly "index": number, readonly "filename": string, readonly [x: string]: unknown }
export const FileCitationBody = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file_citation").annotate({ "description": "The type of the file citation. Always \`file_citation\`.", "default": "file_citation" }), "file_id": Schema.String.annotate({ "description": "The ID of the file." }), "index": Schema.Number.annotate({ "description": "The index of the file in the list of files." }).check(Schema.isInt()), "filename": Schema.String.annotate({ "description": "The filename of the file cited." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File citation", "description": "A citation to a file.", "identifier": "FileCitationBody" })
export type UrlCitationBody = { readonly "type": "url_citation", readonly "url": string, readonly "start_index": number, readonly "end_index": number, readonly "title": string, readonly [x: string]: unknown }
export const UrlCitationBody = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("url_citation").annotate({ "description": "The type of the URL citation. Always \`url_citation\`.", "default": "url_citation" }), "url": Schema.String.annotate({ "description": "The URL of the web resource." }), "start_index": Schema.Number.annotate({ "description": "The index of the first character of the URL citation in the message." }).check(Schema.isInt()), "end_index": Schema.Number.annotate({ "description": "The index of the last character of the URL citation in the message." }).check(Schema.isInt()), "title": Schema.String.annotate({ "description": "The title of the web resource." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "URL citation", "description": "A citation for a web resource used to generate a model response.", "identifier": "UrlCitationBody" })
export type ContainerFileCitationBody = { readonly "type": "container_file_citation", readonly "container_id": string, readonly "file_id": string, readonly "start_index": number, readonly "end_index": number, readonly "filename": string, readonly [x: string]: unknown }
export const ContainerFileCitationBody = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("container_file_citation").annotate({ "description": "The type of the container file citation. Always \`container_file_citation\`.", "default": "container_file_citation" }), "container_id": Schema.String.annotate({ "description": "The ID of the container file." }), "file_id": Schema.String.annotate({ "description": "The ID of the file." }), "start_index": Schema.Number.annotate({ "description": "The index of the first character of the container file citation in the message." }).check(Schema.isInt()), "end_index": Schema.Number.annotate({ "description": "The index of the last character of the container file citation in the message." }).check(Schema.isInt()), "filename": Schema.String.annotate({ "description": "The filename of the container file cited." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Container file citation", "description": "A citation for a container file used to generate a model response.", "identifier": "ContainerFileCitationBody" })
export type TopLogProb = { readonly "token": string, readonly "logprob": number, readonly "bytes": ReadonlyArray<number>, readonly [x: string]: unknown }
export const TopLogProb = Schema.StructWithRest(Schema.Struct({ "token": Schema.String, "logprob": Schema.Number.check(Schema.isFinite()), "bytes": Schema.Array(Schema.Number.check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Top log probability", "description": "The top log probability of a token.", "identifier": "TopLogProb" })
export type TextContent = { readonly "type": "text", readonly "text": string, readonly [x: string]: unknown }
export const TextContent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("text").annotate({ "default": "text" }), "text": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Text Content", "description": "A text content.", "identifier": "TextContent" })
export type SummaryTextContent = { readonly "type": "summary_text", readonly "text": string, readonly [x: string]: unknown }
export const SummaryTextContent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("summary_text").annotate({ "description": "The type of the object. Always \`summary_text\`.", "default": "summary_text" }), "text": Schema.String.annotate({ "description": "A summary of the reasoning output from the model so far." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Summary text", "description": "A summary text from the model.", "identifier": "SummaryTextContent" })
export type ReasoningTextContent = { readonly "type": "reasoning_text", readonly "text": string, readonly [x: string]: unknown }
export const ReasoningTextContent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("reasoning_text").annotate({ "description": "The type of the reasoning text. Always \`reasoning_text\`.", "default": "reasoning_text" }), "text": Schema.String.annotate({ "description": "The reasoning text from the model." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ReasoningTextContent", "description": "Reasoning text from the model.", "identifier": "ReasoningTextContent" })
export type RefusalContent = { readonly "type": "refusal", readonly "refusal": string, readonly [x: string]: unknown }
export const RefusalContent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("refusal").annotate({ "description": "The type of the refusal. Always \`refusal\`.", "default": "refusal" }), "refusal": Schema.String.annotate({ "description": "The refusal explanation from the model." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Refusal", "description": "A refusal from the model.", "identifier": "RefusalContent" })
export type ImageDetail = "low" | "high" | "auto"
export const ImageDetail = Schema.Literals(["low", "high", "auto"]).annotate({ "identifier": "ImageDetail" })
export type ComputerScreenshotContent = { readonly "type": "computer_screenshot", readonly "image_url": string | null, readonly "file_id": string | null, readonly [x: string]: unknown }
export const ComputerScreenshotContent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("computer_screenshot").annotate({ "description": "Specifies the event type. For a computer screenshot, this property is always set to \`computer_screenshot\`.", "default": "computer_screenshot" }), "image_url": Schema.Union([Schema.String.annotate({ "description": "The URL of the screenshot image." }), Schema.Null]), "file_id": Schema.Union([Schema.String.annotate({ "description": "The identifier of an uploaded file that contains the screenshot." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Computer screenshot", "description": "A screenshot of a computer.", "identifier": "ComputerScreenshotContent" })
export type InputFileContent = { readonly "type": "input_file", readonly "file_id"?: string | null, readonly "filename"?: string, readonly "file_url"?: string, readonly "file_data"?: string, readonly [x: string]: unknown }
export const InputFileContent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_file").annotate({ "description": "The type of the input item. Always \`input_file\`.", "default": "input_file" }), "file_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the file to be sent to the model." }), Schema.Null])), "filename": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the file to be sent to the model." })), "file_url": Schema.optionalKey(Schema.String.annotate({ "description": "The URL of the file to be sent to the model." })), "file_data": Schema.optionalKey(Schema.String.annotate({ "description": "The content of the file to be sent to the model.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input file", "description": "A file input to the model.", "identifier": "InputFileContent" })
export type ClickButtonType = "left" | "right" | "wheel" | "back" | "forward"
export const ClickButtonType = Schema.Literals(["left", "right", "wheel", "back", "forward"]).annotate({ "identifier": "ClickButtonType" })
export type DoubleClickAction = { readonly "type": "double_click", readonly "x": number, readonly "y": number, readonly [x: string]: unknown }
export const DoubleClickAction = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("double_click").annotate({ "description": "Specifies the event type. For a double click action, this property is always set to \`double_click\`.", "default": "double_click" }), "x": Schema.Number.annotate({ "description": "The x-coordinate where the double click occurred." }).check(Schema.isInt()), "y": Schema.Number.annotate({ "description": "The y-coordinate where the double click occurred." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "DoubleClick", "description": "A double click action.", "identifier": "DoubleClickAction" })
export type DragPoint = { readonly "x": number, readonly "y": number, readonly [x: string]: unknown }
export const DragPoint = Schema.StructWithRest(Schema.Struct({ "x": Schema.Number.annotate({ "description": "The x-coordinate." }).check(Schema.isInt()), "y": Schema.Number.annotate({ "description": "The y-coordinate." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Coordinate", "description": "An x/y coordinate pair, e.g. \`{ x: 100, y: 200 }\`.", "identifier": "DragPoint" })
export type KeyPressAction = { readonly "type": "keypress", readonly "keys": ReadonlyArray<string>, readonly [x: string]: unknown }
export const KeyPressAction = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("keypress").annotate({ "description": "Specifies the event type. For a keypress action, this property is always set to \`keypress\`.", "default": "keypress" }), "keys": Schema.Array(Schema.String.annotate({ "description": "One of the keys the model is requesting to be pressed." })).annotate({ "description": "The combination of keys the model is requesting to be pressed. This is an array of strings, each representing a key." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "KeyPress", "description": "A collection of keypresses the model would like to perform.", "identifier": "KeyPressAction" })
export type ComputerCallSafetyCheckParam = { readonly "id": string, readonly "code"?: string | null, readonly "message"?: string | null, readonly [x: string]: unknown }
export const ComputerCallSafetyCheckParam = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The ID of the pending safety check." }), "code": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The type of the pending safety check." }), Schema.Null])), "message": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Details about the pending safety check." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A pending safety check for the computer call.", "identifier": "ComputerCallSafetyCheckParam" })
export type CodeInterpreterOutputLogs = { readonly "type": "logs", readonly "logs": string, readonly [x: string]: unknown }
export const CodeInterpreterOutputLogs = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("logs").annotate({ "description": "The type of the output. Always \`logs\`.", "default": "logs" }), "logs": Schema.String.annotate({ "description": "The logs output from the code interpreter." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code interpreter output logs", "description": "The logs output from the code interpreter.", "identifier": "CodeInterpreterOutputLogs" })
export type CodeInterpreterOutputImage = { readonly "type": "image", readonly "url": string, readonly [x: string]: unknown }
export const CodeInterpreterOutputImage = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image").annotate({ "description": "The type of the output. Always \`image\`.", "default": "image" }), "url": Schema.String.annotate({ "description": "The URL of the image output from the code interpreter." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code interpreter output image", "description": "The image output from the code interpreter.", "identifier": "CodeInterpreterOutputImage" })
export type LocalShellExecAction = { readonly "type": "exec", readonly "command": ReadonlyArray<string>, readonly "timeout_ms"?: number | null, readonly "working_directory"?: string | null, readonly "env": { readonly [x: string]: string }, readonly "user"?: string | null, readonly [x: string]: unknown }
export const LocalShellExecAction = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("exec").annotate({ "description": "The type of the local shell action. Always \`exec\`.", "default": "exec" }), "command": Schema.Array(Schema.String).annotate({ "description": "The command to run." }), "timeout_ms": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "Optional timeout in milliseconds for the command." }).check(Schema.isInt()), Schema.Null])), "working_directory": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Optional working directory to run the command in." }), Schema.Null])), "env": Schema.Record(Schema.String, Schema.String).annotate({ "description": "Environment variables to set for the command." }), "user": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Optional user to run the command as." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Local shell exec action", "description": "Execute a shell command on the server.", "identifier": "LocalShellExecAction" })
export type FunctionShellAction = { readonly "commands": ReadonlyArray<string>, readonly "timeout_ms": number | null, readonly "max_output_length": number | null, readonly [x: string]: unknown }
export const FunctionShellAction = Schema.StructWithRest(Schema.Struct({ "commands": Schema.Array(Schema.String.annotate({ "description": "A list of commands to run." })), "timeout_ms": Schema.Union([Schema.Number.annotate({ "description": "Optional timeout in milliseconds for the commands." }).check(Schema.isInt()), Schema.Null]), "max_output_length": Schema.Union([Schema.Number.annotate({ "description": "Optional maximum number of characters to return from each command." }).check(Schema.isInt()), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell exec action", "description": "Execute a shell command.", "identifier": "FunctionShellAction" })
export type LocalShellCallStatus = "in_progress" | "completed" | "incomplete"
export const LocalShellCallStatus = Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "identifier": "LocalShellCallStatus" })
export type FunctionShellCallOutputTimeoutOutcome = { readonly "type": "timeout", readonly [x: string]: unknown }
export const FunctionShellCallOutputTimeoutOutcome = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("timeout").annotate({ "description": "The outcome type. Always \`timeout\`.", "default": "timeout" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell call timeout outcome", "description": "Indicates that the shell call exceeded its configured time limit.", "identifier": "FunctionShellCallOutputTimeoutOutcome" })
export type FunctionShellCallOutputExitOutcome = { readonly "type": "exit", readonly "exit_code": number, readonly [x: string]: unknown }
export const FunctionShellCallOutputExitOutcome = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("exit").annotate({ "description": "The outcome type. Always \`exit\`.", "default": "exit" }), "exit_code": Schema.Number.annotate({ "description": "Exit code from the shell process." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell call exit outcome", "description": "Indicates that the shell commands finished and returned an exit code.", "identifier": "FunctionShellCallOutputExitOutcome" })
export type ApplyPatchCallStatus = "in_progress" | "completed"
export const ApplyPatchCallStatus = Schema.Literals(["in_progress", "completed"]).annotate({ "identifier": "ApplyPatchCallStatus" })
export type ApplyPatchCreateFileOperation = { readonly "type": "create_file", readonly "path": string, readonly "diff": string, readonly [x: string]: unknown }
export const ApplyPatchCreateFileOperation = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("create_file").annotate({ "description": "Create a new file with the provided diff.", "default": "create_file" }), "path": Schema.String.annotate({ "description": "Path of the file to create." }), "diff": Schema.String.annotate({ "description": "Diff to apply." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch create file operation", "description": "Instruction describing how to create a file via the apply_patch tool.", "identifier": "ApplyPatchCreateFileOperation" })
export type ApplyPatchDeleteFileOperation = { readonly "type": "delete_file", readonly "path": string, readonly [x: string]: unknown }
export const ApplyPatchDeleteFileOperation = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("delete_file").annotate({ "description": "Delete the specified file.", "default": "delete_file" }), "path": Schema.String.annotate({ "description": "Path of the file to delete." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch delete file operation", "description": "Instruction describing how to delete a file via the apply_patch tool.", "identifier": "ApplyPatchDeleteFileOperation" })
export type ApplyPatchUpdateFileOperation = { readonly "type": "update_file", readonly "path": string, readonly "diff": string, readonly [x: string]: unknown }
export const ApplyPatchUpdateFileOperation = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("update_file").annotate({ "description": "Update an existing file with the provided diff.", "default": "update_file" }), "path": Schema.String.annotate({ "description": "Path of the file to update." }), "diff": Schema.String.annotate({ "description": "Diff to apply." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch update file operation", "description": "Instruction describing how to update a file via the apply_patch tool.", "identifier": "ApplyPatchUpdateFileOperation" })
export type ApplyPatchCallOutputStatus = "completed" | "failed"
export const ApplyPatchCallOutputStatus = Schema.Literals(["completed", "failed"]).annotate({ "identifier": "ApplyPatchCallOutputStatus" })
export type MCPToolCallStatus = "in_progress" | "completed" | "incomplete" | "calling" | "failed"
export const MCPToolCallStatus = Schema.Literals(["in_progress", "completed", "incomplete", "calling", "failed"]).annotate({ "identifier": "MCPToolCallStatus" })
export type DetailEnum = "low" | "high" | "auto"
export const DetailEnum = Schema.Literals(["low", "high", "auto"]).annotate({ "identifier": "DetailEnum" })
export type FunctionCallItemStatus = "in_progress" | "completed" | "incomplete"
export const FunctionCallItemStatus = Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "identifier": "FunctionCallItemStatus" })
export type InputTextContentParam = { readonly "type": "input_text", readonly "text": string, readonly [x: string]: unknown }
export const InputTextContentParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_text").annotate({ "description": "The type of the input item. Always \`input_text\`.", "default": "input_text" }), "text": Schema.String.annotate({ "description": "The text input to the model." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input text", "description": "A text input to the model.", "identifier": "InputTextContentParam" })
export type InputFileContentParam = { readonly "type": "input_file", readonly "file_id"?: string | null, readonly "filename"?: string | null, readonly "file_data"?: string | null, readonly "file_url"?: string | null, readonly [x: string]: unknown }
export const InputFileContentParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_file").annotate({ "description": "The type of the input item. Always \`input_file\`.", "default": "input_file" }), "file_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the file to be sent to the model." }), Schema.Null])), "filename": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The name of the file to be sent to the model." }), Schema.Null])), "file_data": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The base64-encoded data of the file to be sent to the model." }), Schema.Null])), "file_url": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The URL of the file to be sent to the model." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input file", "description": "A file input to the model.", "identifier": "InputFileContentParam" })
export type CompactionSummaryItemParam = { readonly "id"?: string | null, readonly "type": "compaction", readonly "encrypted_content": string, readonly [x: string]: unknown }
export const CompactionSummaryItemParam = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the compaction item." }), Schema.Null])), "type": Schema.Literal("compaction").annotate({ "description": "The type of the item. Always \`compaction\`.", "default": "compaction" }), "encrypted_content": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Compaction item", "description": "A compaction item generated by the [\`v1/responses/compact\` API](https://platform.openai.com/docs/api-reference/responses/compact).", "identifier": "CompactionSummaryItemParam" })
export type FunctionShellActionParam = { readonly "commands": ReadonlyArray<string>, readonly "timeout_ms"?: number | null, readonly "max_output_length"?: number | null, readonly [x: string]: unknown }
export const FunctionShellActionParam = Schema.StructWithRest(Schema.Struct({ "commands": Schema.Array(Schema.String).annotate({ "description": "Ordered shell commands for the execution environment to run." }), "timeout_ms": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "Maximum wall-clock time in milliseconds to allow the shell commands to run." }).check(Schema.isInt()), Schema.Null])), "max_output_length": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "Maximum number of UTF-8 characters to capture from combined stdout and stderr output." }).check(Schema.isInt()), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell action", "description": "Commands and limits describing how to run the shell tool call.", "identifier": "FunctionShellActionParam" })
export type FunctionShellCallItemStatus = "in_progress" | "completed" | "incomplete"
export const FunctionShellCallItemStatus = Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "title": "Shell call status", "description": "Status values reported for shell tool calls.", "identifier": "FunctionShellCallItemStatus" })
export type FunctionShellCallOutputTimeoutOutcomeParam = { readonly "type": "timeout", readonly [x: string]: unknown }
export const FunctionShellCallOutputTimeoutOutcomeParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("timeout").annotate({ "description": "The outcome type. Always \`timeout\`.", "default": "timeout" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell call timeout outcome", "description": "Indicates that the shell call exceeded its configured time limit.", "identifier": "FunctionShellCallOutputTimeoutOutcomeParam" })
export type FunctionShellCallOutputExitOutcomeParam = { readonly "type": "exit", readonly "exit_code": number, readonly [x: string]: unknown }
export const FunctionShellCallOutputExitOutcomeParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("exit").annotate({ "description": "The outcome type. Always \`exit\`.", "default": "exit" }), "exit_code": Schema.Number.annotate({ "description": "The exit code returned by the shell process." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell call exit outcome", "description": "Indicates that the shell commands finished and returned an exit code.", "identifier": "FunctionShellCallOutputExitOutcomeParam" })
export type ApplyPatchCallStatusParam = "in_progress" | "completed"
export const ApplyPatchCallStatusParam = Schema.Literals(["in_progress", "completed"]).annotate({ "title": "Apply patch call status", "description": "Status values reported for apply_patch tool calls.", "identifier": "ApplyPatchCallStatusParam" })
export type ApplyPatchCreateFileOperationParam = { readonly "type": "create_file", readonly "path": string, readonly "diff": string, readonly [x: string]: unknown }
export const ApplyPatchCreateFileOperationParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("create_file").annotate({ "description": "The operation type. Always \`create_file\`.", "default": "create_file" }), "path": Schema.String.annotate({ "description": "Path of the file to create relative to the workspace root." }), "diff": Schema.String.annotate({ "description": "Unified diff content to apply when creating the file." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch create file operation", "description": "Instruction for creating a new file via the apply_patch tool.", "identifier": "ApplyPatchCreateFileOperationParam" })
export type ApplyPatchDeleteFileOperationParam = { readonly "type": "delete_file", readonly "path": string, readonly [x: string]: unknown }
export const ApplyPatchDeleteFileOperationParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("delete_file").annotate({ "description": "The operation type. Always \`delete_file\`.", "default": "delete_file" }), "path": Schema.String.annotate({ "description": "Path of the file to delete relative to the workspace root." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch delete file operation", "description": "Instruction for deleting an existing file via the apply_patch tool.", "identifier": "ApplyPatchDeleteFileOperationParam" })
export type ApplyPatchUpdateFileOperationParam = { readonly "type": "update_file", readonly "path": string, readonly "diff": string, readonly [x: string]: unknown }
export const ApplyPatchUpdateFileOperationParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("update_file").annotate({ "description": "The operation type. Always \`update_file\`.", "default": "update_file" }), "path": Schema.String.annotate({ "description": "Path of the file to update relative to the workspace root." }), "diff": Schema.String.annotate({ "description": "Unified diff content to apply to the existing file." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch update file operation", "description": "Instruction for updating an existing file via the apply_patch tool.", "identifier": "ApplyPatchUpdateFileOperationParam" })
export type ApplyPatchCallOutputStatusParam = "completed" | "failed"
export const ApplyPatchCallOutputStatusParam = Schema.Literals(["completed", "failed"]).annotate({ "title": "Apply patch call output status", "description": "Outcome values reported for apply_patch tool call outputs.", "identifier": "ApplyPatchCallOutputStatusParam" })
export type ItemReferenceParam = { readonly "type"?: "item_reference" | null, readonly "id": string, readonly [x: string]: unknown }
export const ItemReferenceParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Union([Schema.Literal("item_reference").annotate({ "description": "The type of item to reference. Always \`item_reference\`.", "default": "item_reference" }), Schema.Null])), "id": Schema.String.annotate({ "description": "The ID of the item to reference." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Item reference", "description": "An internal identifier for an item to reference.", "identifier": "ItemReferenceParam" })
export type ConversationResource = { readonly "id": string, readonly "object": "conversation", readonly "metadata": unknown, readonly "created_at": number, readonly [x: string]: unknown }
export const ConversationResource = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the conversation." }), "object": Schema.Literal("conversation").annotate({ "description": "The object type, which is always \`conversation\`.", "default": "conversation" }), "metadata": Schema.Unknown.annotate({ "description": "Set of 16 key-value pairs that can be attached to an object. This can be         useful for storing additional information about the object in a structured         format, and querying for objects via API or the dashboard.\\n        Keys are strings with a maximum length of 64 characters. Values are strings         with a maximum length of 512 characters." }), "created_at": Schema.Number.annotate({ "description": "The time at which the conversation was created, measured in seconds since the Unix epoch." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ConversationResource" })
export type FunctionTool = { readonly "type": "function", readonly "name": string, readonly "description"?: string | null, readonly "parameters": { readonly [x: string]: unknown } | null, readonly "strict": boolean | null, readonly [x: string]: unknown }
export const FunctionTool = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("function").annotate({ "description": "The type of the function tool. Always \`function\`.", "default": "function" }), "name": Schema.String.annotate({ "description": "The name of the function to call." }), "description": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "A description of the function. Used by the model to determine whether or not to call the function." }), Schema.Null])), "parameters": Schema.Union([Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "A JSON schema object describing the parameters of the function." }), Schema.Null]), "strict": Schema.Union([Schema.Boolean.annotate({ "description": "Whether to enforce strict parameter validation. Default \`true\`." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function", "description": "Defines a function in your own code the model can choose to call. Learn more about [function calling](https://platform.openai.com/docs/guides/function-calling).", "identifier": "FunctionTool" })
export type RankerVersionType = "auto" | "default-2024-11-15"
export const RankerVersionType = Schema.Literals(["auto", "default-2024-11-15"]).annotate({ "identifier": "RankerVersionType" })
export type HybridSearchOptions = { readonly "embedding_weight": number, readonly "text_weight": number, readonly [x: string]: unknown }
export const HybridSearchOptions = Schema.StructWithRest(Schema.Struct({ "embedding_weight": Schema.Number.annotate({ "description": "The weight of the embedding in the reciprocal ranking fusion." }).check(Schema.isFinite()), "text_weight": Schema.Number.annotate({ "description": "The weight of the text in the reciprocal ranking fusion." }).check(Schema.isFinite()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "HybridSearchOptions" })
export type ComputerEnvironment = "windows" | "mac" | "linux" | "ubuntu" | "browser"
export const ComputerEnvironment = Schema.Literals(["windows", "mac", "linux", "ubuntu", "browser"]).annotate({ "identifier": "ComputerEnvironment" })
export type ContainerMemoryLimit = "1g" | "4g" | "16g" | "64g"
export const ContainerMemoryLimit = Schema.Literals(["1g", "4g", "16g", "64g"]).annotate({ "identifier": "ContainerMemoryLimit" })
export type InputFidelity = "high" | "low"
export const InputFidelity = Schema.Literals(["high", "low"]).annotate({ "description": "Control how much effort the model will exert to match the style and features, especially facial features, of input images. This parameter is only supported for \`gpt-image-1\`. Unsupported for \`gpt-image-1-mini\`. Supports \`high\` and \`low\`. Defaults to \`low\`.", "identifier": "InputFidelity" })
export type LocalShellToolParam = { readonly "type": "local_shell", readonly [x: string]: unknown }
export const LocalShellToolParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("local_shell").annotate({ "description": "The type of the local shell tool. Always \`local_shell\`.", "default": "local_shell" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Local shell tool", "description": "A tool that allows the model to execute shell commands in a local environment.", "identifier": "LocalShellToolParam" })
export type FunctionShellToolParam = { readonly "type": "shell", readonly [x: string]: unknown }
export const FunctionShellToolParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("shell").annotate({ "description": "The type of the shell tool. Always \`shell\`.", "default": "shell" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell tool", "description": "A tool that allows the model to execute shell commands.", "identifier": "FunctionShellToolParam" })
export type CustomTextFormatParam = { readonly "type": "text", readonly [x: string]: unknown }
export const CustomTextFormatParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("text").annotate({ "description": "Unconstrained text format. Always \`text\`.", "default": "text" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Text format", "description": "Unconstrained free-form text.", "identifier": "CustomTextFormatParam" })
export type GrammarSyntax1 = "lark" | "regex"
export const GrammarSyntax1 = Schema.Literals(["lark", "regex"]).annotate({ "identifier": "GrammarSyntax1" })
export type ApproximateLocation = { readonly "type": "approximate", readonly "country"?: string | null, readonly "region"?: string | null, readonly "city"?: string | null, readonly "timezone"?: string | null, readonly [x: string]: unknown }
export const ApproximateLocation = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("approximate").annotate({ "description": "The type of location approximation. Always \`approximate\`.", "default": "approximate" }), "country": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. \`US\`." }), Schema.Null])), "region": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Free text input for the region of the user, e.g. \`California\`." }), Schema.Null])), "city": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Free text input for the city of the user, e.g. \`San Francisco\`." }), Schema.Null])), "timezone": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. \`America/Los_Angeles\`." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ApproximateLocation" })
export type SearchContextSize = "low" | "medium" | "high"
export const SearchContextSize = Schema.Literals(["low", "medium", "high"]).annotate({ "identifier": "SearchContextSize" })
export type ApplyPatchToolParam = { readonly "type": "apply_patch", readonly [x: string]: unknown }
export const ApplyPatchToolParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("apply_patch").annotate({ "description": "The type of the tool. Always \`apply_patch\`.", "default": "apply_patch" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch tool", "description": "Allows the assistant to create, delete, or update files using unified diffs.", "identifier": "ApplyPatchToolParam" })
export type ImageGenOutputTokensDetails = { readonly "image_tokens": number, readonly "text_tokens": number, readonly [x: string]: unknown }
export const ImageGenOutputTokensDetails = Schema.StructWithRest(Schema.Struct({ "image_tokens": Schema.Number.annotate({ "description": "The number of image output tokens generated by the model." }).check(Schema.isInt()), "text_tokens": Schema.Number.annotate({ "description": "The number of text output tokens generated by the model." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Image generation output token details", "description": "The output token details for the image generation.", "identifier": "ImageGenOutputTokensDetails" })
export type ImageGenInputUsageDetails = { readonly "text_tokens": number, readonly "image_tokens": number, readonly [x: string]: unknown }
export const ImageGenInputUsageDetails = Schema.StructWithRest(Schema.Struct({ "text_tokens": Schema.Number.annotate({ "description": "The number of text tokens in the input prompt." }).check(Schema.isInt()), "image_tokens": Schema.Number.annotate({ "description": "The number of image tokens in the input prompt." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input usage details", "description": "The input tokens detailed information for the image generation.", "identifier": "ImageGenInputUsageDetails" })
export type SpecificApplyPatchParam = { readonly "type": "apply_patch", readonly [x: string]: unknown }
export const SpecificApplyPatchParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("apply_patch").annotate({ "description": "The tool to call. Always \`apply_patch\`.", "default": "apply_patch" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Specific apply patch tool choice", "description": "Forces the model to call the apply_patch tool when executing a tool call.", "identifier": "SpecificApplyPatchParam" })
export type SpecificFunctionShellParam = { readonly "type": "shell", readonly [x: string]: unknown }
export const SpecificFunctionShellParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("shell").annotate({ "description": "The tool to call. Always \`shell\`.", "default": "shell" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Specific shell tool choice", "description": "Forces the model to call the shell tool when a tool call is required.", "identifier": "SpecificFunctionShellParam" })
export type ConversationParam_2 = { readonly "id": string, readonly [x: string]: unknown }
export const ConversationParam_2 = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the conversation." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Conversation object", "description": "The conversation that this response belongs to.", "identifier": "ConversationParam-2" })
export type CompactionBody = { readonly "type": "compaction", readonly "id": string, readonly "encrypted_content": string, readonly "created_by"?: string, readonly [x: string]: unknown }
export const CompactionBody = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("compaction").annotate({ "description": "The type of the item. Always \`compaction\`.", "default": "compaction" }), "id": Schema.String.annotate({ "description": "The unique ID of the compaction item." }), "encrypted_content": Schema.String, "created_by": Schema.optionalKey(Schema.String) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Compaction item", "description": "A compaction item generated by the [\`v1/responses/compact\` API](https://platform.openai.com/docs/api-reference/responses/compact).", "identifier": "CompactionBody" })
export type Conversation_2 = { readonly "id": string, readonly [x: string]: unknown }
export const Conversation_2 = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the conversation." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Conversation", "description": "The conversation that this response belongs to. Input items and output items from this response are automatically added to this conversation.", "identifier": "Conversation-2" })
export type DeletedConversationResource = { readonly "object": "conversation.deleted", readonly "deleted": boolean, readonly "id": string, readonly [x: string]: unknown }
export const DeletedConversationResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("conversation.deleted").annotate({ "default": "conversation.deleted" }), "deleted": Schema.Boolean, "id": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "DeletedConversationResource" })
export type OrderEnum = "asc" | "desc"
export const OrderEnum = Schema.Literals(["asc", "desc"]).annotate({ "identifier": "OrderEnum" })
export type VideoModel = string | "sora-2" | "sora-2-pro" | "sora-2-2025-10-06" | "sora-2-pro-2025-10-06" | "sora-2-2025-12-08"
export const VideoModel = Schema.Union([Schema.String, Schema.Literals(["sora-2", "sora-2-pro", "sora-2-2025-10-06", "sora-2-pro-2025-10-06", "sora-2-2025-12-08"])]).annotate({ "identifier": "VideoModel" })
export type VideoStatus = "queued" | "in_progress" | "completed" | "failed"
export const VideoStatus = Schema.Literals(["queued", "in_progress", "completed", "failed"]).annotate({ "identifier": "VideoStatus" })
export type VideoSize = "720x1280" | "1280x720" | "1024x1792" | "1792x1024"
export const VideoSize = Schema.Literals(["720x1280", "1280x720", "1024x1792", "1792x1024"]).annotate({ "identifier": "VideoSize" })
export type VideoSeconds = "4" | "8" | "12"
export const VideoSeconds = Schema.Literals(["4", "8", "12"]).annotate({ "identifier": "VideoSeconds" })
export type Error_2 = { readonly "code": string, readonly "message": string, readonly [x: string]: unknown }
export const Error_2 = Schema.StructWithRest(Schema.Struct({ "code": Schema.String, "message": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "Error-2" })
export type DeletedVideoResource = { readonly "object": "video.deleted", readonly "deleted": boolean, readonly "id": string, readonly [x: string]: unknown }
export const DeletedVideoResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("video.deleted").annotate({ "description": "The object type that signals the deletion response.", "default": "video.deleted" }), "deleted": Schema.Boolean.annotate({ "description": "Indicates that the video resource was deleted." }), "id": Schema.String.annotate({ "description": "Identifier of the deleted video." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Deleted video response", "description": "Confirmation payload returned after deleting a video.", "identifier": "DeletedVideoResource" })
export type VideoContentVariant = "video" | "thumbnail" | "spritesheet"
export const VideoContentVariant = Schema.Literals(["video", "thumbnail", "spritesheet"]).annotate({ "identifier": "VideoContentVariant" })
export type CreateVideoRemixBody = { readonly "prompt": string, readonly [x: string]: unknown }
export const CreateVideoRemixBody = Schema.StructWithRest(Schema.Struct({ "prompt": Schema.String.annotate({ "description": "Updated text prompt that directs the remix generation." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Create video remix request", "description": "Parameters for remixing an existing generated video.", "identifier": "CreateVideoRemixBody" })
export type TruncationEnum = "auto" | "disabled"
export const TruncationEnum = Schema.Literals(["auto", "disabled"]).annotate({ "identifier": "TruncationEnum" })
export type TokenCountsResource = { readonly "object": "response.input_tokens", readonly "input_tokens": number, readonly [x: string]: unknown }
export const TokenCountsResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("response.input_tokens").annotate({ "default": "response.input_tokens" }), "input_tokens": Schema.Number.check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Token counts", "identifier": "TokenCountsResource" })
export type ChatkitWorkflowTracing = { readonly "enabled": boolean, readonly [x: string]: unknown }
export const ChatkitWorkflowTracing = Schema.StructWithRest(Schema.Struct({ "enabled": Schema.Boolean.annotate({ "description": "Indicates whether tracing is enabled." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tracing Configuration", "description": "Controls diagnostic tracing during the session.", "identifier": "ChatkitWorkflowTracing" })
export type ChatSessionRateLimits = { readonly "max_requests_per_1_minute": number, readonly [x: string]: unknown }
export const ChatSessionRateLimits = Schema.StructWithRest(Schema.Struct({ "max_requests_per_1_minute": Schema.Number.annotate({ "description": "Maximum allowed requests per one-minute window." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Rate limits", "description": "Active per-minute request limit for the session.", "identifier": "ChatSessionRateLimits" })
export type ChatSessionStatus = "active" | "expired" | "cancelled"
export const ChatSessionStatus = Schema.Literals(["active", "expired", "cancelled"]).annotate({ "identifier": "ChatSessionStatus" })
export type ChatSessionAutomaticThreadTitling = { readonly "enabled": boolean, readonly [x: string]: unknown }
export const ChatSessionAutomaticThreadTitling = Schema.StructWithRest(Schema.Struct({ "enabled": Schema.Boolean.annotate({ "description": "Whether automatic thread titling is enabled." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Automatic thread titling", "description": "Automatic thread title preferences for the session.", "identifier": "ChatSessionAutomaticThreadTitling" })
export type ChatSessionFileUpload = { readonly "enabled": boolean, readonly "max_file_size": number | null, readonly "max_files": number | null, readonly [x: string]: unknown }
export const ChatSessionFileUpload = Schema.StructWithRest(Schema.Struct({ "enabled": Schema.Boolean.annotate({ "description": "Indicates if uploads are enabled for the session." }), "max_file_size": Schema.Union([Schema.Number.annotate({ "description": "Maximum upload size in megabytes." }).check(Schema.isInt()), Schema.Null]), "max_files": Schema.Union([Schema.Number.annotate({ "description": "Maximum number of uploads allowed during the session." }).check(Schema.isInt()), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File upload settings", "description": "Upload permissions and limits applied to the session.", "identifier": "ChatSessionFileUpload" })
export type ChatSessionHistory = { readonly "enabled": boolean, readonly "recent_threads": number | null, readonly [x: string]: unknown }
export const ChatSessionHistory = Schema.StructWithRest(Schema.Struct({ "enabled": Schema.Boolean.annotate({ "description": "Indicates if chat history is persisted for the session." }), "recent_threads": Schema.Union([Schema.Number.annotate({ "description": "Number of prior threads surfaced in history views. Defaults to null when all history is retained." }).check(Schema.isInt()), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "History settings", "description": "History retention preferences returned for the session.", "identifier": "ChatSessionHistory" })
export type WorkflowTracingParam = { readonly "enabled"?: boolean, readonly [x: string]: unknown }
export const WorkflowTracingParam = Schema.StructWithRest(Schema.Struct({ "enabled": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Whether tracing is enabled during the session. Defaults to true." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tracing Configuration", "description": "Controls diagnostic tracing during the session.", "identifier": "WorkflowTracingParam" })
export type ExpiresAfterParam = { readonly "anchor": "created_at", readonly "seconds": number, readonly [x: string]: unknown }
export const ExpiresAfterParam = Schema.StructWithRest(Schema.Struct({ "anchor": Schema.Literal("created_at").annotate({ "description": "Base timestamp used to calculate expiration. Currently fixed to \`created_at\`.", "default": "created_at" }), "seconds": Schema.Number.annotate({ "description": "Number of seconds after the anchor when the session expires." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Expiration overrides", "description": "Controls when the session expires relative to an anchor timestamp.", "identifier": "ExpiresAfterParam" })
export type RateLimitsParam = { readonly "max_requests_per_1_minute"?: number, readonly [x: string]: unknown }
export const RateLimitsParam = Schema.StructWithRest(Schema.Struct({ "max_requests_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "Maximum number of requests allowed per minute for the session. Defaults to 10." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Rate limit overrides", "description": "Controls request rate limits for the session.", "identifier": "RateLimitsParam" })
export type AutomaticThreadTitlingParam = { readonly "enabled"?: boolean, readonly [x: string]: unknown }
export const AutomaticThreadTitlingParam = Schema.StructWithRest(Schema.Struct({ "enabled": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Enable automatic thread title generation. Defaults to true." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Automatic thread titling configuration", "description": "Controls whether ChatKit automatically generates thread titles.", "identifier": "AutomaticThreadTitlingParam" })
export type FileUploadParam = { readonly "enabled"?: boolean, readonly "max_file_size"?: number, readonly "max_files"?: number, readonly [x: string]: unknown }
export const FileUploadParam = Schema.StructWithRest(Schema.Struct({ "enabled": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Enable uploads for this session. Defaults to false." })), "max_file_size": Schema.optionalKey(Schema.Number.annotate({ "description": "Maximum size in megabytes for each uploaded file. Defaults to 512 MB, which is the maximum allowable size." }).check(Schema.isInt())), "max_files": Schema.optionalKey(Schema.Number.annotate({ "description": "Maximum number of files that can be uploaded to the session. Defaults to 10." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File upload configuration", "description": "Controls whether users can upload files.", "identifier": "FileUploadParam" })
export type HistoryParam = { readonly "enabled"?: boolean, readonly "recent_threads"?: number, readonly [x: string]: unknown }
export const HistoryParam = Schema.StructWithRest(Schema.Struct({ "enabled": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Enables chat users to access previous ChatKit threads. Defaults to true." })), "recent_threads": Schema.optionalKey(Schema.Number.annotate({ "description": "Number of recent ChatKit threads users have access to. Defaults to unlimited when unset." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Chat history configuration", "description": "Controls how much historical context is retained for the session.", "identifier": "HistoryParam" })
export type UserMessageInputText = { readonly "type": "input_text", readonly "text": string, readonly [x: string]: unknown }
export const UserMessageInputText = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_text").annotate({ "description": "Type discriminator that is always \`input_text\`.", "default": "input_text" }), "text": Schema.String.annotate({ "description": "Plain-text content supplied by the user." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "User message input", "description": "Text block that a user contributed to the thread.", "identifier": "UserMessageInputText" })
export type UserMessageQuotedText = { readonly "type": "quoted_text", readonly "text": string, readonly [x: string]: unknown }
export const UserMessageQuotedText = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("quoted_text").annotate({ "description": "Type discriminator that is always \`quoted_text\`.", "default": "quoted_text" }), "text": Schema.String.annotate({ "description": "Quoted text content." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "User message quoted text", "description": "Quoted snippet that the user referenced in their message.", "identifier": "UserMessageQuotedText" })
export type AttachmentType = "image" | "file"
export const AttachmentType = Schema.Literals(["image", "file"]).annotate({ "identifier": "AttachmentType" })
export type ToolChoice = { readonly "id": string, readonly [x: string]: unknown }
export const ToolChoice = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the requested tool." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tool choice", "description": "Tool selection that the assistant should honor when executing the item.", "identifier": "ToolChoice" })
export type FileAnnotationSource = { readonly "type": "file", readonly "filename": string, readonly [x: string]: unknown }
export const FileAnnotationSource = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file").annotate({ "description": "Type discriminator that is always \`file\`.", "default": "file" }), "filename": Schema.String.annotate({ "description": "Filename referenced by the annotation." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File annotation source", "description": "Attachment source referenced by an annotation.", "identifier": "FileAnnotationSource" })
export type UrlAnnotationSource = { readonly "type": "url", readonly "url": string, readonly [x: string]: unknown }
export const UrlAnnotationSource = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("url").annotate({ "description": "Type discriminator that is always \`url\`.", "default": "url" }), "url": Schema.String.annotate({ "description": "URL referenced by the annotation." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "URL annotation source", "description": "URL backing an annotation entry.", "identifier": "UrlAnnotationSource" })
export type WidgetMessageItem = { readonly "id": string, readonly "object": "chatkit.thread_item", readonly "created_at": number, readonly "thread_id": string, readonly "type": "chatkit.widget", readonly "widget": string, readonly [x: string]: unknown }
export const WidgetMessageItem = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the thread item." }), "object": Schema.Literal("chatkit.thread_item").annotate({ "description": "Type discriminator that is always \`chatkit.thread_item\`.", "default": "chatkit.thread_item" }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." }).check(Schema.isInt()), "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }), "type": Schema.Literal("chatkit.widget").annotate({ "description": "Type discriminator that is always \`chatkit.widget\`.", "default": "chatkit.widget" }), "widget": Schema.String.annotate({ "description": "Serialized widget payload rendered in the UI." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Widget message", "description": "Thread item that renders a widget payload.", "identifier": "WidgetMessageItem" })
export type ClientToolCallStatus = "in_progress" | "completed"
export const ClientToolCallStatus = Schema.Literals(["in_progress", "completed"]).annotate({ "identifier": "ClientToolCallStatus" })
export type TaskType = "custom" | "thought"
export const TaskType = Schema.Literals(["custom", "thought"]).annotate({ "identifier": "TaskType" })
export type ActiveStatus = { readonly "type": "active", readonly [x: string]: unknown }
export const ActiveStatus = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("active").annotate({ "description": "Status discriminator that is always \`active\`.", "default": "active" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Active thread status", "description": "Indicates that a thread is active.", "identifier": "ActiveStatus" })
export type LockedStatus = { readonly "type": "locked", readonly "reason": string | null, readonly [x: string]: unknown }
export const LockedStatus = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("locked").annotate({ "description": "Status discriminator that is always \`locked\`.", "default": "locked" }), "reason": Schema.Union([Schema.String.annotate({ "description": "Reason that the thread was locked. Defaults to null when no reason is recorded." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Locked thread status", "description": "Indicates that a thread is locked and cannot accept new input.", "identifier": "LockedStatus" })
export type ClosedStatus = { readonly "type": "closed", readonly "reason": string | null, readonly [x: string]: unknown }
export const ClosedStatus = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("closed").annotate({ "description": "Status discriminator that is always \`closed\`.", "default": "closed" }), "reason": Schema.Union([Schema.String.annotate({ "description": "Reason that the thread was closed. Defaults to null when no reason is recorded." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Closed thread status", "description": "Indicates that a thread has been closed.", "identifier": "ClosedStatus" })
export type DeletedThreadResource = { readonly "id": string, readonly "object": "chatkit.thread.deleted", readonly "deleted": boolean, readonly [x: string]: unknown }
export const DeletedThreadResource = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the deleted thread." }), "object": Schema.Literal("chatkit.thread.deleted").annotate({ "description": "Type discriminator that is always \`chatkit.thread.deleted\`.", "default": "chatkit.thread.deleted" }), "deleted": Schema.Boolean.annotate({ "description": "Indicates that the thread has been deleted." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Deleted thread", "description": "Confirmation payload returned after deleting a thread.", "identifier": "DeletedThreadResource" })
export type RealtimeConnectParams = { readonly "model"?: string, readonly "call_id"?: string, readonly [x: string]: unknown }
export const RealtimeConnectParams = Schema.StructWithRest(Schema.Struct({ "model": Schema.optionalKey(Schema.String), "call_id": Schema.optionalKey(Schema.String) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "RealtimeConnectParams" })
export type ModerationImageURLInput = { readonly "type": "image_url", readonly "image_url": { readonly "url": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ModerationImageURLInput = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image_url").annotate({ "description": "Always \`image_url\`." }), "image_url": Schema.StructWithRest(Schema.Struct({ "url": Schema.String.annotate({ "description": "Either a URL of the image or the base64 encoded image data.", "format": "uri" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Contains either an image URL or a data URL for a base64 encoded image." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "An object describing an image to classify.", "identifier": "ModerationImageURLInput" })
export type ModerationTextInput = { readonly "type": "text", readonly "text": string, readonly [x: string]: unknown }
export const ModerationTextInput = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("text").annotate({ "description": "Always \`text\`." }), "text": Schema.String.annotate({ "description": "A string of text to classify." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "An object describing text to classify.", "identifier": "ModerationTextInput" })
export type ComparisonFilterValueItems = string | number
export const ComparisonFilterValueItems = Schema.Union([Schema.String, Schema.Number.check(Schema.isFinite())]).annotate({ "identifier": "ComparisonFilterValueItems" })
export type FilePurpose = "assistants" | "batch" | "fine-tune" | "vision" | "user_data" | "evals"
export const FilePurpose = Schema.Literals(["assistants", "batch", "fine-tune", "vision", "user_data", "evals"]).annotate({ "description": "The intended purpose of the uploaded file. One of: - \`assistants\`: Used in the Assistants API - \`batch\`: Used in the Batch API - \`fine-tune\`: Used for fine-tuning - \`vision\`: Images used for vision fine-tuning - \`user_data\`: Flexible file type for any purpose - \`evals\`: Used for eval data sets\\n", "identifier": "FilePurpose" })
export type BatchError = { readonly "code"?: string, readonly "message"?: string, readonly "param"?: string | null, readonly "line"?: number | null, readonly [x: string]: unknown }
export const BatchError = Schema.StructWithRest(Schema.Struct({ "code": Schema.optionalKey(Schema.String.annotate({ "description": "An error code identifying the error type." })), "message": Schema.optionalKey(Schema.String.annotate({ "description": "A human-readable message providing more details about the error." })), "param": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The name of the parameter that caused the error, if applicable." }), Schema.Null])), "line": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "The line number of the input file where the error occurred, if applicable." }).check(Schema.isInt()), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "BatchError" })
export type BatchRequestCounts = { readonly "total": number, readonly "completed": number, readonly "failed": number, readonly [x: string]: unknown }
export const BatchRequestCounts = Schema.StructWithRest(Schema.Struct({ "total": Schema.Number.annotate({ "description": "Total number of requests in the batch." }).check(Schema.isInt()), "completed": Schema.Number.annotate({ "description": "Number of requests that have been completed successfully." }).check(Schema.isInt()), "failed": Schema.Number.annotate({ "description": "Number of requests that have failed." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The request counts for different statuses within the batch.", "identifier": "BatchRequestCounts" })
export type ChatModel = "gpt-5.2" | "gpt-5.2-2025-12-11" | "gpt-5.2-chat-latest" | "gpt-5.2-pro" | "gpt-5.2-pro-2025-12-11" | "gpt-5.1" | "gpt-5.1-2025-11-13" | "gpt-5.1-codex" | "gpt-5.1-mini" | "gpt-5.1-chat-latest" | "gpt-5" | "gpt-5-mini" | "gpt-5-nano" | "gpt-5-2025-08-07" | "gpt-5-mini-2025-08-07" | "gpt-5-nano-2025-08-07" | "gpt-5-chat-latest" | "gpt-4.1" | "gpt-4.1-mini" | "gpt-4.1-nano" | "gpt-4.1-2025-04-14" | "gpt-4.1-mini-2025-04-14" | "gpt-4.1-nano-2025-04-14" | "o4-mini" | "o4-mini-2025-04-16" | "o3" | "o3-2025-04-16" | "o3-mini" | "o3-mini-2025-01-31" | "o1" | "o1-2024-12-17" | "o1-preview" | "o1-preview-2024-09-12" | "o1-mini" | "o1-mini-2024-09-12" | "gpt-4o" | "gpt-4o-2024-11-20" | "gpt-4o-2024-08-06" | "gpt-4o-2024-05-13" | "gpt-4o-audio-preview" | "gpt-4o-audio-preview-2024-10-01" | "gpt-4o-audio-preview-2024-12-17" | "gpt-4o-audio-preview-2025-06-03" | "gpt-4o-mini-audio-preview" | "gpt-4o-mini-audio-preview-2024-12-17" | "gpt-4o-search-preview" | "gpt-4o-mini-search-preview" | "gpt-4o-search-preview-2025-03-11" | "gpt-4o-mini-search-preview-2025-03-11" | "chatgpt-4o-latest" | "codex-mini-latest" | "gpt-4o-mini" | "gpt-4o-mini-2024-07-18" | "gpt-4-turbo" | "gpt-4-turbo-2024-04-09" | "gpt-4-0125-preview" | "gpt-4-turbo-preview" | "gpt-4-1106-preview" | "gpt-4-vision-preview" | "gpt-4" | "gpt-4-0314" | "gpt-4-0613" | "gpt-4-32k" | "gpt-4-32k-0314" | "gpt-4-32k-0613" | "gpt-3.5-turbo" | "gpt-3.5-turbo-16k" | "gpt-3.5-turbo-0301" | "gpt-3.5-turbo-0613" | "gpt-3.5-turbo-1106" | "gpt-3.5-turbo-0125" | "gpt-3.5-turbo-16k-0613"
export const ChatModel = Schema.Literals(["gpt-5.2", "gpt-5.2-2025-12-11", "gpt-5.2-chat-latest", "gpt-5.2-pro", "gpt-5.2-pro-2025-12-11", "gpt-5.1", "gpt-5.1-2025-11-13", "gpt-5.1-codex", "gpt-5.1-mini", "gpt-5.1-chat-latest", "gpt-5", "gpt-5-mini", "gpt-5-nano", "gpt-5-2025-08-07", "gpt-5-mini-2025-08-07", "gpt-5-nano-2025-08-07", "gpt-5-chat-latest", "gpt-4.1", "gpt-4.1-mini", "gpt-4.1-nano", "gpt-4.1-2025-04-14", "gpt-4.1-mini-2025-04-14", "gpt-4.1-nano-2025-04-14", "o4-mini", "o4-mini-2025-04-16", "o3", "o3-2025-04-16", "o3-mini", "o3-mini-2025-01-31", "o1", "o1-2024-12-17", "o1-preview", "o1-preview-2024-09-12", "o1-mini", "o1-mini-2024-09-12", "gpt-4o", "gpt-4o-2024-11-20", "gpt-4o-2024-08-06", "gpt-4o-2024-05-13", "gpt-4o-audio-preview", "gpt-4o-audio-preview-2024-10-01", "gpt-4o-audio-preview-2024-12-17", "gpt-4o-audio-preview-2025-06-03", "gpt-4o-mini-audio-preview", "gpt-4o-mini-audio-preview-2024-12-17", "gpt-4o-search-preview", "gpt-4o-mini-search-preview", "gpt-4o-search-preview-2025-03-11", "gpt-4o-mini-search-preview-2025-03-11", "chatgpt-4o-latest", "codex-mini-latest", "gpt-4o-mini", "gpt-4o-mini-2024-07-18", "gpt-4-turbo", "gpt-4-turbo-2024-04-09", "gpt-4-0125-preview", "gpt-4-turbo-preview", "gpt-4-1106-preview", "gpt-4-vision-preview", "gpt-4", "gpt-4-0314", "gpt-4-0613", "gpt-4-32k", "gpt-4-32k-0314", "gpt-4-32k-0613", "gpt-3.5-turbo", "gpt-3.5-turbo-16k", "gpt-3.5-turbo-0301", "gpt-3.5-turbo-0613", "gpt-3.5-turbo-1106", "gpt-3.5-turbo-0125", "gpt-3.5-turbo-16k-0613"]).annotate({ "identifier": "ChatModel" })
export type Summary = { readonly "type": "summary_text", readonly "text": string, readonly [x: string]: unknown }
export const Summary = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("summary_text").annotate({ "description": "The type of the object. Always \`summary_text\`.", "default": "summary_text" }), "text": Schema.String.annotate({ "description": "A summary of the reasoning output from the model so far." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Summary text", "description": "A summary text from the model.", "identifier": "Summary" })
export type SubmitToolOutputsRunRequestWithoutStream = { readonly "tool_outputs": ReadonlyArray<{ readonly "tool_call_id"?: string, readonly "output"?: string, readonly [x: string]: unknown }> }
export const SubmitToolOutputsRunRequestWithoutStream = Schema.Struct({ "tool_outputs": Schema.Array(Schema.StructWithRest(Schema.Struct({ "tool_call_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the tool call in the \`required_action\` object within the run object the output is being submitted for." })), "output": Schema.optionalKey(Schema.String.annotate({ "description": "The output of the tool call to be submitted to continue the run." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "A list of tools for which the outputs are being submitted." }) }).annotate({ "identifier": "SubmitToolOutputsRunRequestWithoutStream" })
export type RunStatus = "queued" | "in_progress" | "requires_action" | "cancelling" | "cancelled" | "failed" | "completed" | "incomplete" | "expired"
export const RunStatus = Schema.Literals(["queued", "in_progress", "requires_action", "cancelling", "cancelled", "failed", "completed", "incomplete", "expired"]).annotate({ "description": "The status of the run, which can be either \`queued\`, \`in_progress\`, \`requires_action\`, \`cancelling\`, \`cancelled\`, \`failed\`, \`completed\`, \`incomplete\`, or \`expired\`.", "identifier": "RunStatus" })
export type ApiKeyList = { readonly "object"?: string, readonly "data"?: ReadonlyArray<AdminApiKey>, readonly "has_more"?: boolean, readonly "first_id"?: string, readonly "last_id"?: string, readonly [x: string]: unknown }
export const ApiKeyList = Schema.StructWithRest(Schema.Struct({ "object": Schema.optionalKey(Schema.String), "data": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<AdminApiKey> => AdminApiKey))), "has_more": Schema.optionalKey(Schema.Boolean), "first_id": Schema.optionalKey(Schema.String), "last_id": Schema.optionalKey(Schema.String) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ApiKeyList" })
export type RoleListResource = { readonly "object": "list", readonly "data": ReadonlyArray<AssignedRoleDetails>, readonly "has_more": boolean, readonly "next": string | null, readonly [x: string]: unknown }
export const RoleListResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "Always \`list\`." }), "data": Schema.Array(Schema.suspend((): Schema.Codec<AssignedRoleDetails> => AssignedRoleDetails)).annotate({ "description": "Role assignments returned in the current page." }), "has_more": Schema.Boolean.annotate({ "description": "Whether additional assignments are available when paginating." }), "next": Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Cursor to fetch the next page of results, or \`null\` when there are no more assignments." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Paginated list of roles assigned to a principal.", "identifier": "RoleListResource" })
export type AssistantsApiToolChoiceOption = "none" | "auto" | "required" | AssistantsNamedToolChoice
export const AssistantsApiToolChoiceOption = Schema.Union([Schema.Literals(["none", "auto", "required"]).annotate({ "title": "Auto", "description": "\`none\` means the model will not call any tools and instead generates a message. \`auto\` means the model can pick between generating a message or calling one or more tools. \`required\` means the model must call one or more tools before responding to the user.\\n" }), AssistantsNamedToolChoice]).annotate({ "description": "Controls which (if any) tool is called by the model.\\n\`none\` means the model will not call any tools and instead generates a message.\\n\`auto\` is the default value and means the model can pick between generating a message or calling one or more tools.\\n\`required\` means the model must call one or more tools before responding to the user.\\nSpecifying a particular tool like \`{\\"type\\": \\"file_search\\"}\` or \`{\\"type\\": \\"function\\", \\"function\\": {\\"name\\": \\"my_function\\"}}\` forces the model to call that tool.\\n", "identifier": "AssistantsApiToolChoiceOption" })
export type RealtimeTranscriptionSessionCreateResponse = { readonly "client_secret": { readonly "value": string, readonly "expires_at": number, readonly [x: string]: unknown }, readonly "modalities"?: ReadonlyArray<"text" | "audio">, readonly "input_audio_format"?: string, readonly "input_audio_transcription"?: AudioTranscription, readonly "turn_detection"?: { readonly "type"?: string, readonly "threshold"?: number, readonly "prefix_padding_ms"?: number, readonly "silence_duration_ms"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeTranscriptionSessionCreateResponse = Schema.StructWithRest(Schema.Struct({ "client_secret": Schema.StructWithRest(Schema.Struct({ "value": Schema.String.annotate({ "description": "Ephemeral key usable in client environments to authenticate connections\\nto the Realtime API. Use this in client-side environments rather than\\na standard API token, which should only be used server-side.\\n" }), "expires_at": Schema.Number.annotate({ "description": "Timestamp for when the token expires. Currently, all tokens expire\\nafter one minute.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Ephemeral key returned by the API. Only present when the session is\\ncreated on the server via REST API.\\n" }), "modalities": Schema.optionalKey(Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "The set of modalities the model can respond with. To disable audio,\\nset this to [\\"text\\"].\\n" })), "input_audio_format": Schema.optionalKey(Schema.String.annotate({ "description": "The format of input audio. Options are \`pcm16\`, \`g711_ulaw\`, or \`g711_alaw\`.\\n" })), "input_audio_transcription": Schema.optionalKey(Schema.suspend((): Schema.Codec<AudioTranscription> => AudioTranscription).annotate({ "description": "Configuration of the transcription model.\\n" })), "turn_detection": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "Type of turn detection, only \`server_vad\` is currently supported.\\n" })), "threshold": Schema.optionalKey(Schema.Number.annotate({ "description": "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\\nhigher threshold will require louder audio to activate the model, and\\nthus might perform better in noisy environments.\\n" }).check(Schema.isFinite())), "prefix_padding_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Amount of audio to include before the VAD detected speech (in\\nmilliseconds). Defaults to 300ms.\\n" }).check(Schema.isInt())), "silence_duration_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Duration of silence to detect speech stop (in milliseconds). Defaults\\nto 500ms. With shorter values the model will respond more quickly,\\nbut may jump in on short pauses from the user.\\n" }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for turn detection. Can be set to \`null\` to turn off. Server\\nVAD means that the model will detect the start and end of speech based on\\naudio volume and respond at the end of user speech.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A new Realtime transcription session configuration.\\n\\nWhen a session is created on the server via REST API, the session object\\nalso contains an ephemeral key. Default TTL for keys is 10 minutes. This\\nproperty is not present when a session is updated via the WebSocket API.\\n", "identifier": "RealtimeTranscriptionSessionCreateResponse" })
export type AuditLogActorApiKey = { readonly "id"?: string, readonly "type"?: "user" | "service_account", readonly "user"?: AuditLogActorUser, readonly "service_account"?: AuditLogActorServiceAccount, readonly [x: string]: unknown }
export const AuditLogActorApiKey = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The tracking id of the API key." })), "type": Schema.optionalKey(Schema.Literals(["user", "service_account"]).annotate({ "description": "The type of API key. Can be either \`user\` or \`service_account\`." })), "user": Schema.optionalKey(AuditLogActorUser), "service_account": Schema.optionalKey(AuditLogActorServiceAccount) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The API Key used to perform the audit logged action.", "identifier": "AuditLogActorApiKey" })
export type AuditLogActorSession = { readonly "user"?: AuditLogActorUser, readonly "ip_address"?: string, readonly [x: string]: unknown }
export const AuditLogActorSession = Schema.StructWithRest(Schema.Struct({ "user": Schema.optionalKey(Schema.suspend((): Schema.Codec<AuditLogActorUser> => AuditLogActorUser)), "ip_address": Schema.optionalKey(Schema.String.annotate({ "description": "The IP address from which the action was performed." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The session in which the audit logged action was performed.", "identifier": "AuditLogActorSession" })
export type ListCertificatesResponse = { readonly "data": ReadonlyArray<Certificate>, readonly "first_id"?: string, readonly "last_id"?: string, readonly "has_more": boolean, readonly "object": "list", readonly [x: string]: unknown }
export const ListCertificatesResponse = Schema.StructWithRest(Schema.Struct({ "data": Schema.Array(Schema.suspend((): Schema.Codec<Certificate> => Certificate)), "first_id": Schema.optionalKey(Schema.String), "last_id": Schema.optionalKey(Schema.String), "has_more": Schema.Boolean, "object": Schema.Literal("list") }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListCertificatesResponse" })
export type ChatCompletionAllowedToolsChoice = { readonly "type": "allowed_tools", readonly "allowed_tools": ChatCompletionAllowedTools, readonly [x: string]: unknown }
export const ChatCompletionAllowedToolsChoice = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("allowed_tools").annotate({ "description": "Allowed tool configuration type. Always \`allowed_tools\`." }), "allowed_tools": Schema.suspend((): Schema.Codec<ChatCompletionAllowedTools> => ChatCompletionAllowedTools) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Allowed tools", "description": "Constrains the tools available to the model to a pre-defined set.\\n", "identifier": "ChatCompletionAllowedToolsChoice" })
export type ChatCompletionMessageToolCalls = ReadonlyArray<ChatCompletionMessageToolCall | ChatCompletionMessageCustomToolCall>
export const ChatCompletionMessageToolCalls = Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionMessageToolCall> => ChatCompletionMessageToolCall), Schema.suspend((): Schema.Codec<ChatCompletionMessageCustomToolCall> => ChatCompletionMessageCustomToolCall)])).annotate({ "description": "The tool calls generated by the model, such as function calls.", "identifier": "ChatCompletionMessageToolCalls" })
export type ChatCompletionStreamResponseDelta = { readonly "content"?: string | null, readonly "function_call"?: { readonly "arguments"?: string, readonly "name"?: string, readonly [x: string]: unknown }, readonly "tool_calls"?: ReadonlyArray<ChatCompletionMessageToolCallChunk>, readonly "role"?: "developer" | "system" | "user" | "assistant" | "tool", readonly "refusal"?: string | null, readonly [x: string]: unknown }
export const ChatCompletionStreamResponseDelta = Schema.StructWithRest(Schema.Struct({ "content": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The contents of the chunk message." }), Schema.Null])), "function_call": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "arguments": Schema.optionalKey(Schema.String.annotate({ "description": "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function to call." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Deprecated and replaced by \`tool_calls\`. The name and arguments of a function that should be called, as generated by the model." })), "tool_calls": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionMessageToolCallChunk> => ChatCompletionMessageToolCallChunk))), "role": Schema.optionalKey(Schema.Literals(["developer", "system", "user", "assistant", "tool"]).annotate({ "description": "The role of the author of this message." })), "refusal": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The refusal message generated by the model." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A chat completion delta generated by streamed model responses.", "identifier": "ChatCompletionStreamResponseDelta" })
export type ChatCompletionMessageList = { readonly "object": "list", readonly "data": ReadonlyArray<{ readonly "id": string, readonly "content_parts"?: ReadonlyArray<ChatCompletionRequestMessageContentPartText | ChatCompletionRequestMessageContentPartImage> | null, readonly [x: string]: unknown }>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ChatCompletionMessageList = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of this object. It is always set to \\"list\\".\\n", "default": "list" }), "data": Schema.Array(Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier of the chat message." }), "content_parts": Schema.optionalKey(Schema.Union([Schema.Array(Schema.Union([ChatCompletionRequestMessageContentPartText, ChatCompletionRequestMessageContentPartImage])).annotate({ "description": "If a content parts array was provided, this is an array of \`text\` and \`image_url\` parts.\\nOtherwise, null.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "An array of chat completion message objects.\\n" }), "first_id": Schema.String.annotate({ "description": "The identifier of the first chat message in the data array." }), "last_id": Schema.String.annotate({ "description": "The identifier of the last chat message in the data array." }), "has_more": Schema.Boolean.annotate({ "description": "Indicates whether there are more chat messages available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ChatCompletionMessageList", "description": "An object representing a list of chat completion messages.\\n", "identifier": "ChatCompletionMessageList" })
export type ChatCompletionRequestAssistantMessageContentPart = ChatCompletionRequestMessageContentPartText | ChatCompletionRequestMessageContentPartRefusal
export const ChatCompletionRequestAssistantMessageContentPart = Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionRequestMessageContentPartText> => ChatCompletionRequestMessageContentPartText), ChatCompletionRequestMessageContentPartRefusal]).annotate({ "identifier": "ChatCompletionRequestAssistantMessageContentPart" })
export type ChatCompletionRequestDeveloperMessage = { readonly "content": string | ReadonlyArray<ChatCompletionRequestMessageContentPartText>, readonly "role": "developer", readonly "name"?: string, readonly [x: string]: unknown }
export const ChatCompletionRequestDeveloperMessage = Schema.StructWithRest(Schema.Struct({ "content": Schema.Union([Schema.String.annotate({ "title": "Text content", "description": "The contents of the developer message." }), Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionRequestMessageContentPartText> => ChatCompletionRequestMessageContentPartText)).annotate({ "title": "Array of content parts", "description": "An array of content parts with a defined type. For developer messages, only type \`text\` is supported." })]).annotate({ "description": "The contents of the developer message." }), "role": Schema.Literal("developer").annotate({ "description": "The role of the messages author, in this case \`developer\`." }), "name": Schema.optionalKey(Schema.String.annotate({ "description": "An optional name for the participant. Provides the model information to differentiate between participants of the same role." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Developer message", "description": "Developer-provided instructions that the model should follow, regardless of\\nmessages sent by the user. With o1 models and newer, \`developer\` messages\\nreplace the previous \`system\` messages.\\n", "identifier": "ChatCompletionRequestDeveloperMessage" })
export type ChatCompletionRequestSystemMessageContentPart = ChatCompletionRequestMessageContentPartText
export const ChatCompletionRequestSystemMessageContentPart = Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionRequestMessageContentPartText> => ChatCompletionRequestMessageContentPartText)]).annotate({ "identifier": "ChatCompletionRequestSystemMessageContentPart" })
export type ChatCompletionRequestToolMessageContentPart = ChatCompletionRequestMessageContentPartText
export const ChatCompletionRequestToolMessageContentPart = Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionRequestMessageContentPartText> => ChatCompletionRequestMessageContentPartText)]).annotate({ "identifier": "ChatCompletionRequestToolMessageContentPart" })
export type ChatCompletionRequestUserMessageContentPart = ChatCompletionRequestMessageContentPartText | ChatCompletionRequestMessageContentPartImage | ChatCompletionRequestMessageContentPartAudio | ChatCompletionRequestMessageContentPartFile
export const ChatCompletionRequestUserMessageContentPart = Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionRequestMessageContentPartText> => ChatCompletionRequestMessageContentPartText), Schema.suspend((): Schema.Codec<ChatCompletionRequestMessageContentPartImage> => ChatCompletionRequestMessageContentPartImage), Schema.suspend((): Schema.Codec<ChatCompletionRequestMessageContentPartAudio> => ChatCompletionRequestMessageContentPartAudio), Schema.suspend((): Schema.Codec<ChatCompletionRequestMessageContentPartFile> => ChatCompletionRequestMessageContentPartFile)]).annotate({ "identifier": "ChatCompletionRequestUserMessageContentPart" })
export type PredictionContent = { readonly "type": "content", readonly "content": string | ReadonlyArray<ChatCompletionRequestMessageContentPartText>, readonly [x: string]: unknown }
export const PredictionContent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("content").annotate({ "description": "The type of the predicted content you want to provide. This type is\\ncurrently always \`content\`.\\n" }), "content": Schema.Union([Schema.String.annotate({ "title": "Text content", "description": "The content used for a Predicted Output. This is often the\\ntext of a file you are regenerating with minor changes.\\n" }), Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionRequestMessageContentPartText> => ChatCompletionRequestMessageContentPartText)).annotate({ "title": "Array of content parts", "description": "An array of content parts with a defined type. Supported options differ based on the [model](https://platform.openai.com/docs/models) being used to generate the response. Can contain text inputs." })]).annotate({ "description": "The content that should be matched when generating a model response.\\nIf generated tokens would match this content, the entire model response\\ncan be returned much more quickly.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Static Content", "description": "Static predicted output content, such as the content of a text file that is\\nbeing regenerated.\\n", "identifier": "PredictionContent" })
export type CreateCompletionResponse = { readonly "id": string, readonly "choices": ReadonlyArray<{ readonly "finish_reason": "stop" | "length" | "content_filter", readonly "index": number, readonly "logprobs": { readonly "text_offset"?: ReadonlyArray<number>, readonly "token_logprobs"?: ReadonlyArray<number>, readonly "tokens"?: ReadonlyArray<string>, readonly "top_logprobs"?: ReadonlyArray<{ readonly [x: string]: number }>, readonly [x: string]: unknown } | null, readonly "text": string, readonly [x: string]: unknown }>, readonly "created": number, readonly "model": string, readonly "system_fingerprint"?: string, readonly "object": "text_completion", readonly "usage"?: CompletionUsage, readonly [x: string]: unknown }
export const CreateCompletionResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "A unique identifier for the completion." }), "choices": Schema.Array(Schema.StructWithRest(Schema.Struct({ "finish_reason": Schema.Literals(["stop", "length", "content_filter"]).annotate({ "description": "The reason the model stopped generating tokens. This will be \`stop\` if the model hit a natural stop point or a provided stop sequence,\\n\`length\` if the maximum number of tokens specified in the request was reached,\\nor \`content_filter\` if content was omitted due to a flag from our content filters.\\n" }), "index": Schema.Number.check(Schema.isInt()), "logprobs": Schema.Union([Schema.StructWithRest(Schema.Struct({ "text_offset": Schema.optionalKey(Schema.Array(Schema.Number.check(Schema.isInt()))), "token_logprobs": Schema.optionalKey(Schema.Array(Schema.Number.check(Schema.isFinite()))), "tokens": Schema.optionalKey(Schema.Array(Schema.String)), "top_logprobs": Schema.optionalKey(Schema.Array(Schema.Record(Schema.String, Schema.Number.check(Schema.isFinite())))) }), [Schema.Record(Schema.String, Schema.Unknown)]), Schema.Null]), "text": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The list of completion choices the model generated for the input prompt." }), "created": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the completion was created." }).check(Schema.isInt()), "model": Schema.String.annotate({ "description": "The model used for completion." }), "system_fingerprint": Schema.optionalKey(Schema.String.annotate({ "description": "This fingerprint represents the backend configuration that the model runs with.\\n\\nCan be used in conjunction with the \`seed\` request parameter to understand when backend changes have been made that might impact determinism.\\n" })), "object": Schema.Literal("text_completion").annotate({ "description": "The object type, which is always \\"text_completion\\"" }), "usage": Schema.optionalKey(Schema.suspend((): Schema.Codec<CompletionUsage> => CompletionUsage)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint).\\n", "identifier": "CreateCompletionResponse" })
export type ContainerFileListResource = { readonly "object": "list", readonly "data": ReadonlyArray<ContainerFileResource>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ContainerFileListResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be 'list'." }), "data": Schema.Array(ContainerFileResource).annotate({ "description": "A list of container files." }), "first_id": Schema.String.annotate({ "description": "The ID of the first file in the list." }), "last_id": Schema.String.annotate({ "description": "The ID of the last file in the list." }), "has_more": Schema.Boolean.annotate({ "description": "Whether there are more files available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ContainerFileListResource" })
export type ContainerListResource = { readonly "object": "list", readonly "data": ReadonlyArray<ContainerResource>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ContainerListResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be 'list'." }), "data": Schema.Array(ContainerResource).annotate({ "description": "A list of containers." }), "first_id": Schema.String.annotate({ "description": "The ID of the first container in the list." }), "last_id": Schema.String.annotate({ "description": "The ID of the last container in the list." }), "has_more": Schema.Boolean.annotate({ "description": "Whether there are more containers available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ContainerListResource" })
export type CreateEmbeddingResponse = { readonly "data": ReadonlyArray<Embedding>, readonly "model": string, readonly "object": "list", readonly "usage": { readonly "prompt_tokens": number, readonly "total_tokens": number, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const CreateEmbeddingResponse = Schema.StructWithRest(Schema.Struct({ "data": Schema.Array(Embedding).annotate({ "description": "The list of embeddings generated by the model." }), "model": Schema.String.annotate({ "description": "The name of the model used to generate the embedding." }), "object": Schema.Literal("list").annotate({ "description": "The object type, which is always \\"list\\"." }), "usage": Schema.StructWithRest(Schema.Struct({ "prompt_tokens": Schema.Number.annotate({ "description": "The number of tokens used by the prompt." }).check(Schema.isInt()), "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used by the request." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The usage information for the request." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateEmbeddingResponse" })
export type ErrorEvent = { readonly "event": "error", readonly "data": Error, readonly [x: string]: unknown }
export const ErrorEvent = Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("error"), "data": Schema.suspend((): Schema.Codec<Error> => Error) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when an [error](https://platform.openai.com/docs/guides/error-codes#api-errors) occurs. This can happen due to an internal server error or a timeout.", "identifier": "ErrorEvent" })
export type ErrorResponse = { readonly "error": Error, readonly [x: string]: unknown }
export const ErrorResponse = Schema.StructWithRest(Schema.Struct({ "error": Schema.suspend((): Schema.Codec<Error> => Error) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ErrorResponse" })
export type CreateEvalJsonlRunDataSource = { readonly "type": "jsonl", readonly "source": EvalJsonlFileContentSource | EvalJsonlFileIdSource, readonly [x: string]: unknown }
export const CreateEvalJsonlRunDataSource = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("jsonl").annotate({ "description": "The type of data source. Always \`jsonl\`.", "default": "jsonl" }), "source": Schema.Union([Schema.suspend((): Schema.Codec<EvalJsonlFileContentSource> => EvalJsonlFileContentSource), Schema.suspend((): Schema.Codec<EvalJsonlFileIdSource> => EvalJsonlFileIdSource)]).annotate({ "description": "Determines what populates the \`item\` namespace in the data source." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "JsonlRunDataSource", "description": "A JsonlRunDataSource object with that specifies a JSONL file that matches the eval \\n", "identifier": "CreateEvalJsonlRunDataSource" })
export type EvalRunOutputItem = { readonly "object": "eval.run.output_item", readonly "id": string, readonly "run_id": string, readonly "eval_id": string, readonly "created_at": number, readonly "status": string, readonly "datasource_item_id": number, readonly "datasource_item": { readonly [x: string]: unknown }, readonly "results": ReadonlyArray<EvalRunOutputItemResult>, readonly "sample": { readonly "input": ReadonlyArray<{ readonly "role": string, readonly "content": string, readonly [x: string]: unknown }>, readonly "output": ReadonlyArray<{ readonly "role"?: string, readonly "content"?: string, readonly [x: string]: unknown }>, readonly "finish_reason": string, readonly "model": string, readonly "usage": { readonly "total_tokens": number, readonly "completion_tokens": number, readonly "prompt_tokens": number, readonly "cached_tokens": number, readonly [x: string]: unknown }, readonly "error": EvalApiError, readonly "temperature": number, readonly "max_completion_tokens": number, readonly "top_p": number, readonly "seed": number, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const EvalRunOutputItem = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("eval.run.output_item").annotate({ "description": "The type of the object. Always \\"eval.run.output_item\\".", "default": "eval.run.output_item" }), "id": Schema.String.annotate({ "description": "Unique identifier for the evaluation run output item." }), "run_id": Schema.String.annotate({ "description": "The identifier of the evaluation run associated with this output item." }), "eval_id": Schema.String.annotate({ "description": "The identifier of the evaluation group." }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the evaluation run was created." }).check(Schema.isInt()), "status": Schema.String.annotate({ "description": "The status of the evaluation run." }), "datasource_item_id": Schema.Number.annotate({ "description": "The identifier for the data source item." }).check(Schema.isInt()), "datasource_item": Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "Details of the input data source item." }), "results": Schema.Array(EvalRunOutputItemResult).annotate({ "description": "A list of grader results for this output item." }), "sample": Schema.StructWithRest(Schema.Struct({ "input": Schema.Array(Schema.StructWithRest(Schema.Struct({ "role": Schema.String.annotate({ "description": "The role of the message sender (e.g., system, user, developer)." }), "content": Schema.String.annotate({ "description": "The content of the message." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "An input message." })).annotate({ "description": "An array of input messages." }), "output": Schema.Array(Schema.StructWithRest(Schema.Struct({ "role": Schema.optionalKey(Schema.String.annotate({ "description": "The role of the message (e.g. \\"system\\", \\"assistant\\", \\"user\\")." })), "content": Schema.optionalKey(Schema.String.annotate({ "description": "The content of the message." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "An array of output messages." }), "finish_reason": Schema.String.annotate({ "description": "The reason why the sample generation was finished." }), "model": Schema.String.annotate({ "description": "The model used for generating the sample." }), "usage": Schema.StructWithRest(Schema.Struct({ "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used." }).check(Schema.isInt()), "completion_tokens": Schema.Number.annotate({ "description": "The number of completion tokens generated." }).check(Schema.isInt()), "prompt_tokens": Schema.Number.annotate({ "description": "The number of prompt tokens used." }).check(Schema.isInt()), "cached_tokens": Schema.Number.annotate({ "description": "The number of tokens retrieved from cache." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Token usage details for the sample." }), "error": Schema.suspend((): Schema.Codec<EvalApiError> => EvalApiError), "temperature": Schema.Number.annotate({ "description": "The sampling temperature used." }).check(Schema.isFinite()), "max_completion_tokens": Schema.Number.annotate({ "description": "The maximum number of tokens allowed for completion." }).check(Schema.isInt()), "top_p": Schema.Number.annotate({ "description": "The top_p value used for sampling." }).check(Schema.isFinite()), "seed": Schema.Number.annotate({ "description": "The seed used for generating the sample." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A sample containing the input and output of the evaluation run." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalRunOutputItem", "description": "A schema representing an evaluation run output item.\\n", "identifier": "EvalRunOutputItem" })
export type CreateUploadRequest = { readonly "filename": string, readonly "purpose": "assistants" | "batch" | "fine-tune" | "vision", readonly "bytes": number, readonly "mime_type": string, readonly "expires_after"?: FileExpirationAfter }
export const CreateUploadRequest = Schema.Struct({ "filename": Schema.String.annotate({ "description": "The name of the file to upload.\\n" }), "purpose": Schema.Literals(["assistants", "batch", "fine-tune", "vision"]).annotate({ "description": "The intended purpose of the uploaded file.\\n\\nSee the [documentation on File purposes](https://platform.openai.com/docs/api-reference/files/create#files-create-purpose).\\n" }), "bytes": Schema.Number.annotate({ "description": "The number of bytes in the file you are uploading.\\n" }).check(Schema.isInt()), "mime_type": Schema.String.annotate({ "description": "The MIME type of the file.\\n\\nThis must fall within the supported MIME types for your file purpose. See the supported MIME types for assistants and vision.\\n" }), "expires_after": Schema.optionalKey(Schema.suspend((): Schema.Codec<FileExpirationAfter> => FileExpirationAfter)) }).annotate({ "identifier": "CreateUploadRequest" })
export type FileSearchRankingOptions = { readonly "ranker"?: FileSearchRanker, readonly "score_threshold": number, readonly [x: string]: unknown }
export const FileSearchRankingOptions = Schema.StructWithRest(Schema.Struct({ "ranker": Schema.optionalKey(Schema.suspend((): Schema.Codec<FileSearchRanker> => FileSearchRanker)), "score_threshold": Schema.Number.annotate({ "description": "The score threshold for the file search. All values must be a floating point number between 0 and 1." }).check(Schema.isFinite()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File search tool call ranking options", "description": "The ranking options for the file search. If not specified, the file search tool will use the \`auto\` ranker and a score_threshold of 0.\\n\\nSee the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\\n", "identifier": "FileSearchRankingOptions" })
export type RunStepDetailsToolCallsFileSearchRankingOptionsObject = { readonly "ranker": FileSearchRanker, readonly "score_threshold": number, readonly [x: string]: unknown }
export const RunStepDetailsToolCallsFileSearchRankingOptionsObject = Schema.StructWithRest(Schema.Struct({ "ranker": Schema.suspend((): Schema.Codec<FileSearchRanker> => FileSearchRanker), "score_threshold": Schema.Number.annotate({ "description": "The score threshold for the file search. All values must be a floating point number between 0 and 1." }).check(Schema.isFinite()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File search tool call ranking options", "description": "The ranking options for the file search.", "identifier": "RunStepDetailsToolCallsFileSearchRankingOptionsObject" })
export type FineTuneDPOMethod = { readonly "hyperparameters"?: FineTuneDPOHyperparameters, readonly [x: string]: unknown }
export const FineTuneDPOMethod = Schema.StructWithRest(Schema.Struct({ "hyperparameters": Schema.optionalKey(Schema.suspend((): Schema.Codec<FineTuneDPOHyperparameters> => FineTuneDPOHyperparameters)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for the DPO fine-tuning method.", "identifier": "FineTuneDPOMethod" })
export type FineTuneSupervisedMethod = { readonly "hyperparameters"?: FineTuneSupervisedHyperparameters, readonly [x: string]: unknown }
export const FineTuneSupervisedMethod = Schema.StructWithRest(Schema.Struct({ "hyperparameters": Schema.optionalKey(Schema.suspend((): Schema.Codec<FineTuneSupervisedHyperparameters> => FineTuneSupervisedHyperparameters)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for the supervised fine-tuning method.", "identifier": "FineTuneSupervisedMethod" })
export type ListFineTuningCheckpointPermissionResponse = { readonly "data": ReadonlyArray<FineTuningCheckpointPermission>, readonly "object": "list", readonly "first_id"?: string | null, readonly "last_id"?: string | null, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListFineTuningCheckpointPermissionResponse = Schema.StructWithRest(Schema.Struct({ "data": Schema.Array(Schema.suspend((): Schema.Codec<FineTuningCheckpointPermission> => FineTuningCheckpointPermission)), "object": Schema.Literal("list"), "first_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])), "last_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])), "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListFineTuningCheckpointPermissionResponse" })
export type ListFineTuningJobCheckpointsResponse = { readonly "data": ReadonlyArray<FineTuningJobCheckpoint>, readonly "object": "list", readonly "first_id"?: string | null, readonly "last_id"?: string | null, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListFineTuningJobCheckpointsResponse = Schema.StructWithRest(Schema.Struct({ "data": Schema.Array(Schema.suspend((): Schema.Codec<FineTuningJobCheckpoint> => FineTuningJobCheckpoint)), "object": Schema.Literal("list"), "first_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])), "last_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])), "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListFineTuningJobCheckpointsResponse" })
export type ListFineTuningJobEventsResponse = { readonly "data": ReadonlyArray<FineTuningJobEvent>, readonly "object": "list", readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListFineTuningJobEventsResponse = Schema.StructWithRest(Schema.Struct({ "data": Schema.Array(Schema.suspend((): Schema.Codec<FineTuningJobEvent> => FineTuningJobEvent)), "object": Schema.Literal("list"), "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListFineTuningJobEventsResponse" })
export type ChatCompletionFunctions = { readonly "description"?: string, readonly "name": string, readonly "parameters"?: FunctionParameters, readonly [x: string]: unknown }
export const ChatCompletionFunctions = Schema.StructWithRest(Schema.Struct({ "description": Schema.optionalKey(Schema.String.annotate({ "description": "A description of what the function does, used by the model to choose when and how to call the function." })), "name": Schema.String.annotate({ "description": "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64." }), "parameters": Schema.optionalKey(FunctionParameters) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ChatCompletionFunctions" })
export type FunctionObject = { readonly "description"?: string, readonly "name": string, readonly "parameters"?: FunctionParameters, readonly "strict"?: boolean | null, readonly [x: string]: unknown }
export const FunctionObject = Schema.StructWithRest(Schema.Struct({ "description": Schema.optionalKey(Schema.String.annotate({ "description": "A description of what the function does, used by the model to choose when and how to call the function." })), "name": Schema.String.annotate({ "description": "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64." }), "parameters": Schema.optionalKey(Schema.suspend((): Schema.Codec<FunctionParameters> => FunctionParameters)), "strict": Schema.optionalKey(Schema.Union([Schema.Boolean.annotate({ "description": "Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the \`parameters\` field. Only a subset of JSON Schema is supported when \`strict\` is \`true\`. Learn more about Structured Outputs in the [function calling guide](https://platform.openai.com/docs/guides/function-calling).", "default": false }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "FunctionObject" })
export type GroupListResource = { readonly "object": "list", readonly "data": ReadonlyArray<GroupResponse>, readonly "has_more": boolean, readonly "next": string | null, readonly [x: string]: unknown }
export const GroupListResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "Always \`list\`." }), "data": Schema.Array(GroupResponse).annotate({ "description": "Groups returned in the current page." }), "has_more": Schema.Boolean.annotate({ "description": "Whether additional groups are available when paginating." }), "next": Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Cursor to fetch the next page of results, or \`null\` if there are no more results." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Paginated list of organization groups.", "identifier": "GroupListResource" })
export type ImageEditCompletedEvent = { readonly "type": "image_edit.completed", readonly "b64_json": string, readonly "created_at": number, readonly "size": "1024x1024" | "1024x1536" | "1536x1024" | "auto", readonly "quality": "low" | "medium" | "high" | "auto", readonly "background": "transparent" | "opaque" | "auto", readonly "output_format": "png" | "webp" | "jpeg", readonly "usage": ImagesUsage, readonly [x: string]: unknown }
export const ImageEditCompletedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image_edit.completed").annotate({ "description": "The type of the event. Always \`image_edit.completed\`.\\n" }), "b64_json": Schema.String.annotate({ "description": "Base64-encoded final edited image data, suitable for rendering as an image.\\n" }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp when the event was created.\\n" }).check(Schema.isInt()), "size": Schema.Literals(["1024x1024", "1024x1536", "1536x1024", "auto"]).annotate({ "description": "The size of the edited image.\\n" }), "quality": Schema.Literals(["low", "medium", "high", "auto"]).annotate({ "description": "The quality setting for the edited image.\\n" }), "background": Schema.Literals(["transparent", "opaque", "auto"]).annotate({ "description": "The background setting for the edited image.\\n" }), "output_format": Schema.Literals(["png", "webp", "jpeg"]).annotate({ "description": "The output format for the edited image.\\n" }), "usage": ImagesUsage }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when image editing has completed and the final image is available.\\n", "identifier": "ImageEditCompletedEvent" })
export type ImageGenCompletedEvent = { readonly "type": "image_generation.completed", readonly "b64_json": string, readonly "created_at": number, readonly "size": "1024x1024" | "1024x1536" | "1536x1024" | "auto", readonly "quality": "low" | "medium" | "high" | "auto", readonly "background": "transparent" | "opaque" | "auto", readonly "output_format": "png" | "webp" | "jpeg", readonly "usage": ImagesUsage, readonly [x: string]: unknown }
export const ImageGenCompletedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image_generation.completed").annotate({ "description": "The type of the event. Always \`image_generation.completed\`.\\n" }), "b64_json": Schema.String.annotate({ "description": "Base64-encoded image data, suitable for rendering as an image.\\n" }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp when the event was created.\\n" }).check(Schema.isInt()), "size": Schema.Literals(["1024x1024", "1024x1536", "1536x1024", "auto"]).annotate({ "description": "The size of the generated image.\\n" }), "quality": Schema.Literals(["low", "medium", "high", "auto"]).annotate({ "description": "The quality setting for the generated image.\\n" }), "background": Schema.Literals(["transparent", "opaque", "auto"]).annotate({ "description": "The background setting for the generated image.\\n" }), "output_format": Schema.Literals(["png", "webp", "jpeg"]).annotate({ "description": "The output format for the generated image.\\n" }), "usage": Schema.suspend((): Schema.Codec<ImagesUsage> => ImagesUsage) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when image generation has completed and the final image is available.\\n", "identifier": "ImageGenCompletedEvent" })
export type InviteListResponse = { readonly "object": "list", readonly "data": ReadonlyArray<Invite>, readonly "first_id"?: string, readonly "last_id"?: string, readonly "has_more"?: boolean, readonly [x: string]: unknown }
export const InviteListResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The object type, which is always \`list\`" }), "data": Schema.Array(Schema.suspend((): Schema.Codec<Invite> => Invite)), "first_id": Schema.optionalKey(Schema.String.annotate({ "description": "The first \`invite_id\` in the retrieved \`list\`" })), "last_id": Schema.optionalKey(Schema.String.annotate({ "description": "The last \`invite_id\` in the retrieved \`list\`" })), "has_more": Schema.optionalKey(Schema.Boolean.annotate({ "description": "The \`has_more\` property is used for pagination to indicate there are additional results." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "InviteListResponse" })
export type RealtimeBetaServerEventConversationItemInputAudioTranscriptionDelta = { readonly "event_id": string, readonly "type": "conversation.item.input_audio_transcription.delta", readonly "item_id": string, readonly "content_index"?: number, readonly "delta"?: string, readonly "logprobs"?: ReadonlyArray<LogProbProperties> | null, readonly [x: string]: unknown }
export const RealtimeBetaServerEventConversationItemInputAudioTranscriptionDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.input_audio_transcription.delta").annotate({ "description": "The event type, must be \`conversation.item.input_audio_transcription.delta\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the item." }), "content_index": Schema.optionalKey(Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt())), "delta": Schema.optionalKey(Schema.String.annotate({ "description": "The text delta." })), "logprobs": Schema.optionalKey(Schema.Union([Schema.Array(Schema.suspend((): Schema.Codec<LogProbProperties> => LogProbProperties)).annotate({ "description": "The log probabilities of the transcription." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the text value of an input audio transcription content part is updated.\\n", "identifier": "RealtimeBetaServerEventConversationItemInputAudioTranscriptionDelta" })
export type RealtimeServerEventConversationItemInputAudioTranscriptionDelta = { readonly "event_id": string, readonly "type": "conversation.item.input_audio_transcription.delta", readonly "item_id": string, readonly "content_index"?: number, readonly "delta"?: string, readonly "logprobs"?: ReadonlyArray<LogProbProperties> | null, readonly [x: string]: unknown }
export const RealtimeServerEventConversationItemInputAudioTranscriptionDelta = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.input_audio_transcription.delta").annotate({ "description": "The event type, must be \`conversation.item.input_audio_transcription.delta\`." }), "item_id": Schema.String.annotate({ "description": "The ID of the item containing the audio that is being transcribed." }), "content_index": Schema.optionalKey(Schema.Number.annotate({ "description": "The index of the content part in the item's content array." }).check(Schema.isInt())), "delta": Schema.optionalKey(Schema.String.annotate({ "description": "The text delta." })), "logprobs": Schema.optionalKey(Schema.Union([Schema.Array(Schema.suspend((): Schema.Codec<LogProbProperties> => LogProbProperties)).annotate({ "description": "The log probabilities of the transcription. These can be enabled by configurating the session with \`\\"include\\": [\\"item.input_audio_transcription.logprobs\\"]\`. Each entry in the array corresponds a log probability of which token would be selected for this chunk of transcription. This can help to identify if it was possible there were multiple valid options for a given chunk of transcription." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when the text value of an input audio transcription content part is updated with incremental transcription results.\\n", "identifier": "RealtimeServerEventConversationItemInputAudioTranscriptionDelta" })
export type MCPListTools = { readonly "type": "mcp_list_tools", readonly "id": string, readonly "server_label": string, readonly "tools": ReadonlyArray<MCPListToolsTool>, readonly "error"?: string | null, readonly [x: string]: unknown }
export const MCPListTools = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp_list_tools").annotate({ "description": "The type of the item. Always \`mcp_list_tools\`.\\n" }), "id": Schema.String.annotate({ "description": "The unique ID of the list.\\n" }), "server_label": Schema.String.annotate({ "description": "The label of the MCP server.\\n" }), "tools": Schema.Array(MCPListToolsTool).annotate({ "description": "The tools available on the server.\\n" }), "error": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Error message if the server could not list tools.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "MCP list tools", "description": "A list of tools available on an MCP server.\\n", "identifier": "MCPListTools" })
export type RealtimeMCPListTools = { readonly "type": "mcp_list_tools", readonly "id"?: string, readonly "server_label": string, readonly "tools": ReadonlyArray<MCPListToolsTool>, readonly [x: string]: unknown }
export const RealtimeMCPListTools = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp_list_tools").annotate({ "description": "The type of the item. Always \`mcp_list_tools\`." }), "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the list." })), "server_label": Schema.String.annotate({ "description": "The label of the MCP server." }), "tools": Schema.Array(Schema.suspend((): Schema.Codec<MCPListToolsTool> => MCPListToolsTool)).annotate({ "description": "The tools available on the server." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime MCP list tools", "description": "A Realtime item listing tools available on an MCP server.\\n", "identifier": "RealtimeMCPListTools" })
export type MCPTool = { readonly "type": "mcp", readonly "server_label": string, readonly "server_url"?: string, readonly "connector_id"?: "connector_dropbox" | "connector_gmail" | "connector_googlecalendar" | "connector_googledrive" | "connector_microsoftteams" | "connector_outlookcalendar" | "connector_outlookemail" | "connector_sharepoint", readonly "authorization"?: string, readonly "server_description"?: string, readonly "headers"?: { readonly [x: string]: string } | null, readonly "allowed_tools"?: ReadonlyArray<string> | MCPToolFilter | null, readonly "require_approval"?: { readonly "always"?: MCPToolFilter, readonly "never"?: MCPToolFilter } | "always" | "never" | null, readonly [x: string]: unknown }
export const MCPTool = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp").annotate({ "description": "The type of the MCP tool. Always \`mcp\`." }), "server_label": Schema.String.annotate({ "description": "A label for this MCP server, used to identify it in tool calls.\\n" }), "server_url": Schema.optionalKey(Schema.String.annotate({ "description": "The URL for the MCP server. One of \`server_url\` or \`connector_id\` must be\\nprovided.\\n" })), "connector_id": Schema.optionalKey(Schema.Literals(["connector_dropbox", "connector_gmail", "connector_googlecalendar", "connector_googledrive", "connector_microsoftteams", "connector_outlookcalendar", "connector_outlookemail", "connector_sharepoint"]).annotate({ "description": "Identifier for service connectors, like those available in ChatGPT. One of\\n\`server_url\` or \`connector_id\` must be provided. Learn more about service\\nconnectors [here](https://platform.openai.com/docs/guides/tools-remote-mcp#connectors).\\n\\nCurrently supported \`connector_id\` values are:\\n\\n- Dropbox: \`connector_dropbox\`\\n- Gmail: \`connector_gmail\`\\n- Google Calendar: \`connector_googlecalendar\`\\n- Google Drive: \`connector_googledrive\`\\n- Microsoft Teams: \`connector_microsoftteams\`\\n- Outlook Calendar: \`connector_outlookcalendar\`\\n- Outlook Email: \`connector_outlookemail\`\\n- SharePoint: \`connector_sharepoint\`\\n" })), "authorization": Schema.optionalKey(Schema.String.annotate({ "description": "An OAuth access token that can be used with a remote MCP server, either\\nwith a custom MCP server URL or a service connector. Your application\\nmust handle the OAuth authorization flow and provide the token here.\\n" })), "server_description": Schema.optionalKey(Schema.String.annotate({ "description": "Optional description of the MCP server, used to provide more context.\\n" })), "headers": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.String).annotate({ "description": "Optional HTTP headers to send to the MCP server. Use for authentication\\nor other purposes.\\n" }), Schema.Null])), "allowed_tools": Schema.optionalKey(Schema.Union([Schema.Union([Schema.Array(Schema.String).annotate({ "title": "MCP allowed tools", "description": "A string array of allowed tool names" }), MCPToolFilter]).annotate({ "description": "List of allowed tool names or a filter object.\\n" }), Schema.Null])), "require_approval": Schema.optionalKey(Schema.Union([Schema.Union([Schema.Struct({ "always": Schema.optionalKey(Schema.suspend((): Schema.Codec<MCPToolFilter> => MCPToolFilter)), "never": Schema.optionalKey(Schema.suspend((): Schema.Codec<MCPToolFilter> => MCPToolFilter)) }).annotate({ "title": "MCP tool approval filter", "description": "Specify which of the MCP server's tools require approval. Can be\\n\`always\`, \`never\`, or a filter object associated with tools\\nthat require approval.\\n" }), Schema.Literals(["always", "never"]).annotate({ "title": "MCP tool approval setting", "description": "Specify a single approval policy for all tools. One of \`always\` or\\n\`never\`. When set to \`always\`, all tools will require approval. When\\nset to \`never\`, all tools will not require approval.\\n" })]).annotate({ "description": "Specify which of the MCP server's tools require approval.", "default": "always" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "MCP tool", "description": "Give the model access to additional tools via remote Model Context Protocol\\n(MCP) servers. [Learn more about MCP](https://platform.openai.com/docs/guides/tools-remote-mcp).\\n", "identifier": "MCPTool" })
export type TextAnnotation = MessageContentTextAnnotationsFileCitationObject | MessageContentTextAnnotationsFilePathObject
export const TextAnnotation = Schema.Union([Schema.suspend((): Schema.Codec<MessageContentTextAnnotationsFileCitationObject> => MessageContentTextAnnotationsFileCitationObject), Schema.suspend((): Schema.Codec<MessageContentTextAnnotationsFilePathObject> => MessageContentTextAnnotationsFilePathObject)]).annotate({ "identifier": "TextAnnotation" })
export type TextAnnotationDelta = MessageDeltaContentTextAnnotationsFileCitationObject | MessageDeltaContentTextAnnotationsFilePathObject
export const TextAnnotationDelta = Schema.Union([Schema.suspend((): Schema.Codec<MessageDeltaContentTextAnnotationsFileCitationObject> => MessageDeltaContentTextAnnotationsFileCitationObject), Schema.suspend((): Schema.Codec<MessageDeltaContentTextAnnotationsFilePathObject> => MessageDeltaContentTextAnnotationsFilePathObject)]).annotate({ "identifier": "TextAnnotationDelta" })
export type CreateMessageRequest = { readonly "role": "user" | "assistant", readonly "content": string | ReadonlyArray<MessageContentImageFileObject | MessageContentImageUrlObject | MessageRequestContentTextObject>, readonly "attachments"?: ReadonlyArray<{ readonly "file_id"?: string, readonly "tools"?: ReadonlyArray<AssistantToolsCode | AssistantToolsFileSearchTypeOnly>, readonly [x: string]: unknown }> | null, readonly "metadata"?: Metadata }
export const CreateMessageRequest = Schema.Struct({ "role": Schema.Literals(["user", "assistant"]).annotate({ "description": "The role of the entity that is creating the message. Allowed values include:\\n- \`user\`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.\\n- \`assistant\`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.\\n" }), "content": Schema.Union([Schema.String.annotate({ "title": "Text content", "description": "The text contents of the message." }), Schema.Array(Schema.Union([MessageContentImageFileObject, MessageContentImageUrlObject, MessageRequestContentTextObject])).annotate({ "title": "Array of content parts", "description": "An array of content parts with a defined type, each can be of type \`text\` or images can be passed with \`image_url\` or \`image_file\`. Image types are only supported on [Vision-compatible models](https://platform.openai.com/docs/models)." })]), "attachments": Schema.optionalKey(Schema.Union([Schema.Array(Schema.StructWithRest(Schema.Struct({ "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the file to attach to the message." })), "tools": Schema.optionalKey(Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<AssistantToolsCode> => AssistantToolsCode), Schema.suspend((): Schema.Codec<AssistantToolsFileSearchTypeOnly> => AssistantToolsFileSearchTypeOnly)])).annotate({ "description": "The tools to add this file to." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "A list of files attached to the message, and the tools they should be added to." }), Schema.Null])), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)) }).annotate({ "identifier": "CreateMessageRequest" })
export type EvalLogsDataSourceConfig = { readonly "type": "logs", readonly "metadata"?: Metadata, readonly "schema": { readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const EvalLogsDataSourceConfig = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("logs").annotate({ "description": "The type of data source. Always \`logs\`.", "default": "logs" }), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "schema": Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The json schema for the run data source items.\\nLearn how to build JSON schemas [here](https://json-schema.org/).\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "LogsDataSourceConfig", "description": "A LogsDataSourceConfig which specifies the metadata property of your logs query.\\nThis is usually metadata like \`usecase=chatbot\` or \`prompt-version=v2\`, etc.\\nThe schema returned by this data source config is used to defined what variables are available in your evals.\\n\`item\` and \`sample\` are both defined when using this data source config.\\n", "identifier": "EvalLogsDataSourceConfig" })
export type EvalStoredCompletionsDataSourceConfig = { readonly "type": "stored_completions", readonly "metadata"?: Metadata, readonly "schema": { readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const EvalStoredCompletionsDataSourceConfig = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("stored_completions").annotate({ "description": "The type of data source. Always \`stored_completions\`.", "default": "stored_completions" }), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "schema": Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The json schema for the run data source items.\\nLearn how to build JSON schemas [here](https://json-schema.org/).\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "StoredCompletionsDataSourceConfig", "description": "Deprecated in favor of LogsDataSourceConfig.\\n", "identifier": "EvalStoredCompletionsDataSourceConfig" })
export type EvalStoredCompletionsSource = { readonly "type": "stored_completions", readonly "metadata"?: Metadata, readonly "model"?: string | null, readonly "created_after"?: number | null, readonly "created_before"?: number | null, readonly "limit"?: number | null, readonly [x: string]: unknown }
export const EvalStoredCompletionsSource = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("stored_completions").annotate({ "description": "The type of source. Always \`stored_completions\`.", "default": "stored_completions" }), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "model": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "An optional model to filter by (e.g., 'gpt-4o')." }), Schema.Null])), "created_after": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "An optional Unix timestamp to filter items created after this time." }).check(Schema.isInt()), Schema.Null])), "created_before": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "An optional Unix timestamp to filter items created before this time." }).check(Schema.isInt()), Schema.Null])), "limit": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "An optional maximum number of items to return." }).check(Schema.isInt()), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "StoredCompletionsRunDataSource", "description": "A StoredCompletionsRunDataSource configuration describing a set of filters\\n", "identifier": "EvalStoredCompletionsSource" })
export type ModifyMessageRequest = { readonly "metadata"?: Metadata }
export const ModifyMessageRequest = Schema.Struct({ "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)) }).annotate({ "identifier": "ModifyMessageRequest" })
export type ModifyRunRequest = { readonly "metadata"?: Metadata }
export const ModifyRunRequest = Schema.Struct({ "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)) }).annotate({ "identifier": "ModifyRunRequest" })
export type ModifyThreadRequest = { readonly "tool_resources"?: { readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly "file_search"?: { readonly "vector_store_ids"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly [x: string]: unknown } | null, readonly "metadata"?: Metadata }
export const ModifyThreadRequest = Schema.Struct({ "tool_resources": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "code_interpreter": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "file_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the \`code_interpreter\` tool. There can be a maximum of 20 files associated with the tool.\\n", "default": [] })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "file_search": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "vector_store_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the \`code_interpreter\` tool requires a list of file IDs, while the \`file_search\` tool requires a list of vector store IDs.\\n" }), Schema.Null])), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)) }).annotate({ "identifier": "ModifyThreadRequest" })
export type ThreadObject = { readonly "id": string, readonly "object": "thread", readonly "created_at": number, readonly "tool_resources": { readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly "file_search"?: { readonly "vector_store_ids"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly [x: string]: unknown } | null, readonly "metadata": Metadata, readonly [x: string]: unknown }
export const ThreadObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }), "object": Schema.Literal("thread").annotate({ "description": "The object type, which is always \`thread\`." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the thread was created." }).check(Schema.isInt()), "tool_resources": Schema.Union([Schema.StructWithRest(Schema.Struct({ "code_interpreter": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "file_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the \`code_interpreter\` tool. There can be a maximum of 20 files associated with the tool.\\n", "default": [] })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "file_search": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "vector_store_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the \`code_interpreter\` tool requires a list of file IDs, while the \`file_search\` tool requires a list of vector store IDs.\\n" }), Schema.Null]), "metadata": Schema.suspend((): Schema.Codec<Metadata> => Metadata) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Thread", "description": "Represents a thread that contains [messages](https://platform.openai.com/docs/api-reference/messages).", "identifier": "ThreadObject" })
export type UpdateVectorStoreRequest = { readonly "name"?: string | null, readonly "expires_after"?: never, readonly "metadata"?: Metadata }
export const UpdateVectorStoreRequest = Schema.Struct({ "name": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "The name of the vector store." })), "expires_after": Schema.optionalKey(Schema.Never), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)) }).annotate({ "identifier": "UpdateVectorStoreRequest" })
export type UpdateConversationBody = { readonly "metadata": Metadata, readonly [x: string]: unknown }
export const UpdateConversationBody = Schema.StructWithRest(Schema.Struct({ "metadata": Schema.suspend((): Schema.Codec<Metadata> => Metadata).annotate({ "description": "Set of 16 key-value pairs that can be attached to an object. This can be         useful for storing additional information about the object in a structured         format, and querying for objects via API or the dashboard.\\n        Keys are strings with a maximum length of 64 characters. Values are strings         with a maximum length of 512 characters." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "UpdateConversationBody" })
export type ListModelsResponse = { readonly "object": "list", readonly "data": ReadonlyArray<Model>, readonly [x: string]: unknown }
export const ListModelsResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list"), "data": Schema.Array(Model) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListModelsResponse" })
export type RealtimeTranscriptionSessionCreateRequest = { readonly "turn_detection"?: { readonly "type"?: "server_vad", readonly "threshold"?: number, readonly "prefix_padding_ms"?: number, readonly "silence_duration_ms"?: number, readonly [x: string]: unknown }, readonly "input_audio_noise_reduction"?: { readonly "type"?: NoiseReductionType, readonly [x: string]: unknown }, readonly "input_audio_format"?: "pcm16" | "g711_ulaw" | "g711_alaw", readonly "input_audio_transcription"?: AudioTranscription, readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">, readonly [x: string]: unknown }
export const RealtimeTranscriptionSessionCreateRequest = Schema.StructWithRest(Schema.Struct({ "turn_detection": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("server_vad").annotate({ "description": "Type of turn detection. Only \`server_vad\` is currently supported for transcription sessions.\\n" })), "threshold": Schema.optionalKey(Schema.Number.annotate({ "description": "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\\nhigher threshold will require louder audio to activate the model, and\\nthus might perform better in noisy environments.\\n" }).check(Schema.isFinite())), "prefix_padding_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Amount of audio to include before the VAD detected speech (in\\nmilliseconds). Defaults to 300ms.\\n" }).check(Schema.isInt())), "silence_duration_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Duration of silence to detect speech stop (in milliseconds). Defaults\\nto 500ms. With shorter values the model will respond more quickly,\\nbut may jump in on short pauses from the user.\\n" }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for turn detection. Can be set to \`null\` to turn off. Server VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\\n" })), "input_audio_noise_reduction": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.suspend((): Schema.Codec<NoiseReductionType> => NoiseReductionType)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input audio noise reduction. This can be set to \`null\` to turn off.\\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\\n" })), "input_audio_format": Schema.optionalKey(Schema.Literals(["pcm16", "g711_ulaw", "g711_alaw"]).annotate({ "description": "The format of input audio. Options are \`pcm16\`, \`g711_ulaw\`, or \`g711_alaw\`.\\nFor \`pcm16\`, input audio must be 16-bit PCM at a 24kHz sample rate,\\nsingle channel (mono), and little-endian byte order.\\n", "default": "pcm16" })), "input_audio_transcription": Schema.optionalKey(Schema.suspend((): Schema.Codec<AudioTranscription> => AudioTranscription).annotate({ "description": "Configuration for input audio transcription. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\\n" })), "include": Schema.optionalKey(Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({ "description": "The set of items to include in the transcription. Current available items are:\\n\`item.input_audio_transcription.logprobs\`\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime transcription session configuration", "description": "Realtime transcription session object configuration.", "identifier": "RealtimeTranscriptionSessionCreateRequest" })
export type ListFilesResponse = { readonly "object": string, readonly "data": ReadonlyArray<OpenAIFile>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListFilesResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.String, "data": Schema.Array(OpenAIFile), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListFilesResponse" })
export type CreateImageRequest = { readonly "prompt": string, readonly "model"?: string | "gpt-image-1.5" | "dall-e-2" | "dall-e-3" | "gpt-image-1" | "gpt-image-1-mini" | null, readonly "n"?: number | null, readonly "quality"?: "standard" | "hd" | "low" | "medium" | "high" | "auto" | null, readonly "response_format"?: "url" | "b64_json" | null, readonly "output_format"?: "png" | "jpeg" | "webp" | null, readonly "output_compression"?: number | null, readonly "stream"?: boolean | null, readonly "partial_images"?: PartialImages, readonly "size"?: "auto" | "1024x1024" | "1536x1024" | "1024x1536" | "256x256" | "512x512" | "1792x1024" | "1024x1792" | null, readonly "moderation"?: "low" | "auto" | null, readonly "background"?: "transparent" | "opaque" | "auto" | null, readonly "style"?: "vivid" | "natural" | null, readonly "user"?: string, readonly [x: string]: unknown }
export const CreateImageRequest = Schema.StructWithRest(Schema.Struct({ "prompt": Schema.String.annotate({ "description": "A text description of the desired image(s). The maximum length is 32000 characters for the GPT image models, 1000 characters for \`dall-e-2\` and 4000 characters for \`dall-e-3\`." }), "model": Schema.optionalKey(Schema.Union([Schema.Union([Schema.String, Schema.Literals(["gpt-image-1.5", "dall-e-2", "dall-e-3", "gpt-image-1", "gpt-image-1-mini"])]).annotate({ "description": "The model to use for image generation. One of \`dall-e-2\`, \`dall-e-3\`, or a GPT image model (\`gpt-image-1\`, \`gpt-image-1-mini\`, \`gpt-image-1.5\`). Defaults to \`dall-e-2\` unless a parameter specific to the GPT image models is used." }), Schema.Null])), "n": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The number of images to generate. Must be between 1 and 10. For \`dall-e-3\`, only \`n=1\` is supported.", "default": 1 })), "quality": Schema.optionalKey(Schema.Union([Schema.Literal("standard"), Schema.Literal("hd"), Schema.Literal("low"), Schema.Literal("medium"), Schema.Literal("high"), Schema.Literal("auto"), Schema.Null]).annotate({ "description": "The quality of the image that will be generated.\\n\\n- \`auto\` (default value) will automatically select the best quality for the given model.\\n- \`high\`, \`medium\` and \`low\` are supported for the GPT image models.\\n- \`hd\` and \`standard\` are supported for \`dall-e-3\`.\\n- \`standard\` is the only option for \`dall-e-2\`.\\n", "default": "auto" })), "response_format": Schema.optionalKey(Schema.Union([Schema.Literal("url"), Schema.Literal("b64_json"), Schema.Null]).annotate({ "description": "The format in which generated images with \`dall-e-2\` and \`dall-e-3\` are returned. Must be one of \`url\` or \`b64_json\`. URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported for the GPT image models, which always return base64-encoded images.", "default": "url" })), "output_format": Schema.optionalKey(Schema.Union([Schema.Literal("png"), Schema.Literal("jpeg"), Schema.Literal("webp"), Schema.Null]).annotate({ "description": "The format in which the generated images are returned. This parameter is only supported for the GPT image models. Must be one of \`png\`, \`jpeg\`, or \`webp\`.", "default": "png" })), "output_compression": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The compression level (0-100%) for the generated images. This parameter is only supported for the GPT image models with the \`webp\` or \`jpeg\` output formats, and defaults to 100.", "default": 100 })), "stream": Schema.optionalKey(Schema.Union([Schema.Boolean, Schema.Null]).annotate({ "description": "Generate the image in streaming mode. Defaults to \`false\`. See the\\n[Image generation guide](https://platform.openai.com/docs/guides/image-generation) for more information.\\nThis parameter is only supported for the GPT image models.\\n", "default": false })), "partial_images": Schema.optionalKey(Schema.suspend((): Schema.Codec<PartialImages> => PartialImages)), "size": Schema.optionalKey(Schema.Union([Schema.Literal("auto"), Schema.Literal("1024x1024"), Schema.Literal("1536x1024"), Schema.Literal("1024x1536"), Schema.Literal("256x256"), Schema.Literal("512x512"), Schema.Literal("1792x1024"), Schema.Literal("1024x1792"), Schema.Null]).annotate({ "description": "The size of the generated images. Must be one of \`1024x1024\`, \`1536x1024\` (landscape), \`1024x1536\` (portrait), or \`auto\` (default value) for the GPT image models, one of \`256x256\`, \`512x512\`, or \`1024x1024\` for \`dall-e-2\`, and one of \`1024x1024\`, \`1792x1024\`, or \`1024x1792\` for \`dall-e-3\`.", "default": "auto" })), "moderation": Schema.optionalKey(Schema.Union([Schema.Literal("low"), Schema.Literal("auto"), Schema.Null]).annotate({ "description": "Control the content-moderation level for images generated by the GPT image models. Must be either \`low\` for less restrictive filtering or \`auto\` (default value).", "default": "auto" })), "background": Schema.optionalKey(Schema.Union([Schema.Literal("transparent"), Schema.Literal("opaque"), Schema.Literal("auto"), Schema.Null]).annotate({ "description": "Allows to set transparency for the background of the generated image(s).\\nThis parameter is only supported for the GPT image models. Must be one of\\n\`transparent\`, \`opaque\` or \`auto\` (default value). When \`auto\` is used, the\\nmodel will automatically determine the best background for the image.\\n\\nIf \`transparent\`, the output format needs to support transparency, so it\\nshould be set to either \`png\` (default value) or \`webp\`.\\n", "default": "auto" })), "style": Schema.optionalKey(Schema.Union([Schema.Literal("vivid"), Schema.Literal("natural"), Schema.Null]).annotate({ "description": "The style of the generated images. This parameter is only supported for \`dall-e-3\`. Must be one of \`vivid\` or \`natural\`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images.", "default": "vivid" })), "user": Schema.optionalKey(Schema.String.annotate({ "description": "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateImageRequest" })
export type ProjectListResponse = { readonly "object": "list", readonly "data": ReadonlyArray<Project>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ProjectListResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list"), "data": Schema.Array(Schema.suspend((): Schema.Codec<Project> => Project)), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectListResponse" })
export type ProjectGroupListResource = { readonly "object": "list", readonly "data": ReadonlyArray<ProjectGroup>, readonly "has_more": boolean, readonly "next": string | null, readonly [x: string]: unknown }
export const ProjectGroupListResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "Always \`list\`." }), "data": Schema.Array(Schema.suspend((): Schema.Codec<ProjectGroup> => ProjectGroup)).annotate({ "description": "Project group memberships returned in the current page." }), "has_more": Schema.Boolean.annotate({ "description": "Whether additional project group memberships are available." }), "next": Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Cursor to fetch the next page of results, or \`null\` when there are no more results." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Paginated list of groups that have access to a project.", "identifier": "ProjectGroupListResource" })
export type ProjectRateLimitListResponse = { readonly "object": "list", readonly "data": ReadonlyArray<ProjectRateLimit>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ProjectRateLimitListResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list"), "data": Schema.Array(Schema.suspend((): Schema.Codec<ProjectRateLimit> => ProjectRateLimit)), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectRateLimitListResponse" })
export type ProjectServiceAccountListResponse = { readonly "object": "list", readonly "data": ReadonlyArray<ProjectServiceAccount>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ProjectServiceAccountListResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list"), "data": Schema.Array(Schema.suspend((): Schema.Codec<ProjectServiceAccount> => ProjectServiceAccount)), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectServiceAccountListResponse" })
export type ProjectServiceAccountCreateResponse = { readonly "object": "organization.project.service_account", readonly "id": string, readonly "name": string, readonly "role": "member", readonly "created_at": number, readonly "api_key": ProjectServiceAccountApiKey, readonly [x: string]: unknown }
export const ProjectServiceAccountCreateResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.project.service_account"), "id": Schema.String, "name": Schema.String, "role": Schema.Literal("member").annotate({ "description": "Service accounts can only have one role of type \`member\`" }), "created_at": Schema.Number.check(Schema.isInt()), "api_key": Schema.suspend((): Schema.Codec<ProjectServiceAccountApiKey> => ProjectServiceAccountApiKey) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectServiceAccountCreateResponse" })
export type ProjectApiKey = { readonly "object": "organization.project.api_key", readonly "redacted_value": string, readonly "name": string, readonly "created_at": number, readonly "last_used_at": number, readonly "id": string, readonly "owner": { readonly "type"?: "user" | "service_account", readonly "user"?: ProjectUser, readonly "service_account"?: ProjectServiceAccount, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ProjectApiKey = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("organization.project.api_key").annotate({ "description": "The object type, which is always \`organization.project.api_key\`" }), "redacted_value": Schema.String.annotate({ "description": "The redacted value of the API key" }), "name": Schema.String.annotate({ "description": "The name of the API key" }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the API key was created" }).check(Schema.isInt()), "last_used_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the API key was last used." }).check(Schema.isInt()), "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints" }), "owner": Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["user", "service_account"]).annotate({ "description": "\`user\` or \`service_account\`" })), "user": Schema.optionalKey(ProjectUser), "service_account": Schema.optionalKey(ProjectServiceAccount) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents an individual API key in a project.", "identifier": "ProjectApiKey" })
export type ProjectUserListResponse = { readonly "object": string, readonly "data": ReadonlyArray<ProjectUser>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ProjectUserListResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.String, "data": Schema.Array(Schema.suspend((): Schema.Codec<ProjectUser> => ProjectUser)), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectUserListResponse" })
export type RealtimeTranscriptionSessionCreateResponseGA = { readonly "type": "transcription", readonly "id": string, readonly "object": string, readonly "expires_at"?: number, readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">, readonly "audio"?: { readonly "input"?: { readonly "format"?: RealtimeAudioFormats, readonly "transcription"?: AudioTranscription, readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType, readonly [x: string]: unknown }, readonly "turn_detection"?: { readonly "type"?: string, readonly "threshold"?: number, readonly "prefix_padding_ms"?: number, readonly "silence_duration_ms"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RealtimeTranscriptionSessionCreateResponseGA = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("transcription").annotate({ "description": "The type of session. Always \`transcription\` for transcription sessions.\\n" }), "id": Schema.String.annotate({ "description": "Unique identifier for the session that looks like \`sess_1234567890abcdef\`.\\n" }), "object": Schema.String.annotate({ "description": "The object type. Always \`realtime.transcription_session\`." }), "expires_at": Schema.optionalKey(Schema.Number.annotate({ "description": "Expiration timestamp for the session, in seconds since epoch." }).check(Schema.isInt())), "include": Schema.optionalKey(Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({ "description": "Additional fields to include in server outputs.\\n- \`item.input_audio_transcription.logprobs\`: Include logprobs for input audio transcription.\\n" })), "audio": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "input": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeAudioFormats> => RealtimeAudioFormats)), "transcription": Schema.optionalKey(Schema.suspend((): Schema.Codec<AudioTranscription> => AudioTranscription).annotate({ "description": "Configuration of the transcription model.\\n" })), "noise_reduction": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.suspend((): Schema.Codec<NoiseReductionType> => NoiseReductionType)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input audio noise reduction.\\n" })), "turn_detection": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "Type of turn detection, only \`server_vad\` is currently supported.\\n" })), "threshold": Schema.optionalKey(Schema.Number.annotate({ "description": "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\\nhigher threshold will require louder audio to activate the model, and\\nthus might perform better in noisy environments.\\n" }).check(Schema.isFinite())), "prefix_padding_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Amount of audio to include before the VAD detected speech (in\\nmilliseconds). Defaults to 300ms.\\n" }).check(Schema.isInt())), "silence_duration_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Duration of silence to detect speech stop (in milliseconds). Defaults\\nto 500ms. With shorter values the model will respond more quickly,\\nbut may jump in on short pauses from the user.\\n" }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for turn detection. Can be set to \`null\` to turn off. Server\\nVAD means that the model will detect the start and end of speech based on\\naudio volume and respond at the end of user speech.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input audio for the session.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime transcription session configuration object", "description": "A Realtime transcription session configuration object.\\n", "identifier": "RealtimeTranscriptionSessionCreateResponseGA" })
export type RealtimeMCPToolCall = { readonly "type": "mcp_call", readonly "id": string, readonly "server_label": string, readonly "name": string, readonly "arguments": string, readonly "approval_request_id"?: string | null, readonly "output"?: string | null, readonly "error"?: RealtimeMCPProtocolError | RealtimeMCPToolExecutionError | RealtimeMCPHTTPError | null, readonly [x: string]: unknown }
export const RealtimeMCPToolCall = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("mcp_call").annotate({ "description": "The type of the item. Always \`mcp_call\`." }), "id": Schema.String.annotate({ "description": "The unique ID of the tool call." }), "server_label": Schema.String.annotate({ "description": "The label of the MCP server running the tool." }), "name": Schema.String.annotate({ "description": "The name of the tool that was run." }), "arguments": Schema.String.annotate({ "description": "A JSON string of the arguments passed to the tool." }), "approval_request_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of an associated approval request, if any." }), Schema.Null])), "output": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The output from the tool call." }), Schema.Null])), "error": Schema.optionalKey(Schema.Union([Schema.Union([Schema.suspend((): Schema.Codec<RealtimeMCPProtocolError> => RealtimeMCPProtocolError), RealtimeMCPToolExecutionError, Schema.suspend((): Schema.Codec<RealtimeMCPHTTPError> => RealtimeMCPHTTPError)]).annotate({ "description": "The error from the tool call, if any." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime MCP tool call", "description": "A Realtime item representing an invocation of a tool on an MCP server.\\n", "identifier": "RealtimeMCPToolCall" })
export type RealtimeTranscriptionSessionCreateRequestGA = { readonly "type": "transcription", readonly "audio"?: { readonly "input"?: { readonly "format"?: RealtimeAudioFormats, readonly "transcription"?: AudioTranscription, readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType, readonly [x: string]: unknown }, readonly "turn_detection"?: RealtimeTurnDetection, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">, readonly [x: string]: unknown }
export const RealtimeTranscriptionSessionCreateRequestGA = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("transcription").annotate({ "description": "The type of session to create. Always \`transcription\` for transcription sessions.\\n" }), "audio": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "input": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeAudioFormats> => RealtimeAudioFormats)), "transcription": Schema.optionalKey(Schema.suspend((): Schema.Codec<AudioTranscription> => AudioTranscription).annotate({ "description": "Configuration for input audio transcription, defaults to off and can be set to \`null\` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\\n" })), "noise_reduction": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.suspend((): Schema.Codec<NoiseReductionType> => NoiseReductionType)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input audio noise reduction. This can be set to \`null\` to turn off.\\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\\n" })), "turn_detection": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeTurnDetection> => RealtimeTurnDetection)) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input and output audio.\\n" })), "include": Schema.optionalKey(Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({ "description": "Additional fields to include in server outputs.\\n\\n\`item.input_audio_transcription.logprobs\`: Include logprobs for input audio transcription.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime transcription session configuration", "description": "Realtime transcription session object configuration.", "identifier": "RealtimeTranscriptionSessionCreateRequestGA" })
export type EvalResponsesSource = { readonly "type": "responses", readonly "metadata"?: { readonly [x: string]: unknown } | null, readonly "model"?: string | null, readonly "instructions_search"?: string | null, readonly "created_after"?: number | null, readonly "created_before"?: number | null, readonly "reasoning_effort"?: ReasoningEffort | null, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "users"?: ReadonlyArray<string> | null, readonly "tools"?: ReadonlyArray<string> | null, readonly [x: string]: unknown }
export const EvalResponsesSource = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("responses").annotate({ "description": "The type of run data source. Always \`responses\`." }), "metadata": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "Metadata filter for the responses. This is a query parameter used to select responses." }), Schema.Null])), "model": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The name of the model to find responses for. This is a query parameter used to select responses." }), Schema.Null])), "instructions_search": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Optional string to search the 'instructions' field. This is a query parameter used to select responses." }), Schema.Null])), "created_after": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "Only include items created after this timestamp (inclusive). This is a query parameter used to select responses." }).check(Schema.isInt()), Schema.Null])), "created_before": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "Only include items created before this timestamp (inclusive). This is a query parameter used to select responses." }).check(Schema.isInt()), Schema.Null])), "reasoning_effort": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ReasoningEffort> => ReasoningEffort).annotate({ "description": "Optional reasoning effort parameter. This is a query parameter used to select responses." }), Schema.Null])), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "Sampling temperature. This is a query parameter used to select responses." }).check(Schema.isFinite()), Schema.Null])), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "Nucleus sampling parameter. This is a query parameter used to select responses." }).check(Schema.isFinite()), Schema.Null])), "users": Schema.optionalKey(Schema.Union([Schema.Array(Schema.String).annotate({ "description": "List of user identifiers. This is a query parameter used to select responses." }), Schema.Null])), "tools": Schema.optionalKey(Schema.Union([Schema.Array(Schema.String).annotate({ "description": "List of tool names. This is a query parameter used to select responses." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalResponsesSource", "description": "A EvalResponsesSource object describing a run data source configuration.\\n", "identifier": "EvalResponsesSource" })
export type Reasoning = { readonly "effort"?: ReasoningEffort, readonly "summary"?: "auto" | "concise" | "detailed" | null, readonly "generate_summary"?: "auto" | "concise" | "detailed" | null, readonly [x: string]: unknown }
export const Reasoning = Schema.StructWithRest(Schema.Struct({ "effort": Schema.optionalKey(Schema.suspend((): Schema.Codec<ReasoningEffort> => ReasoningEffort)), "summary": Schema.optionalKey(Schema.Union([Schema.Literals(["auto", "concise", "detailed"]).annotate({ "description": "A summary of the reasoning performed by the model. This can be\\nuseful for debugging and understanding the model's reasoning process.\\nOne of \`auto\`, \`concise\`, or \`detailed\`.\\n\\n\`concise\` is supported for \`computer-use-preview\` models and all reasoning models after \`gpt-5\`.\\n" }), Schema.Null])), "generate_summary": Schema.optionalKey(Schema.Union([Schema.Literals(["auto", "concise", "detailed"]).annotate({ "description": "**Deprecated:** use \`summary\` instead.\\n\\nA summary of the reasoning performed by the model. This can be\\nuseful for debugging and understanding the model's reasoning process.\\nOne of \`auto\`, \`concise\`, or \`detailed\`.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Reasoning", "description": "**gpt-5 and o-series models only**\\n\\nConfiguration options for\\n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\\n", "identifier": "Reasoning" })
export type ResponseCompletedEvent = { readonly "type": "response.completed", readonly "response": Response, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseCompletedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.completed").annotate({ "description": "The type of the event. Always \`response.completed\`.\\n" }), "response": Schema.suspend((): Schema.Codec<Response> => Response).annotate({ "description": "Properties of the completed response.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number for this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when the model response is complete.", "identifier": "ResponseCompletedEvent" })
export type ResponseCreatedEvent = { readonly "type": "response.created", readonly "response": Response, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseCreatedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.created").annotate({ "description": "The type of the event. Always \`response.created\`.\\n" }), "response": Schema.suspend((): Schema.Codec<Response> => Response).annotate({ "description": "The response that was created.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number for this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "An event that is emitted when a response is created.\\n", "identifier": "ResponseCreatedEvent" })
export type ResponseFailedEvent = { readonly "type": "response.failed", readonly "sequence_number": number, readonly "response": Response, readonly [x: string]: unknown }
export const ResponseFailedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.failed").annotate({ "description": "The type of the event. Always \`response.failed\`.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "response": Schema.suspend((): Schema.Codec<Response> => Response).annotate({ "description": "The response that failed.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "An event that is emitted when a response fails.\\n", "identifier": "ResponseFailedEvent" })
export type ResponseInProgressEvent = { readonly "type": "response.in_progress", readonly "response": Response, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseInProgressEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.in_progress").annotate({ "description": "The type of the event. Always \`response.in_progress\`.\\n" }), "response": Schema.suspend((): Schema.Codec<Response> => Response).annotate({ "description": "The response that is in progress.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when the response is in progress.", "identifier": "ResponseInProgressEvent" })
export type ResponseIncompleteEvent = { readonly "type": "response.incomplete", readonly "response": Response, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseIncompleteEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.incomplete").annotate({ "description": "The type of the event. Always \`response.incomplete\`.\\n" }), "response": Schema.suspend((): Schema.Codec<Response> => Response).annotate({ "description": "The response that was incomplete.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "An event that is emitted when a response finishes as incomplete.\\n", "identifier": "ResponseIncompleteEvent" })
export type ResponseQueuedEvent = { readonly "type": "response.queued", readonly "response": Response, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseQueuedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.queued").annotate({ "description": "The type of the event. Always 'response.queued'." }), "response": Schema.suspend((): Schema.Codec<Response> => Response).annotate({ "description": "The full response object that is queued." }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number for this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ResponseQueuedEvent", "description": "Emitted when a response is queued and waiting to be processed.\\n", "identifier": "ResponseQueuedEvent" })
export type ResponseError = { readonly "code": ResponseErrorCode, readonly "message": string, readonly [x: string]: unknown } | null
export const ResponseError = Schema.Union([Schema.StructWithRest(Schema.Struct({ "code": ResponseErrorCode, "message": Schema.String.annotate({ "description": "A human-readable description of the error.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "An error object returned when the model fails to generate a Response.\\n" }), Schema.Null]).annotate({ "identifier": "ResponseError" })
export type ResponseFormatJsonSchema = { readonly "type": "json_schema", readonly "json_schema": { readonly "description"?: string, readonly "name": string, readonly "schema"?: ResponseFormatJsonSchemaSchema, readonly "strict"?: boolean | null, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const ResponseFormatJsonSchema = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("json_schema").annotate({ "description": "The type of response format being defined. Always \`json_schema\`." }), "json_schema": Schema.StructWithRest(Schema.Struct({ "description": Schema.optionalKey(Schema.String.annotate({ "description": "A description of what the response format is for, used by the model to\\ndetermine how to respond in the format.\\n" })), "name": Schema.String.annotate({ "description": "The name of the response format. Must be a-z, A-Z, 0-9, or contain\\nunderscores and dashes, with a maximum length of 64.\\n" }), "schema": Schema.optionalKey(ResponseFormatJsonSchemaSchema), "strict": Schema.optionalKey(Schema.Union([Schema.Boolean.annotate({ "description": "Whether to enable strict schema adherence when generating the output.\\nIf set to true, the model will always follow the exact schema defined\\nin the \`schema\` field. Only a subset of JSON Schema is supported when\\n\`strict\` is \`true\`. To learn more, read the [Structured Outputs\\nguide](https://platform.openai.com/docs/guides/structured-outputs).\\n", "default": false }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "JSON schema", "description": "Structured Outputs configuration options, including a JSON Schema.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "JSON schema", "description": "JSON Schema response format. Used to generate structured JSON responses.\\nLearn more about [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs).\\n", "identifier": "ResponseFormatJsonSchema" })
export type TextResponseFormatJsonSchema = { readonly "type": "json_schema", readonly "description"?: string, readonly "name": string, readonly "schema": ResponseFormatJsonSchemaSchema, readonly "strict"?: boolean | null, readonly [x: string]: unknown }
export const TextResponseFormatJsonSchema = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("json_schema").annotate({ "description": "The type of response format being defined. Always \`json_schema\`." }), "description": Schema.optionalKey(Schema.String.annotate({ "description": "A description of what the response format is for, used by the model to\\ndetermine how to respond in the format.\\n" })), "name": Schema.String.annotate({ "description": "The name of the response format. Must be a-z, A-Z, 0-9, or contain\\nunderscores and dashes, with a maximum length of 64.\\n" }), "schema": Schema.suspend((): Schema.Codec<ResponseFormatJsonSchemaSchema> => ResponseFormatJsonSchemaSchema), "strict": Schema.optionalKey(Schema.Union([Schema.Boolean.annotate({ "description": "Whether to enable strict schema adherence when generating the output.\\nIf set to true, the model will always follow the exact schema defined\\nin the \`schema\` field. Only a subset of JSON Schema is supported when\\n\`strict\` is \`true\`. To learn more, read the [Structured Outputs\\nguide](https://platform.openai.com/docs/guides/structured-outputs).\\n", "default": false }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "JSON schema", "description": "JSON Schema response format. Used to generate structured JSON responses.\\nLearn more about [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs).\\n", "identifier": "TextResponseFormatJsonSchema" })
export type ResponseTextDeltaEvent = { readonly "type": "response.output_text.delta", readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "delta": string, readonly "sequence_number": number, readonly "logprobs": ReadonlyArray<ResponseLogProb>, readonly [x: string]: unknown }
export const ResponseTextDeltaEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.output_text.delta").annotate({ "description": "The type of the event. Always \`response.output_text.delta\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the output item that the text delta was added to.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the text delta was added to.\\n" }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part that the text delta was added to.\\n" }).check(Schema.isInt()), "delta": Schema.String.annotate({ "description": "The text delta that was added.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number for this event." }).check(Schema.isInt()), "logprobs": Schema.Array(Schema.suspend((): Schema.Codec<ResponseLogProb> => ResponseLogProb)).annotate({ "description": "The log probabilities of the tokens in the delta.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when there is an additional text delta.", "identifier": "ResponseTextDeltaEvent" })
export type ResponseTextDoneEvent = { readonly "type": "response.output_text.done", readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "text": string, readonly "sequence_number": number, readonly "logprobs": ReadonlyArray<ResponseLogProb>, readonly [x: string]: unknown }
export const ResponseTextDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.output_text.done").annotate({ "description": "The type of the event. Always \`response.output_text.done\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the output item that the text content is finalized.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the text content is finalized.\\n" }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part that the text content is finalized.\\n" }).check(Schema.isInt()), "text": Schema.String.annotate({ "description": "The text content that is finalized.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number for this event." }).check(Schema.isInt()), "logprobs": Schema.Array(Schema.suspend((): Schema.Codec<ResponseLogProb> => ResponseLogProb)).annotate({ "description": "The log probabilities of the tokens in the delta.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when text content is finalized.", "identifier": "ResponseTextDoneEvent" })
export type GroupRoleAssignment = { readonly "object": "group.role", readonly "group": Group, readonly "role": Role, readonly [x: string]: unknown }
export const GroupRoleAssignment = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("group.role").annotate({ "description": "Always \`group.role\`." }), "group": Schema.suspend((): Schema.Codec<Group> => Group), "role": Role }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Role assignment linking a group to a role.", "identifier": "GroupRoleAssignment" })
export type PublicRoleListResource = { readonly "object": "list", readonly "data": ReadonlyArray<Role>, readonly "has_more": boolean, readonly "next": string | null, readonly [x: string]: unknown }
export const PublicRoleListResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "Always \`list\`." }), "data": Schema.Array(Schema.suspend((): Schema.Codec<Role> => Role)).annotate({ "description": "Roles returned in the current page." }), "has_more": Schema.Boolean.annotate({ "description": "Whether more roles are available when paginating." }), "next": Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Cursor to fetch the next page of results, or \`null\` when there are no additional roles." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Paginated list of roles available on an organization or project.", "identifier": "PublicRoleListResource" })
export type RunStepDeltaStepDetailsToolCallsCodeObject = { readonly "index": number, readonly "id"?: string, readonly "type": "code_interpreter", readonly "code_interpreter"?: { readonly "input"?: string, readonly "outputs"?: ReadonlyArray<RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject | RunStepDeltaStepDetailsToolCallsCodeOutputImageObject>, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunStepDeltaStepDetailsToolCallsCodeObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the tool call in the tool calls array." }).check(Schema.isInt()), "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the tool call." })), "type": Schema.Literal("code_interpreter").annotate({ "description": "The type of tool call. This is always going to be \`code_interpreter\` for this type of tool call." }), "code_interpreter": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "input": Schema.optionalKey(Schema.String.annotate({ "description": "The input to the Code Interpreter tool call." })), "outputs": Schema.optionalKey(Schema.Array(Schema.Union([RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject, RunStepDeltaStepDetailsToolCallsCodeOutputImageObject])).annotate({ "description": "The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (\`logs\`) or images (\`image\`). Each of these are represented by a different object type." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The Code Interpreter tool call definition." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code interpreter tool call", "description": "Details of the Code Interpreter tool call the run step was involved in.", "identifier": "RunStepDeltaStepDetailsToolCallsCodeObject" })
export type RunStepDetailsToolCallsCodeObject = { readonly "id": string, readonly "type": "code_interpreter", readonly "code_interpreter": { readonly "input": string, readonly "outputs": ReadonlyArray<RunStepDetailsToolCallsCodeOutputLogsObject | RunStepDetailsToolCallsCodeOutputImageObject>, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunStepDetailsToolCallsCodeObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The ID of the tool call." }), "type": Schema.Literal("code_interpreter").annotate({ "description": "The type of tool call. This is always going to be \`code_interpreter\` for this type of tool call." }), "code_interpreter": Schema.StructWithRest(Schema.Struct({ "input": Schema.String.annotate({ "description": "The input to the Code Interpreter tool call." }), "outputs": Schema.Array(Schema.Union([RunStepDetailsToolCallsCodeOutputLogsObject, RunStepDetailsToolCallsCodeOutputImageObject])).annotate({ "description": "The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (\`logs\`) or images (\`image\`). Each of these are represented by a different object type." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The Code Interpreter tool call definition." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code Interpreter tool call", "description": "Details of the Code Interpreter tool call the run step was involved in.", "identifier": "RunStepDetailsToolCallsCodeObject" })
export type ModelResponseProperties = { readonly "metadata"?: Metadata, readonly "top_logprobs"?: number | null, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "user"?: string, readonly "safety_identifier"?: string, readonly "prompt_cache_key"?: string, readonly "service_tier"?: ServiceTier, readonly "prompt_cache_retention"?: "in-memory" | "24h" | null, readonly [x: string]: unknown }
export const ModelResponseProperties = Schema.StructWithRest(Schema.Struct({ "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "top_logprobs": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "An integer between 0 and 20 specifying the number of most likely tokens to\\nreturn at each token position, each with an associated log probability.\\n" }).check(Schema.isInt()), Schema.Null])), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\\nWe generally recommend altering this or \`top_p\` but not both.\\n", "default": 1 }).check(Schema.isFinite()), Schema.Null])), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "An alternative to sampling with temperature, called nucleus sampling,\\nwhere the model considers the results of the tokens with top_p probability\\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\\nare considered.\\n\\nWe generally recommend altering this or \`temperature\` but not both.\\n", "default": 1 }).check(Schema.isFinite()), Schema.Null])), "user": Schema.optionalKey(Schema.String.annotate({ "description": "This field is being replaced by \`safety_identifier\` and \`prompt_cache_key\`. Use \`prompt_cache_key\` instead to maintain caching optimizations.\\nA stable identifier for your end-users.\\nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\\n" })), "safety_identifier": Schema.optionalKey(Schema.String.annotate({ "description": "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies.\\nThe IDs should be a string that uniquely identifies each user. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\\n" })), "prompt_cache_key": Schema.optionalKey(Schema.String.annotate({ "description": "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the \`user\` field. [Learn more](https://platform.openai.com/docs/guides/prompt-caching).\\n" })), "service_tier": Schema.optionalKey(Schema.suspend((): Schema.Codec<ServiceTier> => ServiceTier)), "prompt_cache_retention": Schema.optionalKey(Schema.Union([Schema.Literals(["in-memory", "24h"]).annotate({ "description": "The retention policy for the prompt cache. Set to \`24h\` to enable extended prompt caching, which keeps cached prefixes active for longer, up to a maximum of 24 hours. [Learn more](https://platform.openai.com/docs/guides/prompt-caching#prompt-cache-retention).\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ModelResponseProperties" })
export type CreateSpeechResponseStreamEvent = SpeechAudioDeltaEvent | SpeechAudioDoneEvent
export const CreateSpeechResponseStreamEvent = Schema.Union([SpeechAudioDeltaEvent, SpeechAudioDoneEvent]).annotate({ "identifier": "CreateSpeechResponseStreamEvent" })
export type StaticChunkingStrategyRequestParam = { readonly "type": "static", readonly "static": StaticChunkingStrategy }
export const StaticChunkingStrategyRequestParam = Schema.Struct({ "type": Schema.Literal("static").annotate({ "description": "Always \`static\`." }), "static": Schema.suspend((): Schema.Codec<StaticChunkingStrategy> => StaticChunkingStrategy) }).annotate({ "title": "Static Chunking Strategy", "description": "Customize your own chunking strategy by setting chunk size and chunk overlap.", "identifier": "StaticChunkingStrategyRequestParam" })
export type StaticChunkingStrategyResponseParam = { readonly "type": "static", readonly "static": StaticChunkingStrategy }
export const StaticChunkingStrategyResponseParam = Schema.Struct({ "type": Schema.Literal("static").annotate({ "description": "Always \`static\`." }), "static": Schema.suspend((): Schema.Codec<StaticChunkingStrategy> => StaticChunkingStrategy) }).annotate({ "title": "Static Chunking Strategy", "identifier": "StaticChunkingStrategyResponseParam" })
export type CreateCompletionRequest = { readonly "model": string | "gpt-3.5-turbo-instruct" | "davinci-002" | "babbage-002", readonly "prompt": string | ReadonlyArray<string> | ReadonlyArray<number> | ReadonlyArray<ReadonlyArray<number>> | null, readonly "best_of"?: number | null, readonly "echo"?: boolean | null, readonly "frequency_penalty"?: number | null, readonly "logit_bias"?: { readonly [x: string]: unknown } | null, readonly "logprobs"?: number | null, readonly "max_tokens"?: number | null, readonly "n"?: number | null, readonly "presence_penalty"?: number | null, readonly "seed"?: number | null, readonly "stop"?: StopConfiguration, readonly "stream"?: boolean | null, readonly "stream_options"?: ChatCompletionStreamOptions, readonly "suffix"?: string | null, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "user"?: string, readonly [x: string]: unknown }
export const CreateCompletionRequest = Schema.StructWithRest(Schema.Struct({ "model": Schema.Union([Schema.String, Schema.Literals(["gpt-3.5-turbo-instruct", "davinci-002", "babbage-002"]).annotate({ "title": "Preset" })]).annotate({ "description": "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\\n" }), "prompt": Schema.Union([Schema.Union([Schema.String.annotate({ "default": "" }), Schema.Array(Schema.String.annotate({ "default": "" })).annotate({ "title": "Array of strings" }), Schema.Array(Schema.Number.check(Schema.isInt())).annotate({ "title": "Array of tokens" }), Schema.Array(Schema.Array(Schema.Number.check(Schema.isInt()))).annotate({ "title": "Array of token arrays" })]).annotate({ "description": "The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.\\n\\nNote that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.\\n" }), Schema.Null]), "best_of": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "Generates \`best_of\` completions server-side and returns the \\"best\\" (the one with the highest log probability per token). Results cannot be streamed.\\n\\nWhen used with \`n\`, \`best_of\` controls the number of candidate completions and \`n\` specifies how many to return  \`best_of\` must be greater than \`n\`.\\n\\n**Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for \`max_tokens\` and \`stop\`.\\n", "default": 1 })), "echo": Schema.optionalKey(Schema.Union([Schema.Boolean, Schema.Null]).annotate({ "description": "Echo back the prompt in addition to the completion\\n", "default": false })), "frequency_penalty": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.\\n\\n[See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation)\\n", "default": 0 })), "logit_bias": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "Modify the likelihood of specified tokens appearing in the completion.\\n\\nAccepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.\\n\\nAs an example, you can pass \`{\\"50256\\": -100}\` to prevent the <|endoftext|> token from being generated.\\n", "default": null })), "logprobs": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "Include the log probabilities on the \`logprobs\` most likely output tokens, as well the chosen tokens. For example, if \`logprobs\` is 5, the API will return a list of the 5 most likely tokens. The API will always return the \`logprob\` of the sampled token, so there may be up to \`logprobs+1\` elements in the response.\\n\\nThe maximum value for \`logprobs\` is 5.\\n", "default": null })), "max_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of [tokens](/tokenizer) that can be generated in the completion.\\n\\nThe token count of your prompt plus \`max_tokens\` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.\\n", "default": 16 })), "n": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "How many completions to generate for each prompt.\\n\\n**Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for \`max_tokens\` and \`stop\`.\\n", "default": 1 })), "presence_penalty": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.\\n\\n[See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation)\\n", "default": 0 })), "seed": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same \`seed\` and parameters should return the same result.\\n\\nDeterminism is not guaranteed, and you should refer to the \`system_fingerprint\` response parameter to monitor changes in the backend.\\n", "format": "int64" })), "stop": Schema.optionalKey(Schema.suspend((): Schema.Codec<StopConfiguration> => StopConfiguration)), "stream": Schema.optionalKey(Schema.Union([Schema.Boolean, Schema.Null]).annotate({ "description": "Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a \`data: [DONE]\` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\\n", "default": false })), "stream_options": Schema.optionalKey(Schema.suspend((): Schema.Codec<ChatCompletionStreamOptions> => ChatCompletionStreamOptions)), "suffix": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "The suffix that comes after a completion of inserted text.\\n\\nThis parameter is only supported for \`gpt-3.5-turbo-instruct\`.\\n", "default": null })), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\\n\\nWe generally recommend altering this or \`top_p\` but not both.\\n", "default": 1 })), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\\n\\nWe generally recommend altering this or \`temperature\` but not both.\\n", "default": 1 })), "user": Schema.optionalKey(Schema.String.annotate({ "description": "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateCompletionRequest" })
export type CreateTranscriptionResponseJson = { readonly "text": string, readonly "logprobs"?: ReadonlyArray<{ readonly "token"?: string, readonly "logprob"?: number, readonly "bytes"?: ReadonlyArray<number>, readonly [x: string]: unknown }>, readonly "usage"?: TranscriptTextUsageTokens | TranscriptTextUsageDuration, readonly [x: string]: unknown }
export const CreateTranscriptionResponseJson = Schema.StructWithRest(Schema.Struct({ "text": Schema.String.annotate({ "description": "The transcribed text." }), "logprobs": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "token": Schema.optionalKey(Schema.String.annotate({ "description": "The token in the transcription." })), "logprob": Schema.optionalKey(Schema.Number.annotate({ "description": "The log probability of the token." }).check(Schema.isFinite())), "bytes": Schema.optionalKey(Schema.Array(Schema.Number.check(Schema.isFinite())).annotate({ "description": "The bytes of the token." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The log probabilities of the tokens in the transcription. Only returned with the models \`gpt-4o-transcribe\` and \`gpt-4o-mini-transcribe\` if \`logprobs\` is added to the \`include\` array.\\n" })), "usage": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<TranscriptTextUsageTokens> => TranscriptTextUsageTokens).annotate({ "title": "Token Usage" }), Schema.suspend((): Schema.Codec<TranscriptTextUsageDuration> => TranscriptTextUsageDuration).annotate({ "title": "Duration Usage" })]).annotate({ "description": "Token usage statistics for the request." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents a transcription response returned by model, based on the provided input.", "identifier": "CreateTranscriptionResponseJson" })
export type RealtimeBetaServerEventConversationItemInputAudioTranscriptionCompleted = { readonly "event_id": string, readonly "type": "conversation.item.input_audio_transcription.completed", readonly "item_id": string, readonly "content_index": number, readonly "transcript": string, readonly "logprobs"?: ReadonlyArray<LogProbProperties> | null, readonly "usage": TranscriptTextUsageTokens | TranscriptTextUsageDuration, readonly [x: string]: unknown }
export const RealtimeBetaServerEventConversationItemInputAudioTranscriptionCompleted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.input_audio_transcription.completed").annotate({ "description": "The event type, must be\\n\`conversation.item.input_audio_transcription.completed\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the user message item containing the audio." }), "content_index": Schema.Number.annotate({ "description": "The index of the content part containing the audio." }).check(Schema.isInt()), "transcript": Schema.String.annotate({ "description": "The transcribed text." }), "logprobs": Schema.optionalKey(Schema.Union([Schema.Array(Schema.suspend((): Schema.Codec<LogProbProperties> => LogProbProperties)).annotate({ "description": "The log probabilities of the transcription." }), Schema.Null])), "usage": Schema.Union([Schema.suspend((): Schema.Codec<TranscriptTextUsageTokens> => TranscriptTextUsageTokens).annotate({ "title": "Token Usage" }), Schema.suspend((): Schema.Codec<TranscriptTextUsageDuration> => TranscriptTextUsageDuration).annotate({ "title": "Duration Usage" })]).annotate({ "description": "Usage statistics for the transcription." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "This event is the output of audio transcription for user audio written to the\\nuser audio buffer. Transcription begins when the input audio buffer is\\ncommitted by the client or server (in \`server_vad\` mode). Transcription runs\\nasynchronously with Response creation, so this event may come before or after\\nthe Response events.\\n\\nRealtime API models accept audio natively, and thus input transcription is a\\nseparate process run on a separate ASR (Automatic Speech Recognition) model.\\nThe transcript may diverge somewhat from the model's interpretation, and\\nshould be treated as a rough guide.\\n", "identifier": "RealtimeBetaServerEventConversationItemInputAudioTranscriptionCompleted" })
export type RealtimeServerEventConversationItemInputAudioTranscriptionCompleted = { readonly "event_id": string, readonly "type": "conversation.item.input_audio_transcription.completed", readonly "item_id": string, readonly "content_index": number, readonly "transcript": string, readonly "logprobs"?: ReadonlyArray<LogProbProperties> | null, readonly "usage": TranscriptTextUsageTokens | TranscriptTextUsageDuration, readonly [x: string]: unknown }
export const RealtimeServerEventConversationItemInputAudioTranscriptionCompleted = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.input_audio_transcription.completed").annotate({ "description": "The event type, must be\\n\`conversation.item.input_audio_transcription.completed\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the item containing the audio that is being transcribed." }), "content_index": Schema.Number.annotate({ "description": "The index of the content part containing the audio." }).check(Schema.isInt()), "transcript": Schema.String.annotate({ "description": "The transcribed text." }), "logprobs": Schema.optionalKey(Schema.Union([Schema.Array(Schema.suspend((): Schema.Codec<LogProbProperties> => LogProbProperties)).annotate({ "description": "The log probabilities of the transcription." }), Schema.Null])), "usage": Schema.Union([Schema.suspend((): Schema.Codec<TranscriptTextUsageTokens> => TranscriptTextUsageTokens).annotate({ "title": "TranscriptTextUsageTokens" }), Schema.suspend((): Schema.Codec<TranscriptTextUsageDuration> => TranscriptTextUsageDuration).annotate({ "title": "TranscriptTextUsageDuration" })]).annotate({ "description": "Usage statistics for the transcription, this is billed according to the ASR model's pricing rather than the realtime model's pricing." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "This event is the output of audio transcription for user audio written to the\\nuser audio buffer. Transcription begins when the input audio buffer is\\ncommitted by the client or server (when VAD is enabled). Transcription runs\\nasynchronously with Response creation, so this event may come before or after\\nthe Response events.\\n\\nRealtime API models accept audio natively, and thus input transcription is a\\nseparate process run on a separate ASR (Automatic Speech Recognition) model.\\nThe transcript may diverge somewhat from the model's interpretation, and\\nshould be treated as a rough guide.\\n", "identifier": "RealtimeServerEventConversationItemInputAudioTranscriptionCompleted" })
export type TranscriptTextDoneEvent = { readonly "type": "transcript.text.done", readonly "text": string, readonly "logprobs"?: ReadonlyArray<{ readonly "token"?: string, readonly "logprob"?: number, readonly "bytes"?: ReadonlyArray<number>, readonly [x: string]: unknown }>, readonly "usage"?: TranscriptTextUsageTokens, readonly [x: string]: unknown }
export const TranscriptTextDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("transcript.text.done").annotate({ "description": "The type of the event. Always \`transcript.text.done\`.\\n" }), "text": Schema.String.annotate({ "description": "The text that was transcribed.\\n" }), "logprobs": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "token": Schema.optionalKey(Schema.String.annotate({ "description": "The token that was used to generate the log probability.\\n" })), "logprob": Schema.optionalKey(Schema.Number.annotate({ "description": "The log probability of the token.\\n" }).check(Schema.isFinite())), "bytes": Schema.optionalKey(Schema.Array(Schema.Number.check(Schema.isInt())).annotate({ "description": "The bytes that were used to generate the log probability.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The log probabilities of the individual tokens in the transcription. Only included if you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the \`include[]\` parameter set to \`logprobs\`.\\n" })), "usage": Schema.optionalKey(Schema.suspend((): Schema.Codec<TranscriptTextUsageTokens> => TranscriptTextUsageTokens)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when the transcription is complete. Contains the complete transcription text. Only emitted when you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the \`Stream\` parameter set to \`true\`.", "identifier": "TranscriptTextDoneEvent" })
export type CreateTranscriptionResponseDiarizedJson = { readonly "task": "transcribe", readonly "duration": number, readonly "text": string, readonly "segments": ReadonlyArray<TranscriptionDiarizedSegment>, readonly "usage"?: unknown | unknown, readonly [x: string]: unknown }
export const CreateTranscriptionResponseDiarizedJson = Schema.StructWithRest(Schema.Struct({ "task": Schema.Literal("transcribe").annotate({ "description": "The type of task that was run. Always \`transcribe\`." }), "duration": Schema.Number.annotate({ "description": "Duration of the input audio in seconds." }).check(Schema.isFinite()), "text": Schema.String.annotate({ "description": "The concatenated transcript text for the entire audio input." }), "segments": Schema.Array(TranscriptionDiarizedSegment).annotate({ "description": "Segments of the transcript annotated with timestamps and speaker labels." }), "usage": Schema.optionalKey(Schema.Union([Schema.Unknown.annotate({ "title": "Token Usage" }), Schema.Unknown.annotate({ "title": "Duration Usage" })]).annotate({ "description": "Token or duration usage statistics for the request." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents a diarized transcription response returned by the model, including the combined transcript and speaker-segment annotations.\\n", "identifier": "CreateTranscriptionResponseDiarizedJson" })
export type CreateTranslationResponseVerboseJson = { readonly "language": string, readonly "duration": number, readonly "text": string, readonly "segments"?: ReadonlyArray<TranscriptionSegment>, readonly [x: string]: unknown }
export const CreateTranslationResponseVerboseJson = Schema.StructWithRest(Schema.Struct({ "language": Schema.String.annotate({ "description": "The language of the output translation (always \`english\`)." }), "duration": Schema.Number.annotate({ "description": "The duration of the input audio." }).check(Schema.isFinite()), "text": Schema.String.annotate({ "description": "The translated text." }), "segments": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<TranscriptionSegment> => TranscriptionSegment)).annotate({ "description": "Segments of the translated text and their corresponding details." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateTranslationResponseVerboseJson" })
export type CreateTranscriptionResponseVerboseJson = { readonly "language": string, readonly "duration": number, readonly "text": string, readonly "words"?: ReadonlyArray<TranscriptionWord>, readonly "segments"?: ReadonlyArray<TranscriptionSegment>, readonly "usage"?: TranscriptTextUsageDuration, readonly [x: string]: unknown }
export const CreateTranscriptionResponseVerboseJson = Schema.StructWithRest(Schema.Struct({ "language": Schema.String.annotate({ "description": "The language of the input audio." }), "duration": Schema.Number.annotate({ "description": "The duration of the input audio." }).check(Schema.isFinite()), "text": Schema.String.annotate({ "description": "The transcribed text." }), "words": Schema.optionalKey(Schema.Array(TranscriptionWord).annotate({ "description": "Extracted words and their corresponding timestamps." })), "segments": Schema.optionalKey(Schema.Array(TranscriptionSegment).annotate({ "description": "Segments of the transcribed text and their corresponding details." })), "usage": Schema.optionalKey(Schema.suspend((): Schema.Codec<TranscriptTextUsageDuration> => TranscriptTextUsageDuration)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents a verbose json transcription response returned by model, based on the provided input.", "identifier": "CreateTranscriptionResponseVerboseJson" })
export type UsageTimeBucket = { readonly "object": "bucket", readonly "start_time": number, readonly "end_time": number, readonly "result": ReadonlyArray<UsageCompletionsResult | UsageEmbeddingsResult | UsageModerationsResult | UsageImagesResult | UsageAudioSpeechesResult | UsageAudioTranscriptionsResult | UsageVectorStoresResult | UsageCodeInterpreterSessionsResult | CostsResult>, readonly [x: string]: unknown }
export const UsageTimeBucket = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("bucket"), "start_time": Schema.Number.check(Schema.isInt()), "end_time": Schema.Number.check(Schema.isInt()), "result": Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<UsageCompletionsResult> => UsageCompletionsResult), Schema.suspend((): Schema.Codec<UsageEmbeddingsResult> => UsageEmbeddingsResult), Schema.suspend((): Schema.Codec<UsageModerationsResult> => UsageModerationsResult), Schema.suspend((): Schema.Codec<UsageImagesResult> => UsageImagesResult), Schema.suspend((): Schema.Codec<UsageAudioSpeechesResult> => UsageAudioSpeechesResult), Schema.suspend((): Schema.Codec<UsageAudioTranscriptionsResult> => UsageAudioTranscriptionsResult), UsageVectorStoresResult, Schema.suspend((): Schema.Codec<UsageCodeInterpreterSessionsResult> => UsageCodeInterpreterSessionsResult), Schema.suspend((): Schema.Codec<CostsResult> => CostsResult)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "UsageTimeBucket" })
export type UserListResource = { readonly "object": "list", readonly "data": ReadonlyArray<User>, readonly "has_more": boolean, readonly "next": string | null, readonly [x: string]: unknown }
export const UserListResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "Always \`list\`." }), "data": Schema.Array(Schema.suspend((): Schema.Codec<User> => User)).annotate({ "description": "Users in the current page." }), "has_more": Schema.Boolean.annotate({ "description": "Whether more users are available when paginating." }), "next": Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Cursor to fetch the next page of results, or \`null\` when no further users are available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Paginated list of user objects returned when inspecting group membership.", "identifier": "UserListResource" })
export type UserListResponse = { readonly "object": "list", readonly "data": ReadonlyArray<User>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const UserListResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list"), "data": Schema.Array(Schema.suspend((): Schema.Codec<User> => User)), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "UserListResponse" })
export type UserRoleAssignment = { readonly "object": "user.role", readonly "user": User, readonly "role": Role, readonly [x: string]: unknown }
export const UserRoleAssignment = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("user.role").annotate({ "description": "Always \`user.role\`." }), "user": Schema.suspend((): Schema.Codec<User> => User), "role": Schema.suspend((): Schema.Codec<Role> => Role) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Role assignment linking a user to a role.", "identifier": "UserRoleAssignment" })
export type TranscriptionChunkingStrategy = "auto" | VadConfig | null
export const TranscriptionChunkingStrategy = Schema.Union([Schema.Union([Schema.Literal("auto").annotate({ "description": "Automatically set chunking parameters based on the audio. Must be set to \`\\"auto\\"\`.\\n", "default": "auto" }), VadConfig]).annotate({ "description": "Controls how the audio is cut into chunks. When set to \`\\"auto\\"\`, the server first normalizes loudness and then uses voice activity detection (VAD) to choose boundaries. \`server_vad\` object can be provided to tweak VAD detection parameters manually. If unset, the audio is transcribed as a single block. Required when using \`gpt-4o-transcribe-diarize\` for inputs longer than 30 seconds. " }), Schema.Null]).annotate({ "identifier": "TranscriptionChunkingStrategy" })
export type VectorStoreObject = { readonly "id": string, readonly "object": "vector_store", readonly "created_at": number, readonly "name": string, readonly "usage_bytes": number, readonly "file_counts": { readonly "in_progress": number, readonly "completed": number, readonly "failed": number, readonly "cancelled": number, readonly "total": number, readonly [x: string]: unknown }, readonly "status": "expired" | "in_progress" | "completed", readonly "expires_after"?: VectorStoreExpirationAfter, readonly "expires_at"?: number | null, readonly "last_active_at": number | null, readonly "metadata": Metadata, readonly [x: string]: unknown }
export const VectorStoreObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }), "object": Schema.Literal("vector_store").annotate({ "description": "The object type, which is always \`vector_store\`." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the vector store was created." }).check(Schema.isInt()), "name": Schema.String.annotate({ "description": "The name of the vector store." }), "usage_bytes": Schema.Number.annotate({ "description": "The total number of bytes used by the files in the vector store." }).check(Schema.isInt()), "file_counts": Schema.StructWithRest(Schema.Struct({ "in_progress": Schema.Number.annotate({ "description": "The number of files that are currently being processed." }).check(Schema.isInt()), "completed": Schema.Number.annotate({ "description": "The number of files that have been successfully processed." }).check(Schema.isInt()), "failed": Schema.Number.annotate({ "description": "The number of files that have failed to process." }).check(Schema.isInt()), "cancelled": Schema.Number.annotate({ "description": "The number of files that were cancelled." }).check(Schema.isInt()), "total": Schema.Number.annotate({ "description": "The total number of files." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]), "status": Schema.Literals(["expired", "in_progress", "completed"]).annotate({ "description": "The status of the vector store, which can be either \`expired\`, \`in_progress\`, or \`completed\`. A status of \`completed\` indicates that the vector store is ready for use." }), "expires_after": Schema.optionalKey(Schema.suspend((): Schema.Codec<VectorStoreExpirationAfter> => VectorStoreExpirationAfter)), "expires_at": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the vector store will expire." }).check(Schema.isInt()), Schema.Null])), "last_active_at": Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the vector store was last active." }).check(Schema.isInt()), Schema.Null]), "metadata": Schema.suspend((): Schema.Codec<Metadata> => Metadata) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Vector store", "description": "A vector store is a collection of processed files can be used by the \`file_search\` tool.", "identifier": "VectorStoreObject" })
export type FileSearchToolCall = { readonly "id": string, readonly "type": "file_search_call", readonly "status": "in_progress" | "searching" | "completed" | "incomplete" | "failed", readonly "queries": ReadonlyArray<string>, readonly "results"?: ReadonlyArray<{ readonly "file_id"?: string, readonly "text"?: string, readonly "filename"?: string, readonly "attributes"?: VectorStoreFileAttributes, readonly "score"?: number, readonly [x: string]: unknown }> | null, readonly [x: string]: unknown }
export const FileSearchToolCall = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the file search tool call.\\n" }), "type": Schema.Literal("file_search_call").annotate({ "description": "The type of the file search tool call. Always \`file_search_call\`.\\n" }), "status": Schema.Literals(["in_progress", "searching", "completed", "incomplete", "failed"]).annotate({ "description": "The status of the file search tool call. One of \`in_progress\`,\\n\`searching\`, \`incomplete\` or \`failed\`,\\n" }), "queries": Schema.Array(Schema.String).annotate({ "description": "The queries used to search for files.\\n" }), "results": Schema.optionalKey(Schema.Union([Schema.Array(Schema.StructWithRest(Schema.Struct({ "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the file.\\n" })), "text": Schema.optionalKey(Schema.String.annotate({ "description": "The text that was retrieved from the file.\\n" })), "filename": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the file.\\n" })), "attributes": Schema.optionalKey(Schema.suspend((): Schema.Codec<VectorStoreFileAttributes> => VectorStoreFileAttributes)), "score": Schema.optionalKey(Schema.Number.annotate({ "description": "The relevance score of the file - a value between 0 and 1.\\n", "format": "float" }).check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The results of the file search tool call.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File search tool call", "description": "The results of a file search tool call. See the\\n[file search guide](https://platform.openai.com/docs/guides/tools-file-search) for more information.\\n", "identifier": "FileSearchToolCall" })
export type UpdateVectorStoreFileAttributesRequest = { readonly "attributes": VectorStoreFileAttributes }
export const UpdateVectorStoreFileAttributesRequest = Schema.Struct({ "attributes": Schema.suspend((): Schema.Codec<VectorStoreFileAttributes> => VectorStoreFileAttributes) }).annotate({ "identifier": "UpdateVectorStoreFileAttributesRequest" })
export type VectorStoreSearchResultItem = { readonly "file_id": string, readonly "filename": string, readonly "score": number, readonly "attributes": VectorStoreFileAttributes, readonly "content": ReadonlyArray<VectorStoreSearchResultContentObject> }
export const VectorStoreSearchResultItem = Schema.Struct({ "file_id": Schema.String.annotate({ "description": "The ID of the vector store file." }), "filename": Schema.String.annotate({ "description": "The name of the vector store file." }), "score": Schema.Number.annotate({ "description": "The similarity score for the result." }).check(Schema.isFinite()), "attributes": Schema.suspend((): Schema.Codec<VectorStoreFileAttributes> => VectorStoreFileAttributes), "content": Schema.Array(Schema.suspend((): Schema.Codec<VectorStoreSearchResultContentObject> => VectorStoreSearchResultContentObject)).annotate({ "description": "Content chunks from the file." }) }).annotate({ "identifier": "VectorStoreSearchResultItem" })
export type VoiceConsentListResource = { readonly "object": "list", readonly "data": ReadonlyArray<VoiceConsentResource>, readonly "first_id"?: string | null, readonly "last_id"?: string | null, readonly "has_more": boolean }
export const VoiceConsentListResource = Schema.Struct({ "object": Schema.Literal("list"), "data": Schema.Array(VoiceConsentResource), "first_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])), "last_id": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null])), "has_more": Schema.Boolean }).annotate({ "identifier": "VoiceConsentListResource" })
export type RealtimeSessionCreateResponse = { readonly "id"?: string, readonly "object"?: string, readonly "expires_at"?: number, readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">, readonly "model"?: string, readonly "output_modalities"?: ReadonlyArray<"text" | "audio">, readonly "instructions"?: string, readonly "audio"?: { readonly "input"?: { readonly "format"?: RealtimeAudioFormats, readonly "transcription"?: AudioTranscription, readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType, readonly [x: string]: unknown }, readonly "turn_detection"?: { readonly "type"?: string, readonly "threshold"?: number, readonly "prefix_padding_ms"?: number, readonly "silence_duration_ms"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "output"?: { readonly "format"?: RealtimeAudioFormats, readonly "voice"?: VoiceIdsShared, readonly "speed"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "tracing"?: "auto" | { readonly "workflow_name"?: string, readonly "group_id"?: string, readonly "metadata"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "turn_detection"?: { readonly "type"?: string, readonly "threshold"?: number, readonly "prefix_padding_ms"?: number, readonly "silence_duration_ms"?: number, readonly [x: string]: unknown }, readonly "tools"?: ReadonlyArray<RealtimeFunctionTool>, readonly "tool_choice"?: string, readonly "max_output_tokens"?: number | "inf", readonly [x: string]: unknown }
export const RealtimeSessionCreateResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "Unique identifier for the session that looks like \`sess_1234567890abcdef\`.\\n" })), "object": Schema.optionalKey(Schema.String.annotate({ "description": "The object type. Always \`realtime.session\`." })), "expires_at": Schema.optionalKey(Schema.Number.annotate({ "description": "Expiration timestamp for the session, in seconds since epoch." }).check(Schema.isInt())), "include": Schema.optionalKey(Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({ "description": "Additional fields to include in server outputs.\\n- \`item.input_audio_transcription.logprobs\`: Include logprobs for input audio transcription.\\n" })), "model": Schema.optionalKey(Schema.String.annotate({ "description": "The Realtime model used for this session." })), "output_modalities": Schema.optionalKey(Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "The set of modalities the model can respond with. To disable audio,\\nset this to [\\"text\\"].\\n" })), "instructions": Schema.optionalKey(Schema.String.annotate({ "description": "The default system instructions (i.e. system message) prepended to model\\ncalls. This field allows the client to guide the model on desired\\nresponses. The model can be instructed on response content and format,\\n(e.g. \\"be extremely succinct\\", \\"act friendly\\", \\"here are examples of good\\nresponses\\") and on audio behavior (e.g. \\"talk quickly\\", \\"inject emotion\\ninto your voice\\", \\"laugh frequently\\"). The instructions are not guaranteed\\nto be followed by the model, but they provide guidance to the model on the\\ndesired behavior.\\n\\nNote that the server sets default instructions which will be used if this\\nfield is not set and are visible in the \`session.created\` event at the\\nstart of the session.\\n" })), "audio": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "input": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeAudioFormats> => RealtimeAudioFormats)), "transcription": Schema.optionalKey(Schema.suspend((): Schema.Codec<AudioTranscription> => AudioTranscription).annotate({ "description": "Configuration for input audio transcription.\\n" })), "noise_reduction": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.suspend((): Schema.Codec<NoiseReductionType> => NoiseReductionType)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input audio noise reduction.\\n" })), "turn_detection": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "Type of turn detection, only \`server_vad\` is currently supported.\\n" })), "threshold": Schema.optionalKey(Schema.Number.check(Schema.isFinite())), "prefix_padding_ms": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "silence_duration_ms": Schema.optionalKey(Schema.Number.check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for turn detection.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "output": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeAudioFormats> => RealtimeAudioFormats)), "voice": Schema.optionalKey(Schema.suspend((): Schema.Codec<VoiceIdsShared> => VoiceIdsShared)), "speed": Schema.optionalKey(Schema.Number.check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input and output audio for the session.\\n" })), "tracing": Schema.optionalKey(Schema.Union([Schema.Literal("auto").annotate({ "description": "Default tracing mode for the session.\\n", "default": "auto" }), Schema.StructWithRest(Schema.Struct({ "workflow_name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the workflow to attach to this trace. This is used to\\nname the trace in the traces dashboard.\\n" })), "group_id": Schema.optionalKey(Schema.String.annotate({ "description": "The group id to attach to this trace to enable filtering and\\ngrouping in the traces dashboard.\\n" })), "metadata": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The arbitrary metadata to attach to this trace to enable\\nfiltering in the traces dashboard.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\\n" })]).annotate({ "title": "Tracing Configuration", "description": "Configuration options for tracing. Set to null to disable tracing. Once\\ntracing is enabled for a session, the configuration cannot be modified.\\n\\n\`auto\` will create a trace for the session with default values for the\\nworkflow name, group id, and metadata.\\n" })), "turn_detection": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "Type of turn detection, only \`server_vad\` is currently supported.\\n" })), "threshold": Schema.optionalKey(Schema.Number.annotate({ "description": "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\\nhigher threshold will require louder audio to activate the model, and\\nthus might perform better in noisy environments.\\n" }).check(Schema.isFinite())), "prefix_padding_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Amount of audio to include before the VAD detected speech (in\\nmilliseconds). Defaults to 300ms.\\n" }).check(Schema.isInt())), "silence_duration_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Duration of silence to detect speech stop (in milliseconds). Defaults\\nto 500ms. With shorter values the model will respond more quickly,\\nbut may jump in on short pauses from the user.\\n" }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for turn detection. Can be set to \`null\` to turn off. Server\\nVAD means that the model will detect the start and end of speech based on\\naudio volume and respond at the end of user speech.\\n" })), "tools": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<RealtimeFunctionTool> => RealtimeFunctionTool)).annotate({ "description": "Tools (functions) available to the model." })), "tool_choice": Schema.optionalKey(Schema.String.annotate({ "description": "How the model chooses tools. Options are \`auto\`, \`none\`, \`required\`, or\\nspecify a function.\\n" })), "max_output_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")]).annotate({ "description": "Maximum number of output tokens for a single assistant response,\\ninclusive of tool calls. Provide an integer between 1 and 4096 to\\nlimit output tokens, or \`inf\` for the maximum available tokens for a\\ngiven model. Defaults to \`inf\`.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime session configuration object", "description": "A Realtime session configuration object.\\n", "identifier": "RealtimeSessionCreateResponse" })
export type WebSearchToolCall = { readonly "id": string, readonly "type": "web_search_call", readonly "status": "in_progress" | "searching" | "completed" | "failed", readonly "action": WebSearchActionSearch | WebSearchActionOpenPage | WebSearchActionFind, readonly [x: string]: unknown }
export const WebSearchToolCall = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the web search tool call.\\n" }), "type": Schema.Literal("web_search_call").annotate({ "description": "The type of the web search tool call. Always \`web_search_call\`.\\n" }), "status": Schema.Literals(["in_progress", "searching", "completed", "failed"]).annotate({ "description": "The status of the web search tool call.\\n" }), "action": Schema.Union([Schema.suspend((): Schema.Codec<WebSearchActionSearch> => WebSearchActionSearch), Schema.suspend((): Schema.Codec<WebSearchActionOpenPage> => WebSearchActionOpenPage), Schema.suspend((): Schema.Codec<WebSearchActionFind> => WebSearchActionFind)]).annotate({ "description": "An object describing the specific action taken in this web search call.\\nIncludes details on how the model used the web (search, open_page, find).\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Web search tool call", "description": "The results of a web search tool call. See the\\n[web search guide](https://platform.openai.com/docs/guides/tools-web-search) for more information.\\n", "identifier": "WebSearchToolCall" })
export type WebSearchTool = { readonly "type": "web_search" | "web_search_2025_08_26", readonly "filters"?: { readonly "allowed_domains"?: ReadonlyArray<string> | null, readonly [x: string]: unknown } | null, readonly "user_location"?: WebSearchApproximateLocation, readonly "search_context_size"?: "low" | "medium" | "high", readonly [x: string]: unknown }
export const WebSearchTool = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literals(["web_search", "web_search_2025_08_26"]).annotate({ "description": "The type of the web search tool. One of \`web_search\` or \`web_search_2025_08_26\`.", "default": "web_search" }), "filters": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "allowed_domains": Schema.optionalKey(Schema.Union([Schema.Array(Schema.String.annotate({ "description": "Allowed domain for the search." })).annotate({ "title": "Allowed domains for the search.", "description": "Allowed domains for the search. If not provided, all domains are allowed.\\nSubdomains of the provided domains are allowed as well.\\n\\nExample: \`[\\"pubmed.ncbi.nlm.nih.gov\\"]\`\\n", "default": [] }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Filters for the search.\\n" }), Schema.Null])), "user_location": Schema.optionalKey(Schema.suspend((): Schema.Codec<WebSearchApproximateLocation> => WebSearchApproximateLocation)), "search_context_size": Schema.optionalKey(Schema.Literals(["low", "medium", "high"]).annotate({ "description": "High level guidance for the amount of context window space to use for the search. One of \`low\`, \`medium\`, or \`high\`. \`medium\` is the default.", "default": "medium" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Web search", "description": "Search the Internet for sources related to the prompt. Learn more about the\\n[web search tool](https://platform.openai.com/docs/guides/tools-web-search).\\n", "identifier": "WebSearchTool" })
export type EvalItemContentItem = EvalItemContentText | InputTextContent | EvalItemContentOutputText | EvalItemInputImage | InputAudio
export const EvalItemContentItem = Schema.Union([EvalItemContentText, InputTextContent, EvalItemContentOutputText, EvalItemInputImage, InputAudio]).annotate({ "title": "Eval content item", "description": "A single content item: input text, output text, input image, or input audio.\\n", "identifier": "EvalItemContentItem" })
export type Annotation = FileCitationBody | UrlCitationBody | ContainerFileCitationBody | FilePath
export const Annotation = Schema.Union([Schema.suspend((): Schema.Codec<FileCitationBody> => FileCitationBody), Schema.suspend((): Schema.Codec<UrlCitationBody> => UrlCitationBody), Schema.suspend((): Schema.Codec<ContainerFileCitationBody> => ContainerFileCitationBody), Schema.suspend((): Schema.Codec<FilePath> => FilePath)]).annotate({ "identifier": "Annotation" })
export type LogProb = { readonly "token": string, readonly "logprob": number, readonly "bytes": ReadonlyArray<number>, readonly "top_logprobs": ReadonlyArray<TopLogProb>, readonly [x: string]: unknown }
export const LogProb = Schema.StructWithRest(Schema.Struct({ "token": Schema.String, "logprob": Schema.Number.check(Schema.isFinite()), "bytes": Schema.Array(Schema.Number.check(Schema.isInt())), "top_logprobs": Schema.Array(Schema.suspend((): Schema.Codec<TopLogProb> => TopLogProb)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Log probability", "description": "The log probability of a token.", "identifier": "LogProb" })
export type InputImageContent = { readonly "type": "input_image", readonly "image_url"?: string | null, readonly "file_id"?: string | null, readonly "detail": ImageDetail, readonly [x: string]: unknown }
export const InputImageContent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_image").annotate({ "description": "The type of the input item. Always \`input_image\`.", "default": "input_image" }), "image_url": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL." }), Schema.Null])), "file_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the file to be sent to the model." }), Schema.Null])), "detail": Schema.suspend((): Schema.Codec<ImageDetail> => ImageDetail).annotate({ "description": "The detail level of the image to be sent to the model. One of \`high\`, \`low\`, or \`auto\`. Defaults to \`auto\`." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input image", "description": "An image input to the model. Learn about [image inputs](https://platform.openai.com/docs/guides/vision).", "identifier": "InputImageContent" })
export type ClickParam = { readonly "type": "click", readonly "button": ClickButtonType, readonly "x": number, readonly "y": number, readonly [x: string]: unknown }
export const ClickParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("click").annotate({ "description": "Specifies the event type. For a click action, this property is always \`click\`.", "default": "click" }), "button": Schema.suspend((): Schema.Codec<ClickButtonType> => ClickButtonType).annotate({ "description": "Indicates which mouse button was pressed during the click. One of \`left\`, \`right\`, \`wheel\`, \`back\`, or \`forward\`." }), "x": Schema.Number.annotate({ "description": "The x-coordinate where the click occurred." }).check(Schema.isInt()), "y": Schema.Number.annotate({ "description": "The y-coordinate where the click occurred." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Click", "description": "A click action.", "identifier": "ClickParam" })
export type Drag = { readonly "type": "drag", readonly "path": ReadonlyArray<DragPoint>, readonly [x: string]: unknown }
export const Drag = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("drag").annotate({ "description": "Specifies the event type. For a drag action, this property is \\nalways set to \`drag\`.\\n", "default": "drag" }), "path": Schema.Array(DragPoint).annotate({ "description": "An array of coordinates representing the path of the drag action. Coordinates will appear as an array\\nof objects, eg\\n\`\`\`\\n[\\n  { x: 100, y: 200 },\\n  { x: 200, y: 300 }\\n]\\n\`\`\`\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Drag", "description": "A drag action.\\n", "identifier": "Drag" })
export type ComputerToolCallOutput = { readonly "type": "computer_call_output", readonly "id"?: string, readonly "call_id": string, readonly "acknowledged_safety_checks"?: ReadonlyArray<ComputerCallSafetyCheckParam>, readonly "output": ComputerScreenshotImage, readonly "status"?: "in_progress" | "completed" | "incomplete", readonly [x: string]: unknown }
export const ComputerToolCallOutput = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("computer_call_output").annotate({ "description": "The type of the computer tool call output. Always \`computer_call_output\`.\\n", "default": "computer_call_output" }), "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the computer tool call output.\\n" })), "call_id": Schema.String.annotate({ "description": "The ID of the computer tool call that produced the output.\\n" }), "acknowledged_safety_checks": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<ComputerCallSafetyCheckParam> => ComputerCallSafetyCheckParam)).annotate({ "description": "The safety checks reported by the API that have been acknowledged by the\\ndeveloper.\\n" })), "output": Schema.suspend((): Schema.Codec<ComputerScreenshotImage> => ComputerScreenshotImage), "status": Schema.optionalKey(Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "description": "The status of the message input. One of \`in_progress\`, \`completed\`, or\\n\`incomplete\`. Populated when input items are returned via API.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Computer tool call output", "description": "The output of a computer tool call.\\n", "identifier": "ComputerToolCallOutput" })
export type CodeInterpreterToolCall = { readonly "type": "code_interpreter_call", readonly "id": string, readonly "status": "in_progress" | "completed" | "incomplete" | "interpreting" | "failed", readonly "container_id": string, readonly "code": string | null, readonly "outputs": ReadonlyArray<CodeInterpreterOutputLogs | CodeInterpreterOutputImage> | null, readonly [x: string]: unknown }
export const CodeInterpreterToolCall = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("code_interpreter_call").annotate({ "description": "The type of the code interpreter tool call. Always \`code_interpreter_call\`.\\n", "default": "code_interpreter_call" }), "id": Schema.String.annotate({ "description": "The unique ID of the code interpreter tool call.\\n" }), "status": Schema.Literals(["in_progress", "completed", "incomplete", "interpreting", "failed"]).annotate({ "description": "The status of the code interpreter tool call. Valid values are \`in_progress\`, \`completed\`, \`incomplete\`, \`interpreting\`, and \`failed\`.\\n" }), "container_id": Schema.String.annotate({ "description": "The ID of the container used to run the code.\\n" }), "code": Schema.Union([Schema.String.annotate({ "description": "The code to run, or null if not available.\\n" }), Schema.Null]), "outputs": Schema.Union([Schema.Array(Schema.Union([CodeInterpreterOutputLogs, CodeInterpreterOutputImage])).annotate({ "description": "The outputs generated by the code interpreter, such as logs or images.\\nCan be null if no outputs are available.\\n" }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code interpreter tool call", "description": "A tool call to run code.\\n", "identifier": "CodeInterpreterToolCall" })
export type LocalShellToolCall = { readonly "type": "local_shell_call", readonly "id": string, readonly "call_id": string, readonly "action": LocalShellExecAction, readonly "status": "in_progress" | "completed" | "incomplete", readonly [x: string]: unknown }
export const LocalShellToolCall = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("local_shell_call").annotate({ "description": "The type of the local shell call. Always \`local_shell_call\`.\\n" }), "id": Schema.String.annotate({ "description": "The unique ID of the local shell call.\\n" }), "call_id": Schema.String.annotate({ "description": "The unique ID of the local shell tool call generated by the model.\\n" }), "action": LocalShellExecAction, "status": Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "description": "The status of the local shell call.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Local shell call", "description": "A tool call to run a command on the local shell.\\n", "identifier": "LocalShellToolCall" })
export type FunctionShellCall = { readonly "type": "shell_call", readonly "id": string, readonly "call_id": string, readonly "action": FunctionShellAction, readonly "status": LocalShellCallStatus, readonly "created_by"?: string, readonly [x: string]: unknown }
export const FunctionShellCall = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("shell_call").annotate({ "description": "The type of the item. Always \`shell_call\`.", "default": "shell_call" }), "id": Schema.String.annotate({ "description": "The unique ID of the shell tool call. Populated when this item is returned via API." }), "call_id": Schema.String.annotate({ "description": "The unique ID of the shell tool call generated by the model." }), "action": Schema.suspend((): Schema.Codec<FunctionShellAction> => FunctionShellAction).annotate({ "description": "The shell commands and limits that describe how to run the tool call." }), "status": Schema.suspend((): Schema.Codec<LocalShellCallStatus> => LocalShellCallStatus).annotate({ "description": "The status of the shell call. One of \`in_progress\`, \`completed\`, or \`incomplete\`." }), "created_by": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the entity that created this tool call." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell tool call", "description": "A tool call that executes one or more shell commands in a managed environment.", "identifier": "FunctionShellCall" })
export type FunctionShellCallOutputContent = { readonly "stdout": string, readonly "stderr": string, readonly "outcome": FunctionShellCallOutputTimeoutOutcome | FunctionShellCallOutputExitOutcome, readonly "created_by"?: string, readonly [x: string]: unknown }
export const FunctionShellCallOutputContent = Schema.StructWithRest(Schema.Struct({ "stdout": Schema.String, "stderr": Schema.String, "outcome": Schema.Union([Schema.suspend((): Schema.Codec<FunctionShellCallOutputTimeoutOutcome> => FunctionShellCallOutputTimeoutOutcome), Schema.suspend((): Schema.Codec<FunctionShellCallOutputExitOutcome> => FunctionShellCallOutputExitOutcome)]).annotate({ "title": "Shell call outcome", "description": "Represents either an exit outcome (with an exit code) or a timeout outcome for a shell call output chunk." }), "created_by": Schema.optionalKey(Schema.String) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell call output content", "description": "The content of a shell call output.", "identifier": "FunctionShellCallOutputContent" })
export type ApplyPatchToolCall = { readonly "type": "apply_patch_call", readonly "id": string, readonly "call_id": string, readonly "status": ApplyPatchCallStatus, readonly "operation": ApplyPatchCreateFileOperation | ApplyPatchDeleteFileOperation | ApplyPatchUpdateFileOperation, readonly "created_by"?: string, readonly [x: string]: unknown }
export const ApplyPatchToolCall = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("apply_patch_call").annotate({ "description": "The type of the item. Always \`apply_patch_call\`.", "default": "apply_patch_call" }), "id": Schema.String.annotate({ "description": "The unique ID of the apply patch tool call. Populated when this item is returned via API." }), "call_id": Schema.String.annotate({ "description": "The unique ID of the apply patch tool call generated by the model." }), "status": Schema.suspend((): Schema.Codec<ApplyPatchCallStatus> => ApplyPatchCallStatus).annotate({ "description": "The status of the apply patch tool call. One of \`in_progress\` or \`completed\`." }), "operation": Schema.Union([Schema.suspend((): Schema.Codec<ApplyPatchCreateFileOperation> => ApplyPatchCreateFileOperation), Schema.suspend((): Schema.Codec<ApplyPatchDeleteFileOperation> => ApplyPatchDeleteFileOperation), Schema.suspend((): Schema.Codec<ApplyPatchUpdateFileOperation> => ApplyPatchUpdateFileOperation)]).annotate({ "title": "Apply patch operation", "description": "One of the create_file, delete_file, or update_file operations applied via apply_patch." }), "created_by": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the entity that created this tool call." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch tool call", "description": "A tool call that applies file diffs by creating, deleting, or updating files.", "identifier": "ApplyPatchToolCall" })
export type ApplyPatchToolCallOutput = { readonly "type": "apply_patch_call_output", readonly "id": string, readonly "call_id": string, readonly "status": ApplyPatchCallOutputStatus, readonly "output"?: string | null, readonly "created_by"?: string, readonly [x: string]: unknown }
export const ApplyPatchToolCallOutput = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("apply_patch_call_output").annotate({ "description": "The type of the item. Always \`apply_patch_call_output\`.", "default": "apply_patch_call_output" }), "id": Schema.String.annotate({ "description": "The unique ID of the apply patch tool call output. Populated when this item is returned via API." }), "call_id": Schema.String.annotate({ "description": "The unique ID of the apply patch tool call generated by the model." }), "status": Schema.suspend((): Schema.Codec<ApplyPatchCallOutputStatus> => ApplyPatchCallOutputStatus).annotate({ "description": "The status of the apply patch tool call output. One of \`completed\` or \`failed\`." }), "output": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Optional textual output returned by the apply patch tool." }), Schema.Null])), "created_by": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the entity that created this tool call output." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch tool call output", "description": "The output emitted by an apply patch tool call.", "identifier": "ApplyPatchToolCallOutput" })
export type InputImageContentParamAutoParam = { readonly "type": "input_image", readonly "image_url"?: string | null, readonly "file_id"?: string | null, readonly "detail"?: DetailEnum | null, readonly [x: string]: unknown }
export const InputImageContentParamAutoParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("input_image").annotate({ "description": "The type of the input item. Always \`input_image\`.", "default": "input_image" }), "image_url": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL." }), Schema.Null])), "file_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the file to be sent to the model." }), Schema.Null])), "detail": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<DetailEnum> => DetailEnum).annotate({ "description": "The detail level of the image to be sent to the model. One of \`high\`, \`low\`, or \`auto\`. Defaults to \`auto\`." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input image", "description": "An image input to the model. Learn about [image inputs](https://platform.openai.com/docs/guides/vision)", "identifier": "InputImageContentParamAutoParam" })
export type ComputerCallOutputItemParam = { readonly "id"?: string | null, readonly "call_id": string, readonly "type": "computer_call_output", readonly "output": ComputerScreenshotImage, readonly "acknowledged_safety_checks"?: ReadonlyArray<ComputerCallSafetyCheckParam> | null, readonly "status"?: FunctionCallItemStatus | null, readonly [x: string]: unknown }
export const ComputerCallOutputItemParam = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the computer tool call output." }), Schema.Null])), "call_id": Schema.String.annotate({ "description": "The ID of the computer tool call that produced the output." }), "type": Schema.Literal("computer_call_output").annotate({ "description": "The type of the computer tool call output. Always \`computer_call_output\`.", "default": "computer_call_output" }), "output": Schema.suspend((): Schema.Codec<ComputerScreenshotImage> => ComputerScreenshotImage), "acknowledged_safety_checks": Schema.optionalKey(Schema.Union([Schema.Array(Schema.suspend((): Schema.Codec<ComputerCallSafetyCheckParam> => ComputerCallSafetyCheckParam)).annotate({ "description": "The safety checks reported by the API that have been acknowledged by the developer." }), Schema.Null])), "status": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<FunctionCallItemStatus> => FunctionCallItemStatus).annotate({ "description": "The status of the message input. One of \`in_progress\`, \`completed\`, or \`incomplete\`. Populated when input items are returned via API." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Computer tool call output", "description": "The output of a computer tool call.", "identifier": "ComputerCallOutputItemParam" })
export type FunctionShellCallItemParam = { readonly "id"?: string | null, readonly "call_id": string, readonly "type": "shell_call", readonly "action": FunctionShellActionParam, readonly "status"?: FunctionShellCallItemStatus | null, readonly [x: string]: unknown }
export const FunctionShellCallItemParam = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The unique ID of the shell tool call. Populated when this item is returned via API." }), Schema.Null])), "call_id": Schema.String.annotate({ "description": "The unique ID of the shell tool call generated by the model." }), "type": Schema.Literal("shell_call").annotate({ "description": "The type of the item. Always \`shell_call\`.", "default": "shell_call" }), "action": Schema.suspend((): Schema.Codec<FunctionShellActionParam> => FunctionShellActionParam).annotate({ "description": "The shell commands and limits that describe how to run the tool call." }), "status": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<FunctionShellCallItemStatus> => FunctionShellCallItemStatus).annotate({ "description": "The status of the shell call. One of \`in_progress\`, \`completed\`, or \`incomplete\`." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell tool call", "description": "A tool representing a request to execute one or more shell commands.", "identifier": "FunctionShellCallItemParam" })
export type FunctionShellCallOutputOutcomeParam = FunctionShellCallOutputTimeoutOutcomeParam | FunctionShellCallOutputExitOutcomeParam
export const FunctionShellCallOutputOutcomeParam = Schema.Union([Schema.suspend((): Schema.Codec<FunctionShellCallOutputTimeoutOutcomeParam> => FunctionShellCallOutputTimeoutOutcomeParam), Schema.suspend((): Schema.Codec<FunctionShellCallOutputExitOutcomeParam> => FunctionShellCallOutputExitOutcomeParam)]).annotate({ "title": "Shell call outcome", "description": "The exit or timeout outcome associated with this shell call.", "identifier": "FunctionShellCallOutputOutcomeParam" })
export type ApplyPatchOperationParam = ApplyPatchCreateFileOperationParam | ApplyPatchDeleteFileOperationParam | ApplyPatchUpdateFileOperationParam
export const ApplyPatchOperationParam = Schema.Union([Schema.suspend((): Schema.Codec<ApplyPatchCreateFileOperationParam> => ApplyPatchCreateFileOperationParam), Schema.suspend((): Schema.Codec<ApplyPatchDeleteFileOperationParam> => ApplyPatchDeleteFileOperationParam), Schema.suspend((): Schema.Codec<ApplyPatchUpdateFileOperationParam> => ApplyPatchUpdateFileOperationParam)]).annotate({ "title": "Apply patch operation", "description": "One of the create_file, delete_file, or update_file operations supplied to the apply_patch tool.", "identifier": "ApplyPatchOperationParam" })
export type ApplyPatchToolCallOutputItemParam = { readonly "type": "apply_patch_call_output", readonly "id"?: string | null, readonly "call_id": string, readonly "status": ApplyPatchCallOutputStatusParam, readonly "output"?: string | null, readonly [x: string]: unknown }
export const ApplyPatchToolCallOutputItemParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("apply_patch_call_output").annotate({ "description": "The type of the item. Always \`apply_patch_call_output\`.", "default": "apply_patch_call_output" }), "id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The unique ID of the apply patch tool call output. Populated when this item is returned via API." }), Schema.Null])), "call_id": Schema.String.annotate({ "description": "The unique ID of the apply patch tool call generated by the model." }), "status": Schema.suspend((): Schema.Codec<ApplyPatchCallOutputStatusParam> => ApplyPatchCallOutputStatusParam).annotate({ "description": "The status of the apply patch tool call output. One of \`completed\` or \`failed\`." }), "output": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Optional human-readable log text from the apply patch tool (e.g., patch results or errors)." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch tool call output", "description": "The streamed output emitted by an apply patch tool call.", "identifier": "ApplyPatchToolCallOutputItemParam" })
export type RankingOptions = { readonly "ranker"?: RankerVersionType, readonly "score_threshold"?: number, readonly "hybrid_search"?: HybridSearchOptions, readonly [x: string]: unknown }
export const RankingOptions = Schema.StructWithRest(Schema.Struct({ "ranker": Schema.optionalKey(Schema.suspend((): Schema.Codec<RankerVersionType> => RankerVersionType).annotate({ "description": "The ranker to use for the file search." })), "score_threshold": Schema.optionalKey(Schema.Number.annotate({ "description": "The score threshold for the file search, a number between 0 and 1. Numbers closer to 1 will attempt to return only the most relevant results, but may return fewer results." }).check(Schema.isFinite())), "hybrid_search": Schema.optionalKey(Schema.suspend((): Schema.Codec<HybridSearchOptions> => HybridSearchOptions).annotate({ "description": "Weights that control how reciprocal rank fusion balances semantic embedding matches versus sparse keyword matches when hybrid search is enabled." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "RankingOptions" })
export type ComputerUsePreviewTool = { readonly "type": "computer_use_preview", readonly "environment": ComputerEnvironment, readonly "display_width": number, readonly "display_height": number, readonly [x: string]: unknown }
export const ComputerUsePreviewTool = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("computer_use_preview").annotate({ "description": "The type of the computer use tool. Always \`computer_use_preview\`.", "default": "computer_use_preview" }), "environment": Schema.suspend((): Schema.Codec<ComputerEnvironment> => ComputerEnvironment).annotate({ "description": "The type of computer environment to control." }), "display_width": Schema.Number.annotate({ "description": "The width of the computer display." }).check(Schema.isInt()), "display_height": Schema.Number.annotate({ "description": "The height of the computer display." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Computer use preview", "description": "A tool that controls a virtual computer. Learn more about the [computer tool](https://platform.openai.com/docs/guides/tools-computer-use).", "identifier": "ComputerUsePreviewTool" })
export type CodeInterpreterContainerAuto = { readonly "type": "auto", readonly "file_ids"?: ReadonlyArray<string>, readonly "memory_limit"?: ContainerMemoryLimit | null, readonly [x: string]: unknown }
export const CodeInterpreterContainerAuto = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("auto").annotate({ "description": "Always \`auto\`.", "default": "auto" }), "file_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "An optional list of uploaded files to make available to your code." })), "memory_limit": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ContainerMemoryLimit> => ContainerMemoryLimit), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "CodeInterpreterToolAuto", "description": "Configuration for a code interpreter container. Optionally specify the IDs of the files to run the code on.", "identifier": "CodeInterpreterContainerAuto" })
export type CreateImageEditRequest = { readonly "image": string | ReadonlyArray<string>, readonly "prompt": string, readonly "mask"?: string, readonly "background"?: "transparent" | "opaque" | "auto" | null, readonly "model"?: string | "gpt-image-1.5" | "dall-e-2" | "gpt-image-1" | "gpt-image-1-mini" | null, readonly "n"?: number | null, readonly "size"?: "256x256" | "512x512" | "1024x1024" | "1536x1024" | "1024x1536" | "auto" | null, readonly "response_format"?: "url" | "b64_json" | null, readonly "output_format"?: "png" | "jpeg" | "webp" | null, readonly "output_compression"?: number | null, readonly "user"?: string, readonly "input_fidelity"?: InputFidelity | null, readonly "stream"?: boolean | null, readonly "partial_images"?: PartialImages, readonly "quality"?: "standard" | "low" | "medium" | "high" | "auto" | null, readonly [x: string]: unknown }
export const CreateImageEditRequest = Schema.StructWithRest(Schema.Struct({ "image": Schema.Union([Schema.String.annotate({ "format": "binary" }), Schema.Array(Schema.String.annotate({ "format": "binary" }))]).annotate({ "description": "The image(s) to edit. Must be a supported image file or an array of images.\\n\\nFor the GPT image models (\`gpt-image-1\`, \`gpt-image-1-mini\`, and \`gpt-image-1.5\`), each image should be a \`png\`, \`webp\`, or \`jpg\`\\nfile less than 50MB. You can provide up to 16 images.\\n\\nFor \`dall-e-2\`, you can only provide one image, and it should be a square\\n\`png\` file less than 4MB.\\n" }), "prompt": Schema.String.annotate({ "description": "A text description of the desired image(s). The maximum length is 1000 characters for \`dall-e-2\`, and 32000 characters for the GPT image models." }), "mask": Schema.optionalKey(Schema.String.annotate({ "description": "An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where \`image\` should be edited. If there are multiple images provided, the mask will be applied on the first image. Must be a valid PNG file, less than 4MB, and have the same dimensions as \`image\`.", "format": "binary" })), "background": Schema.optionalKey(Schema.Union([Schema.Literal("transparent"), Schema.Literal("opaque"), Schema.Literal("auto"), Schema.Null]).annotate({ "description": "Allows to set transparency for the background of the generated image(s).\\nThis parameter is only supported for the GPT image models. Must be one of\\n\`transparent\`, \`opaque\` or \`auto\` (default value). When \`auto\` is used, the\\nmodel will automatically determine the best background for the image.\\n\\nIf \`transparent\`, the output format needs to support transparency, so it\\nshould be set to either \`png\` (default value) or \`webp\`.\\n", "default": "auto" })), "model": Schema.optionalKey(Schema.Union([Schema.Union([Schema.String, Schema.Literals(["gpt-image-1.5", "dall-e-2", "gpt-image-1", "gpt-image-1-mini"])]).annotate({ "description": "The model to use for image generation. Only \`dall-e-2\` and the GPT image models are supported. Defaults to \`dall-e-2\` unless a parameter specific to the GPT image models is used." }), Schema.Null])), "n": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The number of images to generate. Must be between 1 and 10.", "default": 1 })), "size": Schema.optionalKey(Schema.Union([Schema.Literal("256x256"), Schema.Literal("512x512"), Schema.Literal("1024x1024"), Schema.Literal("1536x1024"), Schema.Literal("1024x1536"), Schema.Literal("auto"), Schema.Null]).annotate({ "description": "The size of the generated images. Must be one of \`1024x1024\`, \`1536x1024\` (landscape), \`1024x1536\` (portrait), or \`auto\` (default value) for the GPT image models, and one of \`256x256\`, \`512x512\`, or \`1024x1024\` for \`dall-e-2\`.", "default": "1024x1024" })), "response_format": Schema.optionalKey(Schema.Union([Schema.Literal("url"), Schema.Literal("b64_json"), Schema.Null]).annotate({ "description": "The format in which the generated images are returned. Must be one of \`url\` or \`b64_json\`. URLs are only valid for 60 minutes after the image has been generated. This parameter is only supported for \`dall-e-2\`, as the GPT image models always return base64-encoded images.", "default": "url" })), "output_format": Schema.optionalKey(Schema.Union([Schema.Literal("png"), Schema.Literal("jpeg"), Schema.Literal("webp"), Schema.Null]).annotate({ "description": "The format in which the generated images are returned. This parameter is\\nonly supported for the GPT image models. Must be one of \`png\`, \`jpeg\`, or \`webp\`.\\nThe default value is \`png\`.\\n", "default": "png" })), "output_compression": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The compression level (0-100%) for the generated images. This parameter\\nis only supported for the GPT image models with the \`webp\` or \`jpeg\` output\\nformats, and defaults to 100.\\n", "default": 100 })), "user": Schema.optionalKey(Schema.String.annotate({ "description": "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\\n" })), "input_fidelity": Schema.optionalKey(Schema.Union([InputFidelity, Schema.Null])), "stream": Schema.optionalKey(Schema.Union([Schema.Boolean, Schema.Null]).annotate({ "description": "Edit the image in streaming mode. Defaults to \`false\`. See the\\n[Image generation guide](https://platform.openai.com/docs/guides/image-generation) for more information.\\n", "default": false })), "partial_images": Schema.optionalKey(PartialImages), "quality": Schema.optionalKey(Schema.Union([Schema.Literal("standard"), Schema.Literal("low"), Schema.Literal("medium"), Schema.Literal("high"), Schema.Literal("auto"), Schema.Null]).annotate({ "description": "The quality of the image that will be generated. \`high\`, \`medium\` and \`low\` are only supported for the GPT image models. \`dall-e-2\` only supports \`standard\` quality. Defaults to \`auto\`.\\n", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateImageEditRequest" })
export type ImageGenTool = { readonly "type": "image_generation", readonly "model"?: string | "gpt-image-1" | "gpt-image-1-mini", readonly "quality"?: "low" | "medium" | "high" | "auto", readonly "size"?: "1024x1024" | "1024x1536" | "1536x1024" | "auto", readonly "output_format"?: "png" | "webp" | "jpeg", readonly "output_compression"?: number, readonly "moderation"?: "auto" | "low", readonly "background"?: "transparent" | "opaque" | "auto", readonly "input_fidelity"?: InputFidelity | null, readonly "input_image_mask"?: { readonly "image_url"?: string, readonly "file_id"?: string }, readonly "partial_images"?: number, readonly [x: string]: unknown }
export const ImageGenTool = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("image_generation").annotate({ "description": "The type of the image generation tool. Always \`image_generation\`.\\n" }), "model": Schema.optionalKey(Schema.Union([Schema.String, Schema.Literals(["gpt-image-1", "gpt-image-1-mini"]).annotate({ "description": "The image generation model to use. Default: \`gpt-image-1\`.\\n", "default": "gpt-image-1" })])), "quality": Schema.optionalKey(Schema.Literals(["low", "medium", "high", "auto"]).annotate({ "description": "The quality of the generated image. One of \`low\`, \`medium\`, \`high\`,\\nor \`auto\`. Default: \`auto\`.\\n", "default": "auto" })), "size": Schema.optionalKey(Schema.Literals(["1024x1024", "1024x1536", "1536x1024", "auto"]).annotate({ "description": "The size of the generated image. One of \`1024x1024\`, \`1024x1536\`,\\n\`1536x1024\`, or \`auto\`. Default: \`auto\`.\\n", "default": "auto" })), "output_format": Schema.optionalKey(Schema.Literals(["png", "webp", "jpeg"]).annotate({ "description": "The output format of the generated image. One of \`png\`, \`webp\`, or\\n\`jpeg\`. Default: \`png\`.\\n", "default": "png" })), "output_compression": Schema.optionalKey(Schema.Number.annotate({ "description": "Compression level for the output image. Default: 100.\\n", "default": 100 }).check(Schema.isInt())), "moderation": Schema.optionalKey(Schema.Literals(["auto", "low"]).annotate({ "description": "Moderation level for the generated image. Default: \`auto\`.\\n", "default": "auto" })), "background": Schema.optionalKey(Schema.Literals(["transparent", "opaque", "auto"]).annotate({ "description": "Background type for the generated image. One of \`transparent\`,\\n\`opaque\`, or \`auto\`. Default: \`auto\`.\\n", "default": "auto" })), "input_fidelity": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<InputFidelity> => InputFidelity), Schema.Null])), "input_image_mask": Schema.optionalKey(Schema.Struct({ "image_url": Schema.optionalKey(Schema.String.annotate({ "description": "Base64-encoded mask image.\\n" })), "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "File ID for the mask image.\\n" })) }).annotate({ "description": "Optional mask for inpainting. Contains \`image_url\`\\n(string, optional) and \`file_id\` (string, optional).\\n" })), "partial_images": Schema.optionalKey(Schema.Number.annotate({ "description": "Number of partial images to generate in streaming mode, from 0 (default value) to 3.\\n", "default": 0 }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Image generation tool", "description": "A tool that generates images using the GPT image models.\\n", "identifier": "ImageGenTool" })
export type CustomGrammarFormatParam = { readonly "type": "grammar", readonly "syntax": GrammarSyntax1, readonly "definition": string, readonly [x: string]: unknown }
export const CustomGrammarFormatParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("grammar").annotate({ "description": "Grammar format. Always \`grammar\`.", "default": "grammar" }), "syntax": Schema.suspend((): Schema.Codec<GrammarSyntax1> => GrammarSyntax1).annotate({ "description": "The syntax of the grammar definition. One of \`lark\` or \`regex\`." }), "definition": Schema.String.annotate({ "description": "The grammar definition." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Grammar format", "description": "A grammar defined by the user.", "identifier": "CustomGrammarFormatParam" })
export type WebSearchPreviewTool = { readonly "type": "web_search_preview" | "web_search_preview_2025_03_11", readonly "user_location"?: ApproximateLocation | null, readonly "search_context_size"?: SearchContextSize, readonly [x: string]: unknown }
export const WebSearchPreviewTool = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literals(["web_search_preview", "web_search_preview_2025_03_11"]).annotate({ "description": "The type of the web search tool. One of \`web_search_preview\` or \`web_search_preview_2025_03_11\`.", "default": "web_search_preview" }), "user_location": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ApproximateLocation> => ApproximateLocation).annotate({ "description": "The user's location." }), Schema.Null])), "search_context_size": Schema.optionalKey(Schema.suspend((): Schema.Codec<SearchContextSize> => SearchContextSize).annotate({ "description": "High level guidance for the amount of context window space to use for the search. One of \`low\`, \`medium\`, or \`high\`. \`medium\` is the default." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Web search preview", "description": "This tool searches the web for relevant results to use in a response. Learn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search).", "identifier": "WebSearchPreviewTool" })
export type ImageGenUsage = { readonly "input_tokens": number, readonly "total_tokens": number, readonly "output_tokens": number, readonly "output_tokens_details"?: ImageGenOutputTokensDetails, readonly "input_tokens_details": ImageGenInputUsageDetails, readonly [x: string]: unknown }
export const ImageGenUsage = Schema.StructWithRest(Schema.Struct({ "input_tokens": Schema.Number.annotate({ "description": "The number of tokens (images and text) in the input prompt." }).check(Schema.isInt()), "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens (images and text) used for the image generation." }).check(Schema.isInt()), "output_tokens": Schema.Number.annotate({ "description": "The number of output tokens generated by the model." }).check(Schema.isInt()), "output_tokens_details": Schema.optionalKey(Schema.suspend((): Schema.Codec<ImageGenOutputTokensDetails> => ImageGenOutputTokensDetails)), "input_tokens_details": Schema.suspend((): Schema.Codec<ImageGenInputUsageDetails> => ImageGenInputUsageDetails) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Image generation usage", "description": "For \`gpt-image-1\` only, the token usage information for the image generation.", "identifier": "ImageGenUsage" })
export type ToolChoiceParam = ToolChoiceOptions | ToolChoiceAllowed | ToolChoiceTypes | ToolChoiceFunction | ToolChoiceMCP | ToolChoiceCustom | SpecificApplyPatchParam | SpecificFunctionShellParam
export const ToolChoiceParam = Schema.Union([Schema.suspend((): Schema.Codec<ToolChoiceOptions> => ToolChoiceOptions), Schema.suspend((): Schema.Codec<ToolChoiceAllowed> => ToolChoiceAllowed), ToolChoiceTypes, Schema.suspend((): Schema.Codec<ToolChoiceFunction> => ToolChoiceFunction), Schema.suspend((): Schema.Codec<ToolChoiceMCP> => ToolChoiceMCP), Schema.suspend((): Schema.Codec<ToolChoiceCustom> => ToolChoiceCustom), SpecificApplyPatchParam, SpecificFunctionShellParam]).annotate({ "description": "How the model should select which tool (or tools) to use when generating\\na response. See the \`tools\` parameter to see how to specify which tools\\nthe model can call.\\n", "identifier": "ToolChoiceParam" })
export type ConversationParam = string | ConversationParam_2
export const ConversationParam = Schema.Union([Schema.String.annotate({ "title": "Conversation ID", "description": "The unique ID of the conversation.\\n" }), ConversationParam_2]).annotate({ "description": "The conversation that this response belongs to. Items from this conversation are prepended to \`input_items\` for this response request.\\nInput items and output items from this response are automatically added to this conversation after this response completes.\\n", "identifier": "ConversationParam" })
export type CreateVideoBody = { readonly "model"?: VideoModel, readonly "prompt": string, readonly "input_reference"?: string, readonly "seconds"?: VideoSeconds, readonly "size"?: VideoSize, readonly [x: string]: unknown }
export const CreateVideoBody = Schema.StructWithRest(Schema.Struct({ "model": Schema.optionalKey(Schema.suspend((): Schema.Codec<VideoModel> => VideoModel).annotate({ "description": "The video generation model to use (allowed values: sora-2, sora-2-pro). Defaults to \`sora-2\`." })), "prompt": Schema.String.annotate({ "description": "Text prompt that describes the video to generate." }), "input_reference": Schema.optionalKey(Schema.String.annotate({ "description": "Optional image reference that guides generation.", "format": "binary" })), "seconds": Schema.optionalKey(Schema.suspend((): Schema.Codec<VideoSeconds> => VideoSeconds).annotate({ "description": "Clip duration in seconds (allowed values: 4, 8, 12). Defaults to 4 seconds." })), "size": Schema.optionalKey(Schema.suspend((): Schema.Codec<VideoSize> => VideoSize).annotate({ "description": "Output resolution formatted as width x height (allowed values: 720x1280, 1280x720, 1024x1792, 1792x1024). Defaults to 720x1280." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Create video request", "description": "Parameters for creating a new video generation job.", "identifier": "CreateVideoBody" })
export type VideoResource = { readonly "id": string, readonly "object": "video", readonly "model": VideoModel, readonly "status": VideoStatus, readonly "progress": number, readonly "created_at": number, readonly "completed_at": number | null, readonly "expires_at": number | null, readonly "prompt": string | null, readonly "size": VideoSize, readonly "seconds": VideoSeconds, readonly "remixed_from_video_id": string | null, readonly "error": Error_2 | null, readonly [x: string]: unknown }
export const VideoResource = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Unique identifier for the video job." }), "object": Schema.Literal("video").annotate({ "description": "The object type, which is always \`video\`.", "default": "video" }), "model": Schema.suspend((): Schema.Codec<VideoModel> => VideoModel).annotate({ "description": "The video generation model that produced the job." }), "status": Schema.suspend((): Schema.Codec<VideoStatus> => VideoStatus).annotate({ "description": "Current lifecycle status of the video job." }), "progress": Schema.Number.annotate({ "description": "Approximate completion percentage for the generation task." }).check(Schema.isInt()), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (seconds) for when the job was created." }).check(Schema.isInt()), "completed_at": Schema.Union([Schema.Number.annotate({ "description": "Unix timestamp (seconds) for when the job completed, if finished." }).check(Schema.isInt()), Schema.Null]), "expires_at": Schema.Union([Schema.Number.annotate({ "description": "Unix timestamp (seconds) for when the downloadable assets expire, if set." }).check(Schema.isInt()), Schema.Null]), "prompt": Schema.Union([Schema.String.annotate({ "description": "The prompt that was used to generate the video." }), Schema.Null]), "size": Schema.suspend((): Schema.Codec<VideoSize> => VideoSize).annotate({ "description": "The resolution of the generated video." }), "seconds": Schema.suspend((): Schema.Codec<VideoSeconds> => VideoSeconds).annotate({ "description": "Duration of the generated clip in seconds." }), "remixed_from_video_id": Schema.Union([Schema.String.annotate({ "description": "Identifier of the source video if this video is a remix." }), Schema.Null]), "error": Schema.Union([Schema.suspend((): Schema.Codec<Error_2> => Error_2).annotate({ "description": "Error payload that explains why generation failed, if applicable." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Video job", "description": "Structured information describing a generated video job.", "identifier": "VideoResource" })
export type ChatkitWorkflow = { readonly "id": string, readonly "version": string | null, readonly "state_variables": { readonly [x: string]: string | number | boolean | number } | null, readonly "tracing": ChatkitWorkflowTracing, readonly [x: string]: unknown }
export const ChatkitWorkflow = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the workflow backing the session." }), "version": Schema.Union([Schema.String.annotate({ "description": "Specific workflow version used for the session. Defaults to null when using the latest deployment." }), Schema.Null]), "state_variables": Schema.Union([Schema.Record(Schema.String, Schema.Union([Schema.String, Schema.Number.check(Schema.isInt()), Schema.Boolean, Schema.Number.check(Schema.isFinite())])).annotate({ "description": "State variable key-value pairs applied when invoking the workflow. Defaults to null when no overrides were provided." }), Schema.Null]), "tracing": Schema.suspend((): Schema.Codec<ChatkitWorkflowTracing> => ChatkitWorkflowTracing).annotate({ "description": "Tracing settings applied to the workflow." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Workflow", "description": "Workflow metadata and state returned for the session.", "identifier": "ChatkitWorkflow" })
export type ChatSessionChatkitConfiguration = { readonly "automatic_thread_titling": ChatSessionAutomaticThreadTitling, readonly "file_upload": ChatSessionFileUpload, readonly "history": ChatSessionHistory, readonly [x: string]: unknown }
export const ChatSessionChatkitConfiguration = Schema.StructWithRest(Schema.Struct({ "automatic_thread_titling": Schema.suspend((): Schema.Codec<ChatSessionAutomaticThreadTitling> => ChatSessionAutomaticThreadTitling).annotate({ "description": "Automatic thread titling preferences." }), "file_upload": Schema.suspend((): Schema.Codec<ChatSessionFileUpload> => ChatSessionFileUpload).annotate({ "description": "Upload settings for the session." }), "history": Schema.suspend((): Schema.Codec<ChatSessionHistory> => ChatSessionHistory).annotate({ "description": "History retention configuration." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ChatKit configuration", "description": "ChatKit configuration for the session.", "identifier": "ChatSessionChatkitConfiguration" })
export type WorkflowParam = { readonly "id": string, readonly "version"?: string, readonly "state_variables"?: { readonly [x: string]: string | number | boolean | number }, readonly "tracing"?: WorkflowTracingParam, readonly [x: string]: unknown }
export const WorkflowParam = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier for the workflow invoked by the session." }), "version": Schema.optionalKey(Schema.String.annotate({ "description": "Specific workflow version to run. Defaults to the latest deployed version." })), "state_variables": Schema.optionalKey(Schema.Record(Schema.String, Schema.Union([Schema.String, Schema.Number.check(Schema.isInt()), Schema.Boolean, Schema.Number.check(Schema.isFinite())])).annotate({ "description": "State variables forwarded to the workflow. Keys may be up to 64 characters, values must be primitive types, and the map defaults to an empty object." })), "tracing": Schema.optionalKey(Schema.suspend((): Schema.Codec<WorkflowTracingParam> => WorkflowTracingParam).annotate({ "description": "Optional tracing overrides for the workflow invocation. When omitted, tracing is enabled by default." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Workflow settings", "description": "Workflow reference and overrides applied to the chat session.", "identifier": "WorkflowParam" })
export type ChatkitConfigurationParam = { readonly "automatic_thread_titling"?: AutomaticThreadTitlingParam, readonly "file_upload"?: FileUploadParam, readonly "history"?: HistoryParam, readonly [x: string]: unknown }
export const ChatkitConfigurationParam = Schema.StructWithRest(Schema.Struct({ "automatic_thread_titling": Schema.optionalKey(Schema.suspend((): Schema.Codec<AutomaticThreadTitlingParam> => AutomaticThreadTitlingParam).annotate({ "description": "Configuration for automatic thread titling. When omitted, automatic thread titling is enabled by default." })), "file_upload": Schema.optionalKey(Schema.suspend((): Schema.Codec<FileUploadParam> => FileUploadParam).annotate({ "description": "Configuration for upload enablement and limits. When omitted, uploads are disabled by default (max_files 10, max_file_size 512 MB)." })), "history": Schema.optionalKey(Schema.suspend((): Schema.Codec<HistoryParam> => HistoryParam).annotate({ "description": "Configuration for chat history retention. When omitted, history is enabled by default with no limit on recent_threads (null)." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ChatKit configuration overrides", "description": "Optional per-session configuration settings for ChatKit behavior.", "identifier": "ChatkitConfigurationParam" })
export type Attachment = { readonly "type": AttachmentType, readonly "id": string, readonly "name": string, readonly "mime_type": string, readonly "preview_url": string | null, readonly [x: string]: unknown }
export const Attachment = Schema.StructWithRest(Schema.Struct({ "type": Schema.suspend((): Schema.Codec<AttachmentType> => AttachmentType).annotate({ "description": "Attachment discriminator." }), "id": Schema.String.annotate({ "description": "Identifier for the attachment." }), "name": Schema.String.annotate({ "description": "Original display name for the attachment." }), "mime_type": Schema.String.annotate({ "description": "MIME type of the attachment." }), "preview_url": Schema.Union([Schema.String.annotate({ "description": "Preview URL for rendering the attachment inline." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Attachment", "description": "Attachment metadata included on thread items.", "identifier": "Attachment" })
export type InferenceOptions = { readonly "tool_choice": ToolChoice | null, readonly "model": string | null, readonly [x: string]: unknown }
export const InferenceOptions = Schema.StructWithRest(Schema.Struct({ "tool_choice": Schema.Union([Schema.suspend((): Schema.Codec<ToolChoice> => ToolChoice).annotate({ "description": "Preferred tool to invoke. Defaults to null when ChatKit should auto-select." }), Schema.Null]), "model": Schema.Union([Schema.String.annotate({ "description": "Model name that generated the response. Defaults to null when using the session default." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Inference options", "description": "Model and tool overrides applied when generating the assistant response.", "identifier": "InferenceOptions" })
export type FileAnnotation = { readonly "type": "file", readonly "source": FileAnnotationSource, readonly [x: string]: unknown }
export const FileAnnotation = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file").annotate({ "description": "Type discriminator that is always \`file\` for this annotation.", "default": "file" }), "source": Schema.suspend((): Schema.Codec<FileAnnotationSource> => FileAnnotationSource).annotate({ "description": "File attachment referenced by the annotation." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File annotation", "description": "Annotation that references an uploaded file.", "identifier": "FileAnnotation" })
export type UrlAnnotation = { readonly "type": "url", readonly "source": UrlAnnotationSource, readonly [x: string]: unknown }
export const UrlAnnotation = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("url").annotate({ "description": "Type discriminator that is always \`url\` for this annotation.", "default": "url" }), "source": Schema.suspend((): Schema.Codec<UrlAnnotationSource> => UrlAnnotationSource).annotate({ "description": "URL referenced by the annotation." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "URL annotation", "description": "Annotation that references a URL.", "identifier": "UrlAnnotation" })
export type ClientToolCallItem = { readonly "id": string, readonly "object": "chatkit.thread_item", readonly "created_at": number, readonly "thread_id": string, readonly "type": "chatkit.client_tool_call", readonly "status": ClientToolCallStatus, readonly "call_id": string, readonly "name": string, readonly "arguments": string, readonly "output": string | null, readonly [x: string]: unknown }
export const ClientToolCallItem = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the thread item." }), "object": Schema.Literal("chatkit.thread_item").annotate({ "description": "Type discriminator that is always \`chatkit.thread_item\`.", "default": "chatkit.thread_item" }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." }).check(Schema.isInt()), "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }), "type": Schema.Literal("chatkit.client_tool_call").annotate({ "description": "Type discriminator that is always \`chatkit.client_tool_call\`.", "default": "chatkit.client_tool_call" }), "status": Schema.suspend((): Schema.Codec<ClientToolCallStatus> => ClientToolCallStatus).annotate({ "description": "Execution status for the tool call." }), "call_id": Schema.String.annotate({ "description": "Identifier for the client tool call." }), "name": Schema.String.annotate({ "description": "Tool name that was invoked." }), "arguments": Schema.String.annotate({ "description": "JSON-encoded arguments that were sent to the tool." }), "output": Schema.Union([Schema.String.annotate({ "description": "JSON-encoded output captured from the tool. Defaults to null while execution is in progress." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Client tool call", "description": "Record of a client side tool invocation initiated by the assistant.", "identifier": "ClientToolCallItem" })
export type TaskItem = { readonly "id": string, readonly "object": "chatkit.thread_item", readonly "created_at": number, readonly "thread_id": string, readonly "type": "chatkit.task", readonly "task_type": TaskType, readonly "heading": string | null, readonly "summary": string | null, readonly [x: string]: unknown }
export const TaskItem = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the thread item." }), "object": Schema.Literal("chatkit.thread_item").annotate({ "description": "Type discriminator that is always \`chatkit.thread_item\`.", "default": "chatkit.thread_item" }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." }).check(Schema.isInt()), "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }), "type": Schema.Literal("chatkit.task").annotate({ "description": "Type discriminator that is always \`chatkit.task\`.", "default": "chatkit.task" }), "task_type": Schema.suspend((): Schema.Codec<TaskType> => TaskType).annotate({ "description": "Subtype for the task." }), "heading": Schema.Union([Schema.String.annotate({ "description": "Optional heading for the task. Defaults to null when not provided." }), Schema.Null]), "summary": Schema.Union([Schema.String.annotate({ "description": "Optional summary that describes the task. Defaults to null when omitted." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Task item", "description": "Task emitted by the workflow to show progress and status updates.", "identifier": "TaskItem" })
export type TaskGroupTask = { readonly "type": TaskType, readonly "heading": string | null, readonly "summary": string | null, readonly [x: string]: unknown }
export const TaskGroupTask = Schema.StructWithRest(Schema.Struct({ "type": Schema.suspend((): Schema.Codec<TaskType> => TaskType).annotate({ "description": "Subtype for the grouped task." }), "heading": Schema.Union([Schema.String.annotate({ "description": "Optional heading for the grouped task. Defaults to null when not provided." }), Schema.Null]), "summary": Schema.Union([Schema.String.annotate({ "description": "Optional summary that describes the grouped task. Defaults to null when omitted." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Task group task", "description": "Task entry that appears within a TaskGroup.", "identifier": "TaskGroupTask" })
export type ThreadResource = { readonly "id": string, readonly "object": "chatkit.thread", readonly "created_at": number, readonly "title": string | null, readonly "status": ActiveStatus | LockedStatus | ClosedStatus, readonly "user": string, readonly [x: string]: unknown }
export const ThreadResource = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the thread." }), "object": Schema.Literal("chatkit.thread").annotate({ "description": "Type discriminator that is always \`chatkit.thread\`.", "default": "chatkit.thread" }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the thread was created." }).check(Schema.isInt()), "title": Schema.Union([Schema.String.annotate({ "description": "Optional human-readable title for the thread. Defaults to null when no title has been generated." }), Schema.Null]), "status": Schema.Union([Schema.suspend((): Schema.Codec<ActiveStatus> => ActiveStatus), Schema.suspend((): Schema.Codec<LockedStatus> => LockedStatus), Schema.suspend((): Schema.Codec<ClosedStatus> => ClosedStatus)]).annotate({ "description": "Current status for the thread. Defaults to \`active\` for newly created threads." }), "user": Schema.String.annotate({ "description": "Free-form string that identifies your end user who owns the thread." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "The thread object", "description": "Represents a ChatKit thread and its current status.", "identifier": "ThreadResource" })
export type CreateModerationRequest = { readonly "input": string | ReadonlyArray<string> | ReadonlyArray<ModerationImageURLInput | ModerationTextInput>, readonly "model"?: string | "omni-moderation-latest" | "omni-moderation-2024-09-26" | "text-moderation-latest" | "text-moderation-stable", readonly [x: string]: unknown }
export const CreateModerationRequest = Schema.StructWithRest(Schema.Struct({ "input": Schema.Union([Schema.String.annotate({ "description": "A string of text to classify for moderation.", "default": "" }), Schema.Array(Schema.String.annotate({ "default": "" })).annotate({ "description": "An array of strings to classify for moderation." }), Schema.Array(Schema.Union([ModerationImageURLInput, ModerationTextInput])).annotate({ "title": "Moderation Multi Modal Array", "description": "An array of multi-modal inputs to the moderation model." })]).annotate({ "description": "Input (or inputs) to classify. Can be a single string, an array of strings, or\\nan array of multi-modal input objects similar to other models.\\n" }), "model": Schema.optionalKey(Schema.Union([Schema.String, Schema.Literals(["omni-moderation-latest", "omni-moderation-2024-09-26", "text-moderation-latest", "text-moderation-stable"])]).annotate({ "description": "The content moderation model you would like to use. Learn more in\\n[the moderation guide](https://platform.openai.com/docs/guides/moderation), and learn about\\navailable models [here](https://platform.openai.com/docs/models#moderation).\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateModerationRequest" })
export type ComparisonFilter = { readonly "type": "eq" | "ne" | "gt" | "gte" | "lt" | "lte", readonly "key": string, readonly "value": string | number | boolean | ReadonlyArray<ComparisonFilterValueItems> }
export const ComparisonFilter = Schema.Struct({ "type": Schema.Literals(["eq", "ne", "gt", "gte", "lt", "lte"]).annotate({ "description": "Specifies the comparison operator: \`eq\`, \`ne\`, \`gt\`, \`gte\`, \`lt\`, \`lte\`, \`in\`, \`nin\`.\\n- \`eq\`: equals\\n- \`ne\`: not equal\\n- \`gt\`: greater than\\n- \`gte\`: greater than or equal\\n- \`lt\`: less than\\n- \`lte\`: less than or equal\\n- \`in\`: in\\n- \`nin\`: not in\\n", "default": "eq" }), "key": Schema.String.annotate({ "description": "The key to compare against the value." }), "value": Schema.Union([Schema.String, Schema.Number.check(Schema.isFinite()), Schema.Boolean, Schema.Array(ComparisonFilterValueItems)]).annotate({ "description": "The value to compare against the attribute key; supports string, number, or boolean types." }) }).annotate({ "title": "Comparison Filter", "description": "A filter used to compare a specified attribute key to a given value using a defined comparison operation.\\n", "identifier": "ComparisonFilter" })
export type CreateFileRequest = { readonly "file": string, readonly "purpose": FilePurpose, readonly "expires_after"?: FileExpirationAfter }
export const CreateFileRequest = Schema.Struct({ "file": Schema.String.annotate({ "description": "The File object (not file name) to be uploaded.\\n", "format": "binary" }), "purpose": FilePurpose, "expires_after": Schema.optionalKey(FileExpirationAfter) }).annotate({ "identifier": "CreateFileRequest" })
export type Batch = { readonly "id": string, readonly "object": "batch", readonly "endpoint": string, readonly "model"?: string, readonly "errors"?: { readonly "object"?: string, readonly "data"?: ReadonlyArray<BatchError>, readonly [x: string]: unknown }, readonly "input_file_id": string, readonly "completion_window": string, readonly "status": "validating" | "failed" | "in_progress" | "finalizing" | "completed" | "expired" | "cancelling" | "cancelled", readonly "output_file_id"?: string, readonly "error_file_id"?: string, readonly "created_at": number, readonly "in_progress_at"?: number, readonly "expires_at"?: number, readonly "finalizing_at"?: number, readonly "completed_at"?: number, readonly "failed_at"?: number, readonly "expired_at"?: number, readonly "cancelling_at"?: number, readonly "cancelled_at"?: number, readonly "request_counts"?: BatchRequestCounts, readonly "usage"?: { readonly "input_tokens": number, readonly "input_tokens_details": { readonly "cached_tokens": number, readonly [x: string]: unknown }, readonly "output_tokens": number, readonly "output_tokens_details": { readonly "reasoning_tokens": number, readonly [x: string]: unknown }, readonly "total_tokens": number, readonly [x: string]: unknown }, readonly "metadata"?: Metadata, readonly [x: string]: unknown }
export const Batch = Schema.StructWithRest(Schema.Struct({ "id": Schema.String, "object": Schema.Literal("batch").annotate({ "description": "The object type, which is always \`batch\`." }), "endpoint": Schema.String.annotate({ "description": "The OpenAI API endpoint used by the batch." }), "model": Schema.optionalKey(Schema.String.annotate({ "description": "Model ID used to process the batch, like \`gpt-5-2025-08-07\`. OpenAI\\noffers a wide range of models with different capabilities, performance\\ncharacteristics, and price points. Refer to the [model\\nguide](https://platform.openai.com/docs/models) to browse and compare available models.\\n" })), "errors": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "object": Schema.optionalKey(Schema.String.annotate({ "description": "The object type, which is always \`list\`." })), "data": Schema.optionalKey(Schema.Array(BatchError)) }), [Schema.Record(Schema.String, Schema.Unknown)])), "input_file_id": Schema.String.annotate({ "description": "The ID of the input file for the batch." }), "completion_window": Schema.String.annotate({ "description": "The time frame within which the batch should be processed." }), "status": Schema.Literals(["validating", "failed", "in_progress", "finalizing", "completed", "expired", "cancelling", "cancelled"]).annotate({ "description": "The current status of the batch." }), "output_file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the file containing the outputs of successfully executed requests." })), "error_file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the file containing the outputs of requests with errors." })), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch was created." }).check(Schema.isInt()), "in_progress_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch started processing." }).check(Schema.isInt())), "expires_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch will expire." }).check(Schema.isInt())), "finalizing_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch started finalizing." }).check(Schema.isInt())), "completed_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch was completed." }).check(Schema.isInt())), "failed_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch failed." }).check(Schema.isInt())), "expired_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch expired." }).check(Schema.isInt())), "cancelling_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch started cancelling." }).check(Schema.isInt())), "cancelled_at": Schema.optionalKey(Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the batch was cancelled." }).check(Schema.isInt())), "request_counts": Schema.optionalKey(BatchRequestCounts), "usage": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "input_tokens": Schema.Number.annotate({ "description": "The number of input tokens." }).check(Schema.isInt()), "input_tokens_details": Schema.StructWithRest(Schema.Struct({ "cached_tokens": Schema.Number.annotate({ "description": "The number of tokens that were retrieved from the cache. [More on\\nprompt caching](https://platform.openai.com/docs/guides/prompt-caching).\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A detailed breakdown of the input tokens." }), "output_tokens": Schema.Number.annotate({ "description": "The number of output tokens." }).check(Schema.isInt()), "output_tokens_details": Schema.StructWithRest(Schema.Struct({ "reasoning_tokens": Schema.Number.annotate({ "description": "The number of reasoning tokens." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A detailed breakdown of the output tokens." }), "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents token usage details including input tokens, output tokens, a\\nbreakdown of output tokens, and the total tokens used. Only populated on\\nbatches created after September 7, 2025.\\n" })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "Batch" })
export type ModelIdsShared = string | ChatModel
export const ModelIdsShared = Schema.Union([Schema.String, ChatModel]).annotate({ "identifier": "ModelIdsShared" })
export type ReasoningItem = { readonly "type": "reasoning", readonly "id": string, readonly "encrypted_content"?: string | null, readonly "summary": ReadonlyArray<Summary>, readonly "content"?: ReadonlyArray<ReasoningTextContent>, readonly "status"?: "in_progress" | "completed" | "incomplete", readonly [x: string]: unknown }
export const ReasoningItem = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("reasoning").annotate({ "description": "The type of the object. Always \`reasoning\`.\\n" }), "id": Schema.String.annotate({ "description": "The unique identifier of the reasoning content.\\n" }), "encrypted_content": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The encrypted content of the reasoning item - populated when a response is\\ngenerated with \`reasoning.encrypted_content\` in the \`include\` parameter.\\n" }), Schema.Null])), "summary": Schema.Array(Summary).annotate({ "description": "Reasoning summary content.\\n" }), "content": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<ReasoningTextContent> => ReasoningTextContent)).annotate({ "description": "Reasoning text content.\\n" })), "status": Schema.optionalKey(Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "description": "The status of the item. One of \`in_progress\`, \`completed\`, or\\n\`incomplete\`. Populated when items are returned via API.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Reasoning", "description": "A description of the chain of thought used by a reasoning model while generating\\na response. Be sure to include these items in your \`input\` to the Responses API\\nfor subsequent turns of a conversation if you are manually\\n[managing context](https://platform.openai.com/docs/guides/conversation-state).\\n", "identifier": "ReasoningItem" })
export type RealtimeBetaServerEventTranscriptionSessionCreated = { readonly "event_id": string, readonly "type": "transcription_session.created", readonly "session": RealtimeTranscriptionSessionCreateResponse, readonly [x: string]: unknown }
export const RealtimeBetaServerEventTranscriptionSessionCreated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("transcription_session.created").annotate({ "description": "The event type, must be \`transcription_session.created\`." }), "session": RealtimeTranscriptionSessionCreateResponse }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a transcription session is created.\\n", "identifier": "RealtimeBetaServerEventTranscriptionSessionCreated" })
export type RealtimeBetaServerEventTranscriptionSessionUpdated = { readonly "event_id": string, readonly "type": "transcription_session.updated", readonly "session": RealtimeTranscriptionSessionCreateResponse, readonly [x: string]: unknown }
export const RealtimeBetaServerEventTranscriptionSessionUpdated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("transcription_session.updated").annotate({ "description": "The event type, must be \`transcription_session.updated\`." }), "session": Schema.suspend((): Schema.Codec<RealtimeTranscriptionSessionCreateResponse> => RealtimeTranscriptionSessionCreateResponse) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a transcription session is updated with a \`transcription_session.update\` event, unless \\nthere is an error.\\n", "identifier": "RealtimeBetaServerEventTranscriptionSessionUpdated" })
export type RealtimeServerEventTranscriptionSessionUpdated = { readonly "event_id": string, readonly "type": "transcription_session.updated", readonly "session": RealtimeTranscriptionSessionCreateResponse, readonly [x: string]: unknown }
export const RealtimeServerEventTranscriptionSessionUpdated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("transcription_session.updated").annotate({ "description": "The event type, must be \`transcription_session.updated\`." }), "session": Schema.suspend((): Schema.Codec<RealtimeTranscriptionSessionCreateResponse> => RealtimeTranscriptionSessionCreateResponse) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a transcription session is updated with a \`transcription_session.update\` event, unless \\nthere is an error.\\n", "identifier": "RealtimeServerEventTranscriptionSessionUpdated" })
export type AuditLogActor = { readonly "type"?: "session" | "api_key", readonly "session"?: AuditLogActorSession, readonly "api_key"?: AuditLogActorApiKey, readonly [x: string]: unknown }
export const AuditLogActor = Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["session", "api_key"]).annotate({ "description": "The type of actor. Is either \`session\` or \`api_key\`." })), "session": Schema.optionalKey(AuditLogActorSession), "api_key": Schema.optionalKey(AuditLogActorApiKey) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The actor who performed the audit logged action.", "identifier": "AuditLogActor" })
export type ChatCompletionToolChoiceOption = "none" | "auto" | "required" | ChatCompletionAllowedToolsChoice | ChatCompletionNamedToolChoice | ChatCompletionNamedToolChoiceCustom
export const ChatCompletionToolChoiceOption = Schema.Union([Schema.Literals(["none", "auto", "required"]).annotate({ "title": "Auto", "description": "\`none\` means the model will not call any tool and instead generates a message. \`auto\` means the model can pick between generating a message or calling one or more tools. \`required\` means the model must call one or more tools.\\n" }), Schema.suspend((): Schema.Codec<ChatCompletionAllowedToolsChoice> => ChatCompletionAllowedToolsChoice), Schema.suspend((): Schema.Codec<ChatCompletionNamedToolChoice> => ChatCompletionNamedToolChoice), Schema.suspend((): Schema.Codec<ChatCompletionNamedToolChoiceCustom> => ChatCompletionNamedToolChoiceCustom)]).annotate({ "description": "Controls which (if any) tool is called by the model.\\n\`none\` means the model will not call any tool and instead generates a message.\\n\`auto\` means the model can pick between generating a message or calling one or more tools.\\n\`required\` means the model must call one or more tools.\\nSpecifying a particular tool via \`{\\"type\\": \\"function\\", \\"function\\": {\\"name\\": \\"my_function\\"}}\` forces the model to call that tool.\\n\\n\`none\` is the default when no tools are present. \`auto\` is the default if tools are present.\\n", "identifier": "ChatCompletionToolChoiceOption" })
export type ChatCompletionResponseMessage = { readonly "content": string | null, readonly "refusal": string | null, readonly "tool_calls"?: ChatCompletionMessageToolCalls, readonly "annotations"?: ReadonlyArray<{ readonly "type": "url_citation", readonly "url_citation": { readonly "end_index": number, readonly "start_index": number, readonly "url": string, readonly "title": string, readonly [x: string]: unknown }, readonly [x: string]: unknown }>, readonly "role": "assistant", readonly "function_call"?: { readonly "arguments": string, readonly "name": string, readonly [x: string]: unknown }, readonly "audio"?: { readonly "id": string, readonly "expires_at": number, readonly "data": string, readonly "transcript": string, readonly [x: string]: unknown } | null, readonly [x: string]: unknown }
export const ChatCompletionResponseMessage = Schema.StructWithRest(Schema.Struct({ "content": Schema.Union([Schema.String.annotate({ "description": "The contents of the message." }), Schema.Null]), "refusal": Schema.Union([Schema.String.annotate({ "description": "The refusal message generated by the model." }), Schema.Null]), "tool_calls": Schema.optionalKey(Schema.suspend((): Schema.Codec<ChatCompletionMessageToolCalls> => ChatCompletionMessageToolCalls)), "annotations": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("url_citation").annotate({ "description": "The type of the URL citation. Always \`url_citation\`." }), "url_citation": Schema.StructWithRest(Schema.Struct({ "end_index": Schema.Number.annotate({ "description": "The index of the last character of the URL citation in the message." }).check(Schema.isInt()), "start_index": Schema.Number.annotate({ "description": "The index of the first character of the URL citation in the message." }).check(Schema.isInt()), "url": Schema.String.annotate({ "description": "The URL of the web resource." }), "title": Schema.String.annotate({ "description": "The title of the web resource." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A URL citation when using web search." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A URL citation when using web search.\\n" })).annotate({ "description": "Annotations for the message, when applicable, as when using the\\n[web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).\\n" })), "role": Schema.Literal("assistant").annotate({ "description": "The role of the author of this message." }), "function_call": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "arguments": Schema.String.annotate({ "description": "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function." }), "name": Schema.String.annotate({ "description": "The name of the function to call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Deprecated and replaced by \`tool_calls\`. The name and arguments of a function that should be called, as generated by the model." })), "audio": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Unique identifier for this audio response." }), "expires_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when this audio response will\\nno longer be accessible on the server for use in multi-turn\\nconversations.\\n" }).check(Schema.isInt()), "data": Schema.String.annotate({ "description": "Base64 encoded audio bytes generated by the model, in the format\\nspecified in the request.\\n" }), "transcript": Schema.String.annotate({ "description": "Transcript of the audio generated by the model." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "If the audio output modality is requested, this object contains data\\nabout the audio response from the model. [Learn more](https://platform.openai.com/docs/guides/audio).\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A chat completion message generated by the model.", "identifier": "ChatCompletionResponseMessage" })
export type CreateChatCompletionStreamResponse = { readonly "id": string, readonly "choices": ReadonlyArray<{ readonly "delta": ChatCompletionStreamResponseDelta, readonly "logprobs"?: { readonly [x: string]: unknown } | null, readonly "finish_reason": "stop" | "length" | "tool_calls" | "content_filter" | "function_call" | null, readonly "index": number, readonly [x: string]: unknown }>, readonly "created": number, readonly "model": string, readonly "service_tier"?: ServiceTier, readonly "system_fingerprint"?: string, readonly "object": "chat.completion.chunk", readonly "usage"?: CompletionUsage | null, readonly [x: string]: unknown }
export const CreateChatCompletionStreamResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "A unique identifier for the chat completion. Each chunk has the same ID." }), "choices": Schema.Array(Schema.StructWithRest(Schema.Struct({ "delta": Schema.suspend((): Schema.Codec<ChatCompletionStreamResponseDelta> => ChatCompletionStreamResponseDelta), "logprobs": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "Log probability information for the choice." })), "finish_reason": Schema.Union([Schema.Literal("stop"), Schema.Literal("length"), Schema.Literal("tool_calls"), Schema.Literal("content_filter"), Schema.Literal("function_call"), Schema.Null]).annotate({ "description": "The reason the model stopped generating tokens. This will be \`stop\` if the model hit a natural stop point or a provided stop sequence,\\n\`length\` if the maximum number of tokens specified in the request was reached,\\n\`content_filter\` if content was omitted due to a flag from our content filters,\\n\`tool_calls\` if the model called a tool, or \`function_call\` (deprecated) if the model called a function.\\n" }), "index": Schema.Number.annotate({ "description": "The index of the choice in the list of choices." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "A list of chat completion choices. Can contain more than one elements if \`n\` is greater than 1. Can also be empty for the\\nlast chunk if you set \`stream_options: {\\"include_usage\\": true}\`.\\n" }), "created": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp." }).check(Schema.isInt()), "model": Schema.String.annotate({ "description": "The model to generate the completion." }), "service_tier": Schema.optionalKey(Schema.suspend((): Schema.Codec<ServiceTier> => ServiceTier)), "system_fingerprint": Schema.optionalKey(Schema.String.annotate({ "description": "This fingerprint represents the backend configuration that the model runs with.\\nCan be used in conjunction with the \`seed\` request parameter to understand when backend changes have been made that might impact determinism.\\n" })), "object": Schema.Literal("chat.completion.chunk").annotate({ "description": "The object type, which is always \`chat.completion.chunk\`." }), "usage": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<CompletionUsage> => CompletionUsage).annotate({ "description": "An optional field that will only be present when you set\\n\`stream_options: {\\"include_usage\\": true}\` in your request. When present, it\\ncontains a null value **except for the last chunk** which contains the\\ntoken usage statistics for the entire request.\\n\\n**NOTE:** If the stream is interrupted or cancelled, you may not\\nreceive the final usage chunk which contains the total token usage for\\nthe request.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents a streamed chunk of a chat completion response returned\\nby the model, based on the provided input. \\n[Learn more](https://platform.openai.com/docs/guides/streaming-responses).\\n", "identifier": "CreateChatCompletionStreamResponse" })
export type ChatCompletionRequestAssistantMessage = { readonly "content"?: string | ReadonlyArray<ChatCompletionRequestAssistantMessageContentPart> | null, readonly "refusal"?: string | null, readonly "role": "assistant", readonly "name"?: string, readonly "audio"?: { readonly "id": string, readonly [x: string]: unknown } | null, readonly "tool_calls"?: ChatCompletionMessageToolCalls, readonly "function_call"?: { readonly "arguments": string, readonly "name": string, readonly [x: string]: unknown } | null, readonly [x: string]: unknown }
export const ChatCompletionRequestAssistantMessage = Schema.StructWithRest(Schema.Struct({ "content": Schema.optionalKey(Schema.Union([Schema.Union([Schema.String.annotate({ "title": "Text content", "description": "The contents of the assistant message." }), Schema.Array(ChatCompletionRequestAssistantMessageContentPart).annotate({ "title": "Array of content parts", "description": "An array of content parts with a defined type. Can be one or more of type \`text\`, or exactly one of type \`refusal\`." })]).annotate({ "description": "The contents of the assistant message. Required unless \`tool_calls\` or \`function_call\` is specified.\\n" }), Schema.Null])), "refusal": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The refusal message by the assistant." }), Schema.Null])), "role": Schema.Literal("assistant").annotate({ "description": "The role of the messages author, in this case \`assistant\`." }), "name": Schema.optionalKey(Schema.String.annotate({ "description": "An optional name for the participant. Provides the model information to differentiate between participants of the same role." })), "audio": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Unique identifier for a previous audio response from the model.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Data about a previous audio response from the model.\\n[Learn more](https://platform.openai.com/docs/guides/audio).\\n" }), Schema.Null])), "tool_calls": Schema.optionalKey(Schema.suspend((): Schema.Codec<ChatCompletionMessageToolCalls> => ChatCompletionMessageToolCalls)), "function_call": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "arguments": Schema.String.annotate({ "description": "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function." }), "name": Schema.String.annotate({ "description": "The name of the function to call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Deprecated and replaced by \`tool_calls\`. The name and arguments of a function that should be called, as generated by the model." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Assistant message", "description": "Messages sent by the model in response to user messages.\\n", "identifier": "ChatCompletionRequestAssistantMessage" })
export type ChatCompletionRequestSystemMessage = { readonly "content": string | ReadonlyArray<ChatCompletionRequestSystemMessageContentPart>, readonly "role": "system", readonly "name"?: string, readonly [x: string]: unknown }
export const ChatCompletionRequestSystemMessage = Schema.StructWithRest(Schema.Struct({ "content": Schema.Union([Schema.String.annotate({ "title": "Text content", "description": "The contents of the system message." }), Schema.Array(ChatCompletionRequestSystemMessageContentPart).annotate({ "title": "Array of content parts", "description": "An array of content parts with a defined type. For system messages, only type \`text\` is supported." })]).annotate({ "description": "The contents of the system message." }), "role": Schema.Literal("system").annotate({ "description": "The role of the messages author, in this case \`system\`." }), "name": Schema.optionalKey(Schema.String.annotate({ "description": "An optional name for the participant. Provides the model information to differentiate between participants of the same role." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "System message", "description": "Developer-provided instructions that the model should follow, regardless of\\nmessages sent by the user. With o1 models and newer, use \`developer\` messages\\nfor this purpose instead.\\n", "identifier": "ChatCompletionRequestSystemMessage" })
export type ChatCompletionRequestToolMessage = { readonly "role": "tool", readonly "content": string | ReadonlyArray<ChatCompletionRequestToolMessageContentPart>, readonly "tool_call_id": string, readonly [x: string]: unknown }
export const ChatCompletionRequestToolMessage = Schema.StructWithRest(Schema.Struct({ "role": Schema.Literal("tool").annotate({ "description": "The role of the messages author, in this case \`tool\`." }), "content": Schema.Union([Schema.String.annotate({ "title": "Text content", "description": "The contents of the tool message." }), Schema.Array(ChatCompletionRequestToolMessageContentPart).annotate({ "title": "Array of content parts", "description": "An array of content parts with a defined type. For tool messages, only type \`text\` is supported." })]).annotate({ "description": "The contents of the tool message." }), "tool_call_id": Schema.String.annotate({ "description": "Tool call that this message is responding to." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tool message", "identifier": "ChatCompletionRequestToolMessage" })
export type ChatCompletionRequestUserMessage = { readonly "content": string | ReadonlyArray<ChatCompletionRequestUserMessageContentPart>, readonly "role": "user", readonly "name"?: string, readonly [x: string]: unknown }
export const ChatCompletionRequestUserMessage = Schema.StructWithRest(Schema.Struct({ "content": Schema.Union([Schema.String.annotate({ "title": "Text content", "description": "The text contents of the message." }), Schema.Array(ChatCompletionRequestUserMessageContentPart).annotate({ "title": "Array of content parts", "description": "An array of content parts with a defined type. Supported options differ based on the [model](https://platform.openai.com/docs/models) being used to generate the response. Can contain text, image, or audio inputs." })]).annotate({ "description": "The contents of the user message.\\n" }), "role": Schema.Literal("user").annotate({ "description": "The role of the messages author, in this case \`user\`." }), "name": Schema.optionalKey(Schema.String.annotate({ "description": "An optional name for the participant. Provides the model information to differentiate between participants of the same role." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "User message", "description": "Messages sent by an end user, containing prompts or additional context\\ninformation.\\n", "identifier": "ChatCompletionRequestUserMessage" })
export type EvalRunOutputItemList = { readonly "object": "list", readonly "data": ReadonlyArray<EvalRunOutputItem>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const EvalRunOutputItemList = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of this object. It is always set to \\"list\\".\\n", "default": "list" }), "data": Schema.Array(Schema.suspend((): Schema.Codec<EvalRunOutputItem> => EvalRunOutputItem)).annotate({ "description": "An array of eval run output item objects.\\n" }), "first_id": Schema.String.annotate({ "description": "The identifier of the first eval run output item in the data array." }), "last_id": Schema.String.annotate({ "description": "The identifier of the last eval run output item in the data array." }), "has_more": Schema.Boolean.annotate({ "description": "Indicates whether there are more eval run output items available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalRunOutputItemList", "description": "An object representing a list of output items for an evaluation run.\\n", "identifier": "EvalRunOutputItemList" })
export type AssistantToolsFileSearch = { readonly "type": "file_search", readonly "file_search"?: { readonly "max_num_results"?: number, readonly "ranking_options"?: FileSearchRankingOptions, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const AssistantToolsFileSearch = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file_search").annotate({ "description": "The type of tool being defined: \`file_search\`" }), "file_search": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "max_num_results": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum number of results the file search tool should output. The default is 20 for \`gpt-4*\` models and 5 for \`gpt-3.5-turbo\`. This number should be between 1 and 50 inclusive.\\n\\nNote that the file search tool may output fewer than \`max_num_results\` results. See the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\\n" }).check(Schema.isInt())), "ranking_options": Schema.optionalKey(FileSearchRankingOptions) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Overrides for the file search tool." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "FileSearch tool", "identifier": "AssistantToolsFileSearch" })
export type RunStepDetailsToolCallsFileSearchObject = { readonly "id": string, readonly "type": "file_search", readonly "file_search": { readonly "ranking_options"?: RunStepDetailsToolCallsFileSearchRankingOptionsObject, readonly "results"?: ReadonlyArray<RunStepDetailsToolCallsFileSearchResultObject>, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const RunStepDetailsToolCallsFileSearchObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The ID of the tool call object." }), "type": Schema.Literal("file_search").annotate({ "description": "The type of tool call. This is always going to be \`file_search\` for this type of tool call." }), "file_search": Schema.StructWithRest(Schema.Struct({ "ranking_options": Schema.optionalKey(RunStepDetailsToolCallsFileSearchRankingOptionsObject), "results": Schema.optionalKey(Schema.Array(RunStepDetailsToolCallsFileSearchResultObject).annotate({ "description": "The results of the file search." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "For now, this is always going to be an empty object." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File search tool call", "identifier": "RunStepDetailsToolCallsFileSearchObject" })
export type AssistantToolsFunction = { readonly "type": "function", readonly "function": FunctionObject, readonly [x: string]: unknown }
export const AssistantToolsFunction = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("function").annotate({ "description": "The type of tool being defined: \`function\`" }), "function": FunctionObject }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool", "identifier": "AssistantToolsFunction" })
export type ChatCompletionTool = { readonly "type": "function", readonly "function": FunctionObject, readonly [x: string]: unknown }
export const ChatCompletionTool = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("function").annotate({ "description": "The type of the tool. Currently, only \`function\` is supported." }), "function": Schema.suspend((): Schema.Codec<FunctionObject> => FunctionObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool", "description": "A function tool that can be used to generate a response.\\n", "identifier": "ChatCompletionTool" })
export type ImageEditStreamEvent = ImageEditPartialImageEvent | ImageEditCompletedEvent
export const ImageEditStreamEvent = Schema.Union([Schema.suspend((): Schema.Codec<ImageEditPartialImageEvent> => ImageEditPartialImageEvent), Schema.suspend((): Schema.Codec<ImageEditCompletedEvent> => ImageEditCompletedEvent)]).annotate({ "identifier": "ImageEditStreamEvent" })
export type ImageGenStreamEvent = ImageGenPartialImageEvent | ImageGenCompletedEvent
export const ImageGenStreamEvent = Schema.Union([Schema.suspend((): Schema.Codec<ImageGenPartialImageEvent> => ImageGenPartialImageEvent), Schema.suspend((): Schema.Codec<ImageGenCompletedEvent> => ImageGenCompletedEvent)]).annotate({ "identifier": "ImageGenStreamEvent" })
export type MessageContentTextObject = { readonly "type": "text", readonly "text": { readonly "value": string, readonly "annotations": ReadonlyArray<TextAnnotation>, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const MessageContentTextObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("text").annotate({ "description": "Always \`text\`." }), "text": Schema.StructWithRest(Schema.Struct({ "value": Schema.String.annotate({ "description": "The data that makes up the text." }), "annotations": Schema.Array(TextAnnotation) }), [Schema.Record(Schema.String, Schema.Unknown)]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Text", "description": "The text content that is part of a message.", "identifier": "MessageContentTextObject" })
export type MessageDeltaContentTextObject = { readonly "index": number, readonly "type": "text", readonly "text"?: { readonly "value"?: string, readonly "annotations"?: ReadonlyArray<TextAnnotationDelta>, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const MessageDeltaContentTextObject = Schema.StructWithRest(Schema.Struct({ "index": Schema.Number.annotate({ "description": "The index of the content part in the message." }).check(Schema.isInt()), "type": Schema.Literal("text").annotate({ "description": "Always \`text\`." }), "text": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "value": Schema.optionalKey(Schema.String.annotate({ "description": "The data that makes up the text." })), "annotations": Schema.optionalKey(Schema.Array(TextAnnotationDelta)) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Text", "description": "The text content that is part of a message.", "identifier": "MessageDeltaContentTextObject" })
export type CreateThreadRequest = { readonly "messages"?: ReadonlyArray<CreateMessageRequest>, readonly "tool_resources"?: { readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly "file_search"?: { readonly "vector_store_ids": unknown, readonly [x: string]: unknown } | { readonly "vector_stores": unknown, readonly [x: string]: unknown }, readonly [x: string]: unknown } | null, readonly "metadata"?: Metadata }
export const CreateThreadRequest = Schema.Struct({ "messages": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<CreateMessageRequest> => CreateMessageRequest)).annotate({ "description": "A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with." })), "tool_resources": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "code_interpreter": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "file_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the \`code_interpreter\` tool. There can be a maximum of 20 files associated with the tool.\\n", "default": [] })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "file_search": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "vector_store_ids": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)]), Schema.StructWithRest(Schema.Struct({ "vector_stores": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)])])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the \`code_interpreter\` tool requires a list of file IDs, while the \`file_search\` tool requires a list of vector store IDs.\\n" }), Schema.Null])), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)) }).annotate({ "description": "Options to create a new thread. If no thread is provided when running a\\nrequest, an empty thread will be created.\\n", "identifier": "CreateThreadRequest" })
export type Eval = { readonly "object": "eval", readonly "id": string, readonly "name": string, readonly "data_source_config": EvalCustomDataSourceConfig | EvalLogsDataSourceConfig | EvalStoredCompletionsDataSourceConfig, readonly "testing_criteria": ReadonlyArray<EvalGraderLabelModel | EvalGraderStringCheck | EvalGraderTextSimilarity | EvalGraderPython | EvalGraderScoreModel>, readonly "created_at": number, readonly "metadata": Metadata, readonly [x: string]: unknown }
export const Eval = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("eval").annotate({ "description": "The object type.", "default": "eval" }), "id": Schema.String.annotate({ "description": "Unique identifier for the evaluation." }), "name": Schema.String.annotate({ "description": "The name of the evaluation." }), "data_source_config": Schema.Union([EvalCustomDataSourceConfig, EvalLogsDataSourceConfig, EvalStoredCompletionsDataSourceConfig]).annotate({ "description": "Configuration of data sources used in runs of the evaluation." }), "testing_criteria": Schema.Array(Schema.Union([EvalGraderLabelModel, Schema.suspend((): Schema.Codec<EvalGraderStringCheck> => EvalGraderStringCheck), Schema.suspend((): Schema.Codec<EvalGraderTextSimilarity> => EvalGraderTextSimilarity), Schema.suspend((): Schema.Codec<EvalGraderPython> => EvalGraderPython), Schema.suspend((): Schema.Codec<EvalGraderScoreModel> => EvalGraderScoreModel)])).annotate({ "description": "A list of testing criteria." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the eval was created." }).check(Schema.isInt()), "metadata": Schema.suspend((): Schema.Codec<Metadata> => Metadata) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Eval", "description": "An Eval object with a data source config and testing criteria.\\nAn Eval represents a task to be done for your LLM integration.\\nLike:\\n - Improve the quality of my chatbot\\n - See how well my chatbot handles customer support\\n - Check if o4-mini is better at my usecase than gpt-4o\\n", "identifier": "Eval" })
export type ThreadStreamEvent = { readonly "enabled"?: boolean, readonly "event": "thread.created", readonly "data": ThreadObject, readonly [x: string]: unknown }
export const ThreadStreamEvent = Schema.Union([Schema.StructWithRest(Schema.Struct({ "enabled": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Whether to enable input audio transcription." })), "event": Schema.Literal("thread.created"), "data": Schema.suspend((): Schema.Codec<ThreadObject> => ThreadObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a new [thread](https://platform.openai.com/docs/api-reference/threads/object) is created." })]).annotate({ "identifier": "ThreadStreamEvent" })
export type RealtimeBetaClientEventTranscriptionSessionUpdate = { readonly "event_id"?: string, readonly "type": "transcription_session.update", readonly "session": RealtimeTranscriptionSessionCreateRequest, readonly [x: string]: unknown }
export const RealtimeBetaClientEventTranscriptionSessionUpdate = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("transcription_session.update").annotate({ "description": "The event type, must be \`transcription_session.update\`." }), "session": RealtimeTranscriptionSessionCreateRequest }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to update a transcription session.\\n", "identifier": "RealtimeBetaClientEventTranscriptionSessionUpdate" })
export type RealtimeClientEventTranscriptionSessionUpdate = { readonly "event_id"?: string, readonly "type": "transcription_session.update", readonly "session": RealtimeTranscriptionSessionCreateRequest, readonly [x: string]: unknown }
export const RealtimeClientEventTranscriptionSessionUpdate = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("transcription_session.update").annotate({ "description": "The event type, must be \`transcription_session.update\`." }), "session": Schema.suspend((): Schema.Codec<RealtimeTranscriptionSessionCreateRequest> => RealtimeTranscriptionSessionCreateRequest) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to update a transcription session.\\n", "identifier": "RealtimeClientEventTranscriptionSessionUpdate" })
export type ProjectApiKeyListResponse = { readonly "object": "list", readonly "data": ReadonlyArray<ProjectApiKey>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ProjectApiKeyListResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list"), "data": Schema.Array(Schema.suspend((): Schema.Codec<ProjectApiKey> => ProjectApiKey)), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ProjectApiKeyListResponse" })
export type RealtimeConversationItem = RealtimeConversationItemMessageSystem | RealtimeConversationItemMessageUser | RealtimeConversationItemMessageAssistant | RealtimeConversationItemFunctionCall | RealtimeConversationItemFunctionCallOutput | RealtimeMCPApprovalResponse | RealtimeMCPListTools | RealtimeMCPToolCall | RealtimeMCPApprovalRequest
export const RealtimeConversationItem = Schema.Union([RealtimeConversationItemMessageSystem, RealtimeConversationItemMessageUser, RealtimeConversationItemMessageAssistant, RealtimeConversationItemFunctionCall, RealtimeConversationItemFunctionCallOutput, RealtimeMCPApprovalResponse, RealtimeMCPListTools, RealtimeMCPToolCall, RealtimeMCPApprovalRequest]).annotate({ "description": "A single item within a Realtime conversation.", "identifier": "RealtimeConversationItem" })
export type AssistantsApiResponseFormatOption = "auto" | ResponseFormatText | ResponseFormatJsonObject | ResponseFormatJsonSchema
export const AssistantsApiResponseFormatOption = Schema.Union([Schema.Literal("auto").annotate({ "description": "\`auto\` is the default value\\n" }), ResponseFormatText, ResponseFormatJsonObject, ResponseFormatJsonSchema]).annotate({ "description": "Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models#gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since \`gpt-3.5-turbo-1106\`.\\n\\nSetting to \`{ \\"type\\": \\"json_schema\\", \\"json_schema\\": {...} }\` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\\n\\nSetting to \`{ \\"type\\": \\"json_object\\" }\` enables JSON mode, which ensures the message the model generates is valid JSON.\\n\\n**Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \\"stuck\\" request. Also note that the message content may be partially cut off if \`finish_reason=\\"length\\"\`, which indicates the generation exceeded \`max_tokens\` or the conversation exceeded the max context length.\\n", "identifier": "AssistantsApiResponseFormatOption" })
export type TextResponseFormatConfiguration = ResponseFormatText | TextResponseFormatJsonSchema | ResponseFormatJsonObject
export const TextResponseFormatConfiguration = Schema.Union([Schema.suspend((): Schema.Codec<ResponseFormatText> => ResponseFormatText), TextResponseFormatJsonSchema, Schema.suspend((): Schema.Codec<ResponseFormatJsonObject> => ResponseFormatJsonObject)]).annotate({ "description": "An object specifying the format that the model must output.\\n\\nConfiguring \`{ \\"type\\": \\"json_schema\\" }\` enables Structured Outputs, \\nwhich ensures the model will match your supplied JSON schema. Learn more in the \\n[Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\\n\\nThe default format is \`{ \\"type\\": \\"text\\" }\` with no additional options.\\n\\n**Not recommended for gpt-4o and newer models:**\\n\\nSetting to \`{ \\"type\\": \\"json_object\\" }\` enables the older JSON mode, which\\nensures the message the model generates is valid JSON. Using \`json_schema\`\\nis preferred for models that support it.\\n", "identifier": "TextResponseFormatConfiguration" })
export type RunStepDeltaStepDetailsToolCall = RunStepDeltaStepDetailsToolCallsCodeObject | RunStepDeltaStepDetailsToolCallsFileSearchObject | RunStepDeltaStepDetailsToolCallsFunctionObject
export const RunStepDeltaStepDetailsToolCall = Schema.Union([Schema.suspend((): Schema.Codec<RunStepDeltaStepDetailsToolCallsCodeObject> => RunStepDeltaStepDetailsToolCallsCodeObject), Schema.suspend((): Schema.Codec<RunStepDeltaStepDetailsToolCallsFileSearchObject> => RunStepDeltaStepDetailsToolCallsFileSearchObject), Schema.suspend((): Schema.Codec<RunStepDeltaStepDetailsToolCallsFunctionObject> => RunStepDeltaStepDetailsToolCallsFunctionObject)]).annotate({ "identifier": "RunStepDeltaStepDetailsToolCall" })
export type ChunkingStrategyRequestParam = AutoChunkingStrategyRequestParam | StaticChunkingStrategyRequestParam
export const ChunkingStrategyRequestParam = Schema.Union([Schema.suspend((): Schema.Codec<AutoChunkingStrategyRequestParam> => AutoChunkingStrategyRequestParam), StaticChunkingStrategyRequestParam]).annotate({ "description": "The chunking strategy used to chunk the file(s). If not set, will use the \`auto\` strategy. Only applicable if \`file_ids\` is non-empty.", "identifier": "ChunkingStrategyRequestParam" })
export type ChunkingStrategyResponse = StaticChunkingStrategyResponseParam | OtherChunkingStrategyResponseParam
export const ChunkingStrategyResponse = Schema.Union([Schema.suspend((): Schema.Codec<StaticChunkingStrategyResponseParam> => StaticChunkingStrategyResponseParam), Schema.suspend((): Schema.Codec<OtherChunkingStrategyResponseParam> => OtherChunkingStrategyResponseParam)]).annotate({ "description": "The strategy used to chunk the file.", "identifier": "ChunkingStrategyResponse" })
export type CreateTranscriptionResponseStreamEvent = TranscriptTextSegmentEvent | TranscriptTextDeltaEvent | TranscriptTextDoneEvent
export const CreateTranscriptionResponseStreamEvent = Schema.Union([TranscriptTextSegmentEvent, TranscriptTextDeltaEvent, TranscriptTextDoneEvent]).annotate({ "identifier": "CreateTranscriptionResponseStreamEvent" })
export type UsageResponse = { readonly "object": "page", readonly "data": ReadonlyArray<UsageTimeBucket>, readonly "has_more": boolean, readonly "next_page": string, readonly [x: string]: unknown }
export const UsageResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("page"), "data": Schema.Array(UsageTimeBucket), "has_more": Schema.Boolean, "next_page": Schema.String }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "UsageResponse" })
export type CreateTranscriptionRequest = { readonly "file": string, readonly "model": string | "whisper-1" | "gpt-4o-transcribe" | "gpt-4o-mini-transcribe" | "gpt-4o-mini-transcribe-2025-12-15" | "gpt-4o-transcribe-diarize", readonly "language"?: string, readonly "prompt"?: string, readonly "response_format"?: AudioResponseFormat, readonly "temperature"?: number, readonly "include"?: ReadonlyArray<TranscriptionInclude>, readonly "timestamp_granularities"?: ReadonlyArray<"word" | "segment">, readonly "stream"?: boolean | null, readonly "chunking_strategy"?: TranscriptionChunkingStrategy, readonly "known_speaker_names"?: ReadonlyArray<string>, readonly "known_speaker_references"?: ReadonlyArray<string> }
export const CreateTranscriptionRequest = Schema.Struct({ "file": Schema.String.annotate({ "description": "The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\\n", "format": "binary" }), "model": Schema.Union([Schema.String, Schema.Literals(["whisper-1", "gpt-4o-transcribe", "gpt-4o-mini-transcribe", "gpt-4o-mini-transcribe-2025-12-15", "gpt-4o-transcribe-diarize"])]).annotate({ "description": "ID of the model to use. The options are \`gpt-4o-transcribe\`, \`gpt-4o-mini-transcribe\`, \`gpt-4o-mini-transcribe-2025-12-15\`, \`whisper-1\` (which is powered by our open source Whisper V2 model), and \`gpt-4o-transcribe-diarize\`.\\n" }), "language": Schema.optionalKey(Schema.String.annotate({ "description": "The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. \`en\`) format will improve accuracy and latency.\\n" })), "prompt": Schema.optionalKey(Schema.String.annotate({ "description": "An optional text to guide the model's style or continue a previous audio segment. The [prompt](https://platform.openai.com/docs/guides/speech-to-text#prompting) should match the audio language. This field is not supported when using \`gpt-4o-transcribe-diarize\`.\\n" })), "response_format": Schema.optionalKey(Schema.suspend((): Schema.Codec<AudioResponseFormat> => AudioResponseFormat)), "temperature": Schema.optionalKey(Schema.Number.annotate({ "description": "The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.\\n", "default": 0 }).check(Schema.isFinite())), "include": Schema.optionalKey(Schema.Array(TranscriptionInclude).annotate({ "description": "Additional information to include in the transcription response.\\n\`logprobs\` will return the log probabilities of the tokens in the\\nresponse to understand the model's confidence in the transcription.\\n\`logprobs\` only works with response_format set to \`json\` and only with\\nthe models \`gpt-4o-transcribe\`, \`gpt-4o-mini-transcribe\`, and \`gpt-4o-mini-transcribe-2025-12-15\`. This field is not supported when using \`gpt-4o-transcribe-diarize\`.\\n" })), "timestamp_granularities": Schema.optionalKey(Schema.Array(Schema.Literals(["word", "segment"])).annotate({ "description": "The timestamp granularities to populate for this transcription. \`response_format\` must be set \`verbose_json\` to use timestamp granularities. Either or both of these options are supported: \`word\`, or \`segment\`. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.\\nThis option is not available for \`gpt-4o-transcribe-diarize\`.\\n", "default": ["segment"] })), "stream": Schema.optionalKey(Schema.Union([Schema.Boolean.annotate({ "description": "If set to true, the model response data will be streamed to the client\\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\\nSee the [Streaming section of the Speech-to-Text guide](https://platform.openai.com/docs/guides/speech-to-text?lang=curl#streaming-transcriptions)\\nfor more information.\\n\\nNote: Streaming is not supported for the \`whisper-1\` model and will be ignored.\\n", "default": false }), Schema.Null])), "chunking_strategy": Schema.optionalKey(TranscriptionChunkingStrategy), "known_speaker_names": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "Optional list of speaker names that correspond to the audio samples provided in \`known_speaker_references[]\`. Each entry should be a short identifier (for example \`customer\` or \`agent\`). Up to 4 speakers are supported.\\n" })), "known_speaker_references": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "Optional list of audio samples (as [data URLs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs)) that contain known speaker references matching \`known_speaker_names[]\`. Each sample must be between 2 and 10 seconds, and can use any of the same input audio formats supported by \`file\`.\\n" })) }).annotate({ "identifier": "CreateTranscriptionRequest" })
export type ListVectorStoresResponse = { readonly "object": string, readonly "data": ReadonlyArray<VectorStoreObject>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListVectorStoresResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.String, "data": Schema.Array(VectorStoreObject), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListVectorStoresResponse" })
export type VectorStoreSearchResultsPage = { readonly "object": "vector_store.search_results.page", readonly "search_query": ReadonlyArray<string>, readonly "data": ReadonlyArray<VectorStoreSearchResultItem>, readonly "has_more": boolean, readonly "next_page": string | null }
export const VectorStoreSearchResultsPage = Schema.Struct({ "object": Schema.Literal("vector_store.search_results.page").annotate({ "description": "The object type, which is always \`vector_store.search_results.page\`" }), "search_query": Schema.Array(Schema.String.annotate({ "description": "The query used for this search." })), "data": Schema.Array(Schema.suspend((): Schema.Codec<VectorStoreSearchResultItem> => VectorStoreSearchResultItem)).annotate({ "description": "The list of search result items." }), "has_more": Schema.Boolean.annotate({ "description": "Indicates if there are more results to fetch." }), "next_page": Schema.Union([Schema.String.annotate({ "description": "The token for the next page, if any." }), Schema.Null]) }).annotate({ "identifier": "VectorStoreSearchResultsPage" })
export type EvalItemContentArray = ReadonlyArray<EvalItemContentItem>
export const EvalItemContentArray = Schema.Array(Schema.suspend((): Schema.Codec<EvalItemContentItem> => EvalItemContentItem)).annotate({ "title": "An array of Input text, Output text, Input image, and Input audio", "description": "A list of inputs, each of which may be either an input text, output text, input\\nimage, or input audio object.\\n", "identifier": "EvalItemContentArray" })
export type OutputTextContent = { readonly "type": "output_text", readonly "text": string, readonly "annotations": ReadonlyArray<Annotation>, readonly "logprobs"?: ReadonlyArray<LogProb>, readonly [x: string]: unknown }
export const OutputTextContent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("output_text").annotate({ "description": "The type of the output text. Always \`output_text\`.", "default": "output_text" }), "text": Schema.String.annotate({ "description": "The text output from the model." }), "annotations": Schema.Array(Schema.suspend((): Schema.Codec<Annotation> => Annotation)).annotate({ "description": "The annotations of the text output." }), "logprobs": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<LogProb> => LogProb))) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Output text", "description": "A text output from the model.", "identifier": "OutputTextContent" })
export type FunctionAndCustomToolCallOutput = InputTextContent | InputImageContent | InputFileContent
export const FunctionAndCustomToolCallOutput = Schema.Union([Schema.suspend((): Schema.Codec<InputTextContent> => InputTextContent), InputImageContent, InputFileContent]).annotate({ "identifier": "FunctionAndCustomToolCallOutput" })
export type InputContent = InputTextContent | InputImageContent | InputFileContent
export const InputContent = Schema.Union([Schema.suspend((): Schema.Codec<InputTextContent> => InputTextContent), Schema.suspend((): Schema.Codec<InputImageContent> => InputImageContent), Schema.suspend((): Schema.Codec<InputFileContent> => InputFileContent)]).annotate({ "identifier": "InputContent" })
export type ResponsePromptVariables = { readonly [x: string]: string | InputTextContent | InputImageContent | InputFileContent } | null
export const ResponsePromptVariables = Schema.Union([Schema.Record(Schema.String, Schema.Union([Schema.String, Schema.suspend((): Schema.Codec<InputTextContent> => InputTextContent), Schema.suspend((): Schema.Codec<InputImageContent> => InputImageContent), Schema.suspend((): Schema.Codec<InputFileContent> => InputFileContent)])).annotate({ "title": "Prompt Variables", "description": "Optional map of values to substitute in for variables in your\\nprompt. The substitution values can either be strings, or other\\nResponse input types like images or files.\\n" }), Schema.Null]).annotate({ "identifier": "ResponsePromptVariables" })
export type ComputerAction = ClickParam | DoubleClickAction | Drag | KeyPressAction | Move | Screenshot | Scroll | Type | Wait
export const ComputerAction = Schema.Union([ClickParam, DoubleClickAction, Drag, KeyPressAction, Move, Screenshot, Scroll, Type, Wait]).annotate({ "identifier": "ComputerAction" })
export type FunctionShellCallOutput = { readonly "type": "shell_call_output", readonly "id": string, readonly "call_id": string, readonly "output": ReadonlyArray<FunctionShellCallOutputContent>, readonly "max_output_length": number | null, readonly "created_by"?: string, readonly [x: string]: unknown }
export const FunctionShellCallOutput = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("shell_call_output").annotate({ "description": "The type of the shell call output. Always \`shell_call_output\`.", "default": "shell_call_output" }), "id": Schema.String.annotate({ "description": "The unique ID of the shell call output. Populated when this item is returned via API." }), "call_id": Schema.String.annotate({ "description": "The unique ID of the shell tool call generated by the model." }), "output": Schema.Array(Schema.suspend((): Schema.Codec<FunctionShellCallOutputContent> => FunctionShellCallOutputContent)).annotate({ "description": "An array of shell call output contents" }), "max_output_length": Schema.Union([Schema.Number.annotate({ "description": "The maximum length of the shell command output. This is generated by the model and should be passed back with the raw output." }).check(Schema.isInt()), Schema.Null]), "created_by": Schema.optionalKey(Schema.String) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell call output", "description": "The output of a shell tool call.", "identifier": "FunctionShellCallOutput" })
export type FunctionCallOutputItemParam = { readonly "id"?: string | null, readonly "call_id": string, readonly "type": "function_call_output", readonly "output": string | ReadonlyArray<InputTextContentParam | InputImageContentParamAutoParam | InputFileContentParam>, readonly "status"?: FunctionCallItemStatus | null, readonly [x: string]: unknown }
export const FunctionCallOutputItemParam = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The unique ID of the function tool call output. Populated when this item is returned via API." }), Schema.Null])), "call_id": Schema.String.annotate({ "description": "The unique ID of the function tool call generated by the model." }), "type": Schema.Literal("function_call_output").annotate({ "description": "The type of the function tool call output. Always \`function_call_output\`.", "default": "function_call_output" }), "output": Schema.Union([Schema.String.annotate({ "description": "A JSON string of the output of the function tool call." }), Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<InputTextContentParam> => InputTextContentParam), Schema.suspend((): Schema.Codec<InputImageContentParamAutoParam> => InputImageContentParamAutoParam), Schema.suspend((): Schema.Codec<InputFileContentParam> => InputFileContentParam)]))]).annotate({ "description": "Text, image, or file output of the function tool call." }), "status": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<FunctionCallItemStatus> => FunctionCallItemStatus).annotate({ "description": "The status of the item. One of \`in_progress\`, \`completed\`, or \`incomplete\`. Populated when items are returned via API." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool call output", "description": "The output of a function tool call.", "identifier": "FunctionCallOutputItemParam" })
export type FunctionShellCallOutputContentParam = { readonly "stdout": string, readonly "stderr": string, readonly "outcome": FunctionShellCallOutputOutcomeParam, readonly [x: string]: unknown }
export const FunctionShellCallOutputContentParam = Schema.StructWithRest(Schema.Struct({ "stdout": Schema.String.annotate({ "description": "Captured stdout output for the shell call." }), "stderr": Schema.String.annotate({ "description": "Captured stderr output for the shell call." }), "outcome": Schema.suspend((): Schema.Codec<FunctionShellCallOutputOutcomeParam> => FunctionShellCallOutputOutcomeParam).annotate({ "description": "The exit or timeout outcome associated with this shell call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell output content", "description": "Captured stdout and stderr for a portion of a shell tool call output.", "identifier": "FunctionShellCallOutputContentParam" })
export type ApplyPatchToolCallItemParam = { readonly "type": "apply_patch_call", readonly "id"?: string | null, readonly "call_id": string, readonly "status": ApplyPatchCallStatusParam, readonly "operation": ApplyPatchOperationParam, readonly [x: string]: unknown }
export const ApplyPatchToolCallItemParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("apply_patch_call").annotate({ "description": "The type of the item. Always \`apply_patch_call\`.", "default": "apply_patch_call" }), "id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The unique ID of the apply patch tool call. Populated when this item is returned via API." }), Schema.Null])), "call_id": Schema.String.annotate({ "description": "The unique ID of the apply patch tool call generated by the model." }), "status": Schema.suspend((): Schema.Codec<ApplyPatchCallStatusParam> => ApplyPatchCallStatusParam).annotate({ "description": "The status of the apply patch tool call. One of \`in_progress\` or \`completed\`." }), "operation": Schema.suspend((): Schema.Codec<ApplyPatchOperationParam> => ApplyPatchOperationParam).annotate({ "description": "The specific create, delete, or update instruction for the apply_patch tool call." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Apply patch tool call", "description": "A tool call representing a request to create, delete, or update files using diff patches.", "identifier": "ApplyPatchToolCallItemParam" })
export type CodeInterpreterTool = { readonly "type": "code_interpreter", readonly "container": string | CodeInterpreterContainerAuto, readonly [x: string]: unknown }
export const CodeInterpreterTool = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("code_interpreter").annotate({ "description": "The type of the code interpreter tool. Always \`code_interpreter\`.\\n" }), "container": Schema.Union([Schema.String.annotate({ "description": "The container ID." }), CodeInterpreterContainerAuto]).annotate({ "description": "The code interpreter container. Can be a container ID or an object that\\nspecifies uploaded file IDs to make available to your code, along with an\\noptional \`memory_limit\` setting.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Code interpreter", "description": "A tool that runs Python code to help generate a response to a prompt.\\n", "identifier": "CodeInterpreterTool" })
export type CustomToolParam = { readonly "type": "custom", readonly "name": string, readonly "description"?: string, readonly "format"?: CustomTextFormatParam | CustomGrammarFormatParam, readonly [x: string]: unknown }
export const CustomToolParam = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("custom").annotate({ "description": "The type of the custom tool. Always \`custom\`.", "default": "custom" }), "name": Schema.String.annotate({ "description": "The name of the custom tool, used to identify it in tool calls." }), "description": Schema.optionalKey(Schema.String.annotate({ "description": "Optional description of the custom tool, used to provide more context." })), "format": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<CustomTextFormatParam> => CustomTextFormatParam), Schema.suspend((): Schema.Codec<CustomGrammarFormatParam> => CustomGrammarFormatParam)]).annotate({ "description": "The input format for the custom tool. Default is unconstrained text." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Custom tool", "description": "A custom tool that processes input using a specified format. Learn more about   [custom tools](https://platform.openai.com/docs/guides/function-calling#custom-tools)", "identifier": "CustomToolParam" })
export type ImagesResponse = { readonly "created": number, readonly "data"?: ReadonlyArray<Image>, readonly "background"?: "transparent" | "opaque", readonly "output_format"?: "png" | "webp" | "jpeg", readonly "size"?: "1024x1024" | "1024x1536" | "1536x1024", readonly "quality"?: "low" | "medium" | "high", readonly "usage"?: ImageGenUsage, readonly [x: string]: unknown }
export const ImagesResponse = Schema.StructWithRest(Schema.Struct({ "created": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the image was created." }).check(Schema.isInt()), "data": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<Image> => Image)).annotate({ "description": "The list of generated images." })), "background": Schema.optionalKey(Schema.Literals(["transparent", "opaque"]).annotate({ "description": "The background parameter used for the image generation. Either \`transparent\` or \`opaque\`." })), "output_format": Schema.optionalKey(Schema.Literals(["png", "webp", "jpeg"]).annotate({ "description": "The output format of the image generation. Either \`png\`, \`webp\`, or \`jpeg\`." })), "size": Schema.optionalKey(Schema.Literals(["1024x1024", "1024x1536", "1536x1024"]).annotate({ "description": "The size of the image generated. Either \`1024x1024\`, \`1024x1536\`, or \`1536x1024\`." })), "quality": Schema.optionalKey(Schema.Literals(["low", "medium", "high"]).annotate({ "description": "The quality of the image generated. Either \`low\`, \`medium\`, or \`high\`." })), "usage": Schema.optionalKey(ImageGenUsage) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Image generation response", "description": "The response from the image generation endpoint.", "identifier": "ImagesResponse" })
export type VideoListResource = { readonly "object": "list", readonly "data": ReadonlyArray<VideoResource>, readonly "first_id": string | null, readonly "last_id": string | null, readonly "has_more": boolean, readonly [x: string]: unknown }
export const VideoListResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be \`list\`.", "default": "list" }), "data": Schema.Array(Schema.suspend((): Schema.Codec<VideoResource> => VideoResource)).annotate({ "description": "A list of items" }), "first_id": Schema.Union([Schema.String.annotate({ "description": "The ID of the first item in the list." }), Schema.Null]), "last_id": Schema.Union([Schema.String.annotate({ "description": "The ID of the last item in the list." }), Schema.Null]), "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "VideoListResource" })
export type ChatSessionResource = { readonly "id": string, readonly "object": "chatkit.session", readonly "expires_at": number, readonly "client_secret": string, readonly "workflow": ChatkitWorkflow, readonly "user": string, readonly "rate_limits": ChatSessionRateLimits, readonly "max_requests_per_1_minute": number, readonly "status": ChatSessionStatus, readonly "chatkit_configuration": ChatSessionChatkitConfiguration, readonly [x: string]: unknown }
export const ChatSessionResource = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier for the ChatKit session." }), "object": Schema.Literal("chatkit.session").annotate({ "description": "Type discriminator that is always \`chatkit.session\`.", "default": "chatkit.session" }), "expires_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the session expires." }).check(Schema.isInt()), "client_secret": Schema.String.annotate({ "description": "Ephemeral client secret that authenticates session requests." }), "workflow": Schema.suspend((): Schema.Codec<ChatkitWorkflow> => ChatkitWorkflow).annotate({ "description": "Workflow metadata for the session." }), "user": Schema.String.annotate({ "description": "User identifier associated with the session." }), "rate_limits": Schema.suspend((): Schema.Codec<ChatSessionRateLimits> => ChatSessionRateLimits).annotate({ "description": "Resolved rate limit values." }), "max_requests_per_1_minute": Schema.Number.annotate({ "description": "Convenience copy of the per-minute request limit." }).check(Schema.isInt()), "status": Schema.suspend((): Schema.Codec<ChatSessionStatus> => ChatSessionStatus).annotate({ "description": "Current lifecycle state of the session." }), "chatkit_configuration": Schema.suspend((): Schema.Codec<ChatSessionChatkitConfiguration> => ChatSessionChatkitConfiguration).annotate({ "description": "Resolved ChatKit feature configuration for the session." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "The chat session object", "description": "Represents a ChatKit session and its resolved configuration.", "identifier": "ChatSessionResource" })
export type CreateChatSessionBody = { readonly "workflow": WorkflowParam, readonly "user": string, readonly "expires_after"?: ExpiresAfterParam, readonly "rate_limits"?: RateLimitsParam, readonly "chatkit_configuration"?: ChatkitConfigurationParam, readonly [x: string]: unknown }
export const CreateChatSessionBody = Schema.StructWithRest(Schema.Struct({ "workflow": Schema.suspend((): Schema.Codec<WorkflowParam> => WorkflowParam).annotate({ "description": "Workflow that powers the session." }), "user": Schema.String.annotate({ "description": "A free-form string that identifies your end user; ensures this Session can access other objects that have the same \`user\` scope." }), "expires_after": Schema.optionalKey(Schema.suspend((): Schema.Codec<ExpiresAfterParam> => ExpiresAfterParam).annotate({ "description": "Optional override for session expiration timing in seconds from creation. Defaults to 10 minutes." })), "rate_limits": Schema.optionalKey(Schema.suspend((): Schema.Codec<RateLimitsParam> => RateLimitsParam).annotate({ "description": "Optional override for per-minute request limits. When omitted, defaults to 10." })), "chatkit_configuration": Schema.optionalKey(Schema.suspend((): Schema.Codec<ChatkitConfigurationParam> => ChatkitConfigurationParam).annotate({ "description": "Optional overrides for ChatKit runtime configuration features" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Create chat session request", "description": "Parameters for provisioning a new ChatKit session.", "identifier": "CreateChatSessionBody" })
export type UserMessageItem = { readonly "id": string, readonly "object": "chatkit.thread_item", readonly "created_at": number, readonly "thread_id": string, readonly "type": "chatkit.user_message", readonly "content": ReadonlyArray<UserMessageInputText | UserMessageQuotedText>, readonly "attachments": ReadonlyArray<Attachment>, readonly "inference_options": InferenceOptions | null, readonly [x: string]: unknown }
export const UserMessageItem = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the thread item." }), "object": Schema.Literal("chatkit.thread_item").annotate({ "description": "Type discriminator that is always \`chatkit.thread_item\`.", "default": "chatkit.thread_item" }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." }).check(Schema.isInt()), "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }), "type": Schema.Literal("chatkit.user_message").annotate({ "default": "chatkit.user_message" }), "content": Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<UserMessageInputText> => UserMessageInputText), Schema.suspend((): Schema.Codec<UserMessageQuotedText> => UserMessageQuotedText)]).annotate({ "description": "Content blocks that comprise a user message." })).annotate({ "description": "Ordered content elements supplied by the user." }), "attachments": Schema.Array(Schema.suspend((): Schema.Codec<Attachment> => Attachment)).annotate({ "description": "Attachments associated with the user message. Defaults to an empty list." }), "inference_options": Schema.Union([Schema.suspend((): Schema.Codec<InferenceOptions> => InferenceOptions).annotate({ "description": "Inference overrides applied to the message. Defaults to null when unset." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "User Message Item", "description": "User-authored messages within a thread.", "identifier": "UserMessageItem" })
export type ResponseOutputText = { readonly "type": "output_text", readonly "text": string, readonly "annotations": ReadonlyArray<FileAnnotation | UrlAnnotation>, readonly [x: string]: unknown }
export const ResponseOutputText = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("output_text").annotate({ "description": "Type discriminator that is always \`output_text\`.", "default": "output_text" }), "text": Schema.String.annotate({ "description": "Assistant generated text." }), "annotations": Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<FileAnnotation> => FileAnnotation), Schema.suspend((): Schema.Codec<UrlAnnotation> => UrlAnnotation)]).annotate({ "description": "Annotation object describing a cited source." })).annotate({ "description": "Ordered list of annotations attached to the response text." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Assistant message content", "description": "Assistant response text accompanied by optional annotations.", "identifier": "ResponseOutputText" })
export type TaskGroupItem = { readonly "id": string, readonly "object": "chatkit.thread_item", readonly "created_at": number, readonly "thread_id": string, readonly "type": "chatkit.task_group", readonly "tasks": ReadonlyArray<TaskGroupTask>, readonly [x: string]: unknown }
export const TaskGroupItem = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the thread item." }), "object": Schema.Literal("chatkit.thread_item").annotate({ "description": "Type discriminator that is always \`chatkit.thread_item\`.", "default": "chatkit.thread_item" }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." }).check(Schema.isInt()), "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }), "type": Schema.Literal("chatkit.task_group").annotate({ "description": "Type discriminator that is always \`chatkit.task_group\`.", "default": "chatkit.task_group" }), "tasks": Schema.Array(Schema.suspend((): Schema.Codec<TaskGroupTask> => TaskGroupTask)).annotate({ "description": "Tasks included in the group." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Task group", "description": "Collection of workflow tasks grouped together in the thread.", "identifier": "TaskGroupItem" })
export type ThreadListResource = { readonly "object": "list", readonly "data": ReadonlyArray<ThreadResource>, readonly "first_id": string | null, readonly "last_id": string | null, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ThreadListResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be \`list\`.", "default": "list" }), "data": Schema.Array(Schema.suspend((): Schema.Codec<ThreadResource> => ThreadResource)).annotate({ "description": "A list of items" }), "first_id": Schema.Union([Schema.String.annotate({ "description": "The ID of the first item in the list." }), Schema.Null]), "last_id": Schema.Union([Schema.String.annotate({ "description": "The ID of the last item in the list." }), Schema.Null]), "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Threads", "description": "A paginated list of ChatKit threads.", "identifier": "ThreadListResource" })
export type CompoundFilter = { readonly "type": "and" | "or", readonly "filters": ReadonlyArray<ComparisonFilter | unknown> }
export const CompoundFilter = Schema.Struct({ "type": Schema.Literals(["and", "or"]).annotate({ "description": "Type of operation: \`and\` or \`or\`." }), "filters": Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<ComparisonFilter> => ComparisonFilter), Schema.Unknown])).annotate({ "description": "Array of filters to combine. Items can be \`ComparisonFilter\` or \`CompoundFilter\`." }) }).annotate({ "title": "Compound Filter", "description": "Combine multiple filters using \`and\` or \`or\`.", "identifier": "CompoundFilter" })
export type ListBatchesResponse = { readonly "data": ReadonlyArray<Batch>, readonly "first_id"?: string, readonly "last_id"?: string, readonly "has_more": boolean, readonly "object": "list", readonly [x: string]: unknown }
export const ListBatchesResponse = Schema.StructWithRest(Schema.Struct({ "data": Schema.Array(Schema.suspend((): Schema.Codec<Batch> => Batch)), "first_id": Schema.optionalKey(Schema.String), "last_id": Schema.optionalKey(Schema.String), "has_more": Schema.Boolean, "object": Schema.Literal("list") }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListBatchesResponse" })
export type ModelIdsResponses = ModelIdsShared | "o1-pro" | "o1-pro-2025-03-19" | "o3-pro" | "o3-pro-2025-06-10" | "o3-deep-research" | "o3-deep-research-2025-06-26" | "o4-mini-deep-research" | "o4-mini-deep-research-2025-06-26" | "computer-use-preview" | "computer-use-preview-2025-03-11" | "gpt-5-codex" | "gpt-5-pro" | "gpt-5-pro-2025-10-06" | "gpt-5.1-codex-max"
export const ModelIdsResponses = Schema.Union([Schema.suspend((): Schema.Codec<ModelIdsShared> => ModelIdsShared), Schema.Literals(["o1-pro", "o1-pro-2025-03-19", "o3-pro", "o3-pro-2025-06-10", "o3-deep-research", "o3-deep-research-2025-06-26", "o4-mini-deep-research", "o4-mini-deep-research-2025-06-26", "computer-use-preview", "computer-use-preview-2025-03-11", "gpt-5-codex", "gpt-5-pro", "gpt-5-pro-2025-10-06", "gpt-5.1-codex-max"]).annotate({ "title": "ResponsesOnlyModel" })]).annotate({ "identifier": "ModelIdsResponses" })
export type AuditLog = { readonly "id": string, readonly "type": AuditLogEventType, readonly "effective_at": number, readonly "project"?: { readonly "id"?: string, readonly "name"?: string, readonly [x: string]: unknown }, readonly "actor": AuditLogActor, readonly "api_key.created"?: { readonly "id"?: string, readonly "data"?: { readonly "scopes"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "api_key.updated"?: { readonly "id"?: string, readonly "changes_requested"?: { readonly "scopes"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "api_key.deleted"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "checkpoint.permission.created"?: { readonly "id"?: string, readonly "data"?: { readonly "project_id"?: string, readonly "fine_tuned_model_checkpoint"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "checkpoint.permission.deleted"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "external_key.registered"?: { readonly "id"?: string, readonly "data"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "external_key.removed"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "group.created"?: { readonly "id"?: string, readonly "data"?: { readonly "group_name"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "group.updated"?: { readonly "id"?: string, readonly "changes_requested"?: { readonly "group_name"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "group.deleted"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "scim.enabled"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "scim.disabled"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "invite.sent"?: { readonly "id"?: string, readonly "data"?: { readonly "email"?: string, readonly "role"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "invite.accepted"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "invite.deleted"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "ip_allowlist.created"?: { readonly "id"?: string, readonly "name"?: string, readonly "allowed_ips"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly "ip_allowlist.updated"?: { readonly "id"?: string, readonly "allowed_ips"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly "ip_allowlist.deleted"?: { readonly "id"?: string, readonly "name"?: string, readonly "allowed_ips"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly "ip_allowlist.config.activated"?: { readonly "configs"?: ReadonlyArray<{ readonly "id"?: string, readonly "name"?: string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }, readonly "ip_allowlist.config.deactivated"?: { readonly "configs"?: ReadonlyArray<{ readonly "id"?: string, readonly "name"?: string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }, readonly "login.succeeded"?: { readonly [x: string]: unknown }, readonly "login.failed"?: { readonly "error_code"?: string, readonly "error_message"?: string, readonly [x: string]: unknown }, readonly "logout.succeeded"?: { readonly [x: string]: unknown }, readonly "logout.failed"?: { readonly "error_code"?: string, readonly "error_message"?: string, readonly [x: string]: unknown }, readonly "organization.updated"?: { readonly "id"?: string, readonly "changes_requested"?: { readonly "title"?: string, readonly "description"?: string, readonly "name"?: string, readonly "threads_ui_visibility"?: string, readonly "usage_dashboard_visibility"?: string, readonly "api_call_logging"?: string, readonly "api_call_logging_project_ids"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "project.created"?: { readonly "id"?: string, readonly "data"?: { readonly "name"?: string, readonly "title"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "project.updated"?: { readonly "id"?: string, readonly "changes_requested"?: { readonly "title"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "project.archived"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "project.deleted"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "rate_limit.updated"?: { readonly "id"?: string, readonly "changes_requested"?: { readonly "max_requests_per_1_minute"?: number, readonly "max_tokens_per_1_minute"?: number, readonly "max_images_per_1_minute"?: number, readonly "max_audio_megabytes_per_1_minute"?: number, readonly "max_requests_per_1_day"?: number, readonly "batch_1_day_max_input_tokens"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "rate_limit.deleted"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "role.created"?: { readonly "id"?: string, readonly "role_name"?: string, readonly "permissions"?: ReadonlyArray<string>, readonly "resource_type"?: string, readonly "resource_id"?: string, readonly [x: string]: unknown }, readonly "role.updated"?: { readonly "id"?: string, readonly "changes_requested"?: { readonly "role_name"?: string, readonly "resource_id"?: string, readonly "resource_type"?: string, readonly "permissions_added"?: ReadonlyArray<string>, readonly "permissions_removed"?: ReadonlyArray<string>, readonly "description"?: string, readonly "metadata"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "role.deleted"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "role.assignment.created"?: { readonly "id"?: string, readonly "principal_id"?: string, readonly "principal_type"?: string, readonly "resource_id"?: string, readonly "resource_type"?: string, readonly [x: string]: unknown }, readonly "role.assignment.deleted"?: { readonly "id"?: string, readonly "principal_id"?: string, readonly "principal_type"?: string, readonly "resource_id"?: string, readonly "resource_type"?: string, readonly [x: string]: unknown }, readonly "service_account.created"?: { readonly "id"?: string, readonly "data"?: { readonly "role"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "service_account.updated"?: { readonly "id"?: string, readonly "changes_requested"?: { readonly "role"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "service_account.deleted"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "user.added"?: { readonly "id"?: string, readonly "data"?: { readonly "role"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "user.updated"?: { readonly "id"?: string, readonly "changes_requested"?: { readonly "role"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "user.deleted"?: { readonly "id"?: string, readonly [x: string]: unknown }, readonly "certificate.created"?: { readonly "id"?: string, readonly "name"?: string, readonly [x: string]: unknown }, readonly "certificate.updated"?: { readonly "id"?: string, readonly "name"?: string, readonly [x: string]: unknown }, readonly "certificate.deleted"?: { readonly "id"?: string, readonly "name"?: string, readonly "certificate"?: string, readonly [x: string]: unknown }, readonly "certificates.activated"?: { readonly "certificates"?: ReadonlyArray<{ readonly "id"?: string, readonly "name"?: string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }, readonly "certificates.deactivated"?: { readonly "certificates"?: ReadonlyArray<{ readonly "id"?: string, readonly "name"?: string, readonly [x: string]: unknown }>, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const AuditLog = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The ID of this log." }), "type": AuditLogEventType, "effective_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of the event." }).check(Schema.isInt()), "project": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The project title." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The project that the action was scoped to. Absent for actions not scoped to projects. Note that any admin actions taken via Admin API keys are associated with the default project." })), "actor": AuditLogActor, "api_key.created": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The tracking ID of the API key." })), "data": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "scopes": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "A list of scopes allowed for the API key, e.g. \`[\\"api.model.request\\"]\`" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to create the API key." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "api_key.updated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The tracking ID of the API key." })), "changes_requested": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "scopes": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "A list of scopes allowed for the API key, e.g. \`[\\"api.model.request\\"]\`" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to update the API key." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "api_key.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The tracking ID of the API key." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "checkpoint.permission.created": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the checkpoint permission." })), "data": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "project_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the project that the checkpoint permission was created for." })), "fine_tuned_model_checkpoint": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the fine-tuned model checkpoint." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to create the checkpoint permission." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The project and fine-tuned model checkpoint that the checkpoint permission was created for." })), "checkpoint.permission.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the checkpoint permission." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "external_key.registered": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the external key configuration." })), "data": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The configuration for the external key." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "external_key.removed": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the external key configuration." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "group.created": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the group." })), "data": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "group_name": Schema.optionalKey(Schema.String.annotate({ "description": "The group name." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Information about the created group." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "group.updated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the group." })), "changes_requested": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "group_name": Schema.optionalKey(Schema.String.annotate({ "description": "The updated group name." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to update the group." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "group.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the group." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "scim.enabled": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the SCIM was enabled for." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "scim.disabled": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the SCIM was disabled for." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "invite.sent": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the invite." })), "data": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "email": Schema.optionalKey(Schema.String.annotate({ "description": "The email invited to the organization." })), "role": Schema.optionalKey(Schema.String.annotate({ "description": "The role the email was invited to be. Is either \`owner\` or \`member\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to create the invite." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "invite.accepted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the invite." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "invite.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the invite." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "ip_allowlist.created": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the IP allowlist configuration." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the IP allowlist configuration." })), "allowed_ips": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "The IP addresses or CIDR ranges included in the configuration." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "ip_allowlist.updated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the IP allowlist configuration." })), "allowed_ips": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "The updated set of IP addresses or CIDR ranges in the configuration." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "ip_allowlist.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the IP allowlist configuration." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the IP allowlist configuration." })), "allowed_ips": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "The IP addresses or CIDR ranges that were in the configuration." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "ip_allowlist.config.activated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "configs": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the IP allowlist configuration." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the IP allowlist configuration." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The configurations that were activated." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "ip_allowlist.config.deactivated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "configs": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the IP allowlist configuration." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the IP allowlist configuration." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "The configurations that were deactivated." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "login.succeeded": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "This event has no additional fields beyond the standard audit log attributes." })), "login.failed": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "error_code": Schema.optionalKey(Schema.String.annotate({ "description": "The error code of the failure." })), "error_message": Schema.optionalKey(Schema.String.annotate({ "description": "The error message of the failure." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "logout.succeeded": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "This event has no additional fields beyond the standard audit log attributes." })), "logout.failed": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "error_code": Schema.optionalKey(Schema.String.annotate({ "description": "The error code of the failure." })), "error_message": Schema.optionalKey(Schema.String.annotate({ "description": "The error message of the failure." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "organization.updated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The organization ID." })), "changes_requested": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "title": Schema.optionalKey(Schema.String.annotate({ "description": "The organization title." })), "description": Schema.optionalKey(Schema.String.annotate({ "description": "The organization description." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The organization name." })), "threads_ui_visibility": Schema.optionalKey(Schema.String.annotate({ "description": "Visibility of the threads page which shows messages created with the Assistants API and Playground. One of \`ANY_ROLE\`, \`OWNERS\`, or \`NONE\`." })), "usage_dashboard_visibility": Schema.optionalKey(Schema.String.annotate({ "description": "Visibility of the usage dashboard which shows activity and costs for your organization. One of \`ANY_ROLE\` or \`OWNERS\`." })), "api_call_logging": Schema.optionalKey(Schema.String.annotate({ "description": "How your organization logs data from supported API calls. One of \`disabled\`, \`enabled_per_call\`, \`enabled_for_all_projects\`, or \`enabled_for_selected_projects\`" })), "api_call_logging_project_ids": Schema.optionalKey(Schema.String.annotate({ "description": "The list of project ids if api_call_logging is set to \`enabled_for_selected_projects\`" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to update the organization settings." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "project.created": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })), "data": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "name": Schema.optionalKey(Schema.String.annotate({ "description": "The project name." })), "title": Schema.optionalKey(Schema.String.annotate({ "description": "The title of the project as seen on the dashboard." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to create the project." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "project.updated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })), "changes_requested": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "title": Schema.optionalKey(Schema.String.annotate({ "description": "The title of the project as seen on the dashboard." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to update the project." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "project.archived": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "project.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "rate_limit.updated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The rate limit ID" })), "changes_requested": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "max_requests_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum requests per minute." }).check(Schema.isInt())), "max_tokens_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum tokens per minute." }).check(Schema.isInt())), "max_images_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum images per minute. Only relevant for certain models." }).check(Schema.isInt())), "max_audio_megabytes_per_1_minute": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum audio megabytes per minute. Only relevant for certain models." }).check(Schema.isInt())), "max_requests_per_1_day": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum requests per day. Only relevant for certain models." }).check(Schema.isInt())), "batch_1_day_max_input_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum batch input tokens per day. Only relevant for certain models." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to update the rate limits." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "rate_limit.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The rate limit ID" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "role.created": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The role ID." })), "role_name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the role." })), "permissions": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "The permissions granted by the role." })), "resource_type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of resource the role belongs to." })), "resource_id": Schema.optionalKey(Schema.String.annotate({ "description": "The resource the role is scoped to." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "role.updated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The role ID." })), "changes_requested": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "role_name": Schema.optionalKey(Schema.String.annotate({ "description": "The updated role name, when provided." })), "resource_id": Schema.optionalKey(Schema.String.annotate({ "description": "The resource the role is scoped to." })), "resource_type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of resource the role belongs to." })), "permissions_added": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "The permissions added to the role." })), "permissions_removed": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "The permissions removed from the role." })), "description": Schema.optionalKey(Schema.String.annotate({ "description": "The updated role description, when provided." })), "metadata": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "Additional metadata stored on the role." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to update the role." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "role.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The role ID." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "role.assignment.created": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The identifier of the role assignment." })), "principal_id": Schema.optionalKey(Schema.String.annotate({ "description": "The principal (user or group) that received the role." })), "principal_type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of principal (user or group) that received the role." })), "resource_id": Schema.optionalKey(Schema.String.annotate({ "description": "The resource the role assignment is scoped to." })), "resource_type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of resource the role assignment is scoped to." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "role.assignment.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The identifier of the role assignment." })), "principal_id": Schema.optionalKey(Schema.String.annotate({ "description": "The principal (user or group) that had the role removed." })), "principal_type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of principal (user or group) that had the role removed." })), "resource_id": Schema.optionalKey(Schema.String.annotate({ "description": "The resource the role assignment was scoped to." })), "resource_type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of resource the role assignment was scoped to." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "service_account.created": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The service account ID." })), "data": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "role": Schema.optionalKey(Schema.String.annotate({ "description": "The role of the service account. Is either \`owner\` or \`member\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to create the service account." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "service_account.updated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The service account ID." })), "changes_requested": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "role": Schema.optionalKey(Schema.String.annotate({ "description": "The role of the service account. Is either \`owner\` or \`member\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to updated the service account." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "service_account.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The service account ID." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "user.added": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The user ID." })), "data": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "role": Schema.optionalKey(Schema.String.annotate({ "description": "The role of the user. Is either \`owner\` or \`member\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to add the user to the project." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "user.updated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The project ID." })), "changes_requested": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "role": Schema.optionalKey(Schema.String.annotate({ "description": "The role of the user. Is either \`owner\` or \`member\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The payload used to update the user." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "user.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The user ID." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "certificate.created": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate ID." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the certificate." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "certificate.updated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate ID." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the certificate." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "certificate.deleted": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate ID." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the certificate." })), "certificate": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate content in PEM format." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "certificates.activated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "certificates": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate ID." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the certificate." })) }), [Schema.Record(Schema.String, Schema.Unknown)]))) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })), "certificates.deactivated": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "certificates": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The certificate ID." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the certificate." })) }), [Schema.Record(Schema.String, Schema.Unknown)]))) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The details for events with this \`type\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A log of a user action or configuration change within this organization.", "identifier": "AuditLog" })
export type CreateChatCompletionResponse = { readonly "id": string, readonly "choices": ReadonlyArray<{ readonly "finish_reason": "stop" | "length" | "tool_calls" | "content_filter" | "function_call", readonly "index": number, readonly "message": ChatCompletionResponseMessage, readonly "logprobs": { readonly "content": ReadonlyArray<ChatCompletionTokenLogprob> | null, readonly "refusal": ReadonlyArray<ChatCompletionTokenLogprob> | null, readonly [x: string]: unknown } | null, readonly [x: string]: unknown }>, readonly "created": number, readonly "model": string, readonly "service_tier"?: ServiceTier, readonly "system_fingerprint"?: string, readonly "object": "chat.completion", readonly "usage"?: CompletionUsage, readonly [x: string]: unknown }
export const CreateChatCompletionResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "A unique identifier for the chat completion." }), "choices": Schema.Array(Schema.StructWithRest(Schema.Struct({ "finish_reason": Schema.Literals(["stop", "length", "tool_calls", "content_filter", "function_call"]).annotate({ "description": "The reason the model stopped generating tokens. This will be \`stop\` if the model hit a natural stop point or a provided stop sequence,\\n\`length\` if the maximum number of tokens specified in the request was reached,\\n\`content_filter\` if content was omitted due to a flag from our content filters,\\n\`tool_calls\` if the model called a tool, or \`function_call\` (deprecated) if the model called a function.\\n" }), "index": Schema.Number.annotate({ "description": "The index of the choice in the list of choices." }).check(Schema.isInt()), "message": Schema.suspend((): Schema.Codec<ChatCompletionResponseMessage> => ChatCompletionResponseMessage), "logprobs": Schema.Union([Schema.StructWithRest(Schema.Struct({ "content": Schema.Union([Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionTokenLogprob> => ChatCompletionTokenLogprob)).annotate({ "description": "A list of message content tokens with log probability information." }), Schema.Null]), "refusal": Schema.Union([Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionTokenLogprob> => ChatCompletionTokenLogprob)).annotate({ "description": "A list of message refusal tokens with log probability information." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Log probability information for the choice." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "A list of chat completion choices. Can be more than one if \`n\` is greater than 1." }), "created": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) of when the chat completion was created." }).check(Schema.isInt()), "model": Schema.String.annotate({ "description": "The model used for the chat completion." }), "service_tier": Schema.optionalKey(ServiceTier), "system_fingerprint": Schema.optionalKey(Schema.String.annotate({ "description": "This fingerprint represents the backend configuration that the model runs with.\\n\\nCan be used in conjunction with the \`seed\` request parameter to understand when backend changes have been made that might impact determinism.\\n" })), "object": Schema.Literal("chat.completion").annotate({ "description": "The object type, which is always \`chat.completion\`." }), "usage": Schema.optionalKey(Schema.suspend((): Schema.Codec<CompletionUsage> => CompletionUsage)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Represents a chat completion response returned by model, based on the provided input.", "identifier": "CreateChatCompletionResponse" })
export type ChatCompletionRequestMessage = ChatCompletionRequestDeveloperMessage | ChatCompletionRequestSystemMessage | ChatCompletionRequestUserMessage | ChatCompletionRequestAssistantMessage | ChatCompletionRequestToolMessage | ChatCompletionRequestFunctionMessage
export const ChatCompletionRequestMessage = Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionRequestDeveloperMessage> => ChatCompletionRequestDeveloperMessage), ChatCompletionRequestSystemMessage, ChatCompletionRequestUserMessage, Schema.suspend((): Schema.Codec<ChatCompletionRequestAssistantMessage> => ChatCompletionRequestAssistantMessage), ChatCompletionRequestToolMessage, Schema.suspend((): Schema.Codec<ChatCompletionRequestFunctionMessage> => ChatCompletionRequestFunctionMessage)]).annotate({ "identifier": "ChatCompletionRequestMessage" })
export type RunStepDetailsToolCall = RunStepDetailsToolCallsCodeObject | RunStepDetailsToolCallsFileSearchObject | RunStepDetailsToolCallsFunctionObject
export const RunStepDetailsToolCall = Schema.Union([Schema.suspend((): Schema.Codec<RunStepDetailsToolCallsCodeObject> => RunStepDetailsToolCallsCodeObject), Schema.suspend((): Schema.Codec<RunStepDetailsToolCallsFileSearchObject> => RunStepDetailsToolCallsFileSearchObject), Schema.suspend((): Schema.Codec<RunStepDetailsToolCallsFunctionObject> => RunStepDetailsToolCallsFunctionObject)]).annotate({ "identifier": "RunStepDetailsToolCall" })
export type AssistantTool = AssistantToolsCode | AssistantToolsFileSearch | AssistantToolsFunction
export const AssistantTool = Schema.Union([Schema.suspend((): Schema.Codec<AssistantToolsCode> => AssistantToolsCode), Schema.suspend((): Schema.Codec<AssistantToolsFileSearch> => AssistantToolsFileSearch), Schema.suspend((): Schema.Codec<AssistantToolsFunction> => AssistantToolsFunction)]).annotate({ "identifier": "AssistantTool" })
export type FineTuneChatRequestInput = { readonly "messages"?: ReadonlyArray<ChatCompletionRequestSystemMessage | ChatCompletionRequestUserMessage | FineTuneChatCompletionRequestAssistantMessage | ChatCompletionRequestToolMessage | ChatCompletionRequestFunctionMessage>, readonly "tools"?: ReadonlyArray<ChatCompletionTool>, readonly "parallel_tool_calls"?: ParallelToolCalls, readonly "functions"?: ReadonlyArray<ChatCompletionFunctions>, readonly [x: string]: unknown }
export const FineTuneChatRequestInput = Schema.StructWithRest(Schema.Struct({ "messages": Schema.optionalKey(Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionRequestSystemMessage> => ChatCompletionRequestSystemMessage), Schema.suspend((): Schema.Codec<ChatCompletionRequestUserMessage> => ChatCompletionRequestUserMessage), Schema.suspend((): Schema.Codec<FineTuneChatCompletionRequestAssistantMessage> => FineTuneChatCompletionRequestAssistantMessage), Schema.suspend((): Schema.Codec<ChatCompletionRequestToolMessage> => ChatCompletionRequestToolMessage), Schema.suspend((): Schema.Codec<ChatCompletionRequestFunctionMessage> => ChatCompletionRequestFunctionMessage)]))), "tools": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionTool> => ChatCompletionTool)).annotate({ "description": "A list of tools the model may generate JSON inputs for." })), "parallel_tool_calls": Schema.optionalKey(Schema.suspend((): Schema.Codec<ParallelToolCalls> => ParallelToolCalls)), "functions": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionFunctions> => ChatCompletionFunctions)).annotate({ "description": "A list of functions the model may generate JSON inputs for." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The per-line training example of a fine-tuning input file for chat models using the supervised method.\\nInput messages may contain text or image content only. Audio and file input messages\\nare not currently supported for fine-tuning.\\n", "identifier": "FineTuneChatRequestInput" })
export type FineTunePreferenceRequestInput = { readonly "input"?: { readonly "messages"?: ReadonlyArray<ChatCompletionRequestSystemMessage | ChatCompletionRequestUserMessage | FineTuneChatCompletionRequestAssistantMessage | ChatCompletionRequestToolMessage | ChatCompletionRequestFunctionMessage>, readonly "tools"?: ReadonlyArray<ChatCompletionTool>, readonly "parallel_tool_calls"?: ParallelToolCalls, readonly [x: string]: unknown }, readonly "preferred_output"?: ReadonlyArray<ChatCompletionRequestAssistantMessage>, readonly "non_preferred_output"?: ReadonlyArray<ChatCompletionRequestAssistantMessage>, readonly [x: string]: unknown }
export const FineTunePreferenceRequestInput = Schema.StructWithRest(Schema.Struct({ "input": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "messages": Schema.optionalKey(Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionRequestSystemMessage> => ChatCompletionRequestSystemMessage), Schema.suspend((): Schema.Codec<ChatCompletionRequestUserMessage> => ChatCompletionRequestUserMessage), Schema.suspend((): Schema.Codec<FineTuneChatCompletionRequestAssistantMessage> => FineTuneChatCompletionRequestAssistantMessage), Schema.suspend((): Schema.Codec<ChatCompletionRequestToolMessage> => ChatCompletionRequestToolMessage), Schema.suspend((): Schema.Codec<ChatCompletionRequestFunctionMessage> => ChatCompletionRequestFunctionMessage)]))), "tools": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionTool> => ChatCompletionTool)).annotate({ "description": "A list of tools the model may generate JSON inputs for." })), "parallel_tool_calls": Schema.optionalKey(Schema.suspend((): Schema.Codec<ParallelToolCalls> => ParallelToolCalls)) }), [Schema.Record(Schema.String, Schema.Unknown)])), "preferred_output": Schema.optionalKey(Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionRequestAssistantMessage> => ChatCompletionRequestAssistantMessage)])).annotate({ "description": "The preferred completion message for the output." })), "non_preferred_output": Schema.optionalKey(Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionRequestAssistantMessage> => ChatCompletionRequestAssistantMessage)])).annotate({ "description": "The non-preferred completion message for the output." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The per-line training example of a fine-tuning input file for chat models using the dpo method.\\nInput messages may contain text or image content only. Audio and file input messages\\nare not currently supported for fine-tuning.\\n", "identifier": "FineTunePreferenceRequestInput" })
export type FineTuneReinforcementRequestInput = { readonly "messages": ReadonlyArray<ChatCompletionRequestDeveloperMessage | ChatCompletionRequestUserMessage | FineTuneChatCompletionRequestAssistantMessage | ChatCompletionRequestToolMessage>, readonly "tools"?: ReadonlyArray<ChatCompletionTool>, readonly [x: string]: unknown }
export const FineTuneReinforcementRequestInput = Schema.StructWithRest(Schema.Struct({ "messages": Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionRequestDeveloperMessage> => ChatCompletionRequestDeveloperMessage), Schema.suspend((): Schema.Codec<ChatCompletionRequestUserMessage> => ChatCompletionRequestUserMessage), Schema.suspend((): Schema.Codec<FineTuneChatCompletionRequestAssistantMessage> => FineTuneChatCompletionRequestAssistantMessage), Schema.suspend((): Schema.Codec<ChatCompletionRequestToolMessage> => ChatCompletionRequestToolMessage)])), "tools": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionTool> => ChatCompletionTool)).annotate({ "description": "A list of tools the model may generate JSON inputs for." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Per-line training example for reinforcement fine-tuning. Note that \`messages\` and \`tools\` are the only reserved keywords.\\nAny other arbitrary key-value data can be included on training datapoints and will be available to reference during grading under the \`{{ item.XXX }}\` template variable.\\nInput messages may contain text or image content only. Audio and file input messages\\nare not currently supported for fine-tuning.\\n", "identifier": "FineTuneReinforcementRequestInput" })
export type MessageContent = MessageContentImageFileObject | MessageContentImageUrlObject | MessageContentTextObject | MessageContentRefusalObject
export const MessageContent = Schema.Union([Schema.suspend((): Schema.Codec<MessageContentImageFileObject> => MessageContentImageFileObject), Schema.suspend((): Schema.Codec<MessageContentImageUrlObject> => MessageContentImageUrlObject), Schema.suspend((): Schema.Codec<MessageContentTextObject> => MessageContentTextObject), Schema.suspend((): Schema.Codec<MessageContentRefusalObject> => MessageContentRefusalObject)]).annotate({ "identifier": "MessageContent" })
export type MessageContentDelta = MessageDeltaContentImageFileObject | MessageDeltaContentTextObject | MessageDeltaContentRefusalObject | MessageDeltaContentImageUrlObject
export const MessageContentDelta = Schema.Union([Schema.suspend((): Schema.Codec<MessageDeltaContentImageFileObject> => MessageDeltaContentImageFileObject), Schema.suspend((): Schema.Codec<MessageDeltaContentTextObject> => MessageDeltaContentTextObject), Schema.suspend((): Schema.Codec<MessageDeltaContentRefusalObject> => MessageDeltaContentRefusalObject), Schema.suspend((): Schema.Codec<MessageDeltaContentImageUrlObject> => MessageDeltaContentImageUrlObject)]).annotate({ "identifier": "MessageContentDelta" })
export type EvalList = { readonly "object": "list", readonly "data": ReadonlyArray<Eval>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const EvalList = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of this object. It is always set to \\"list\\".\\n", "default": "list" }), "data": Schema.Array(Schema.suspend((): Schema.Codec<Eval> => Eval)).annotate({ "description": "An array of eval objects.\\n" }), "first_id": Schema.String.annotate({ "description": "The identifier of the first eval in the data array." }), "last_id": Schema.String.annotate({ "description": "The identifier of the last eval in the data array." }), "has_more": Schema.Boolean.annotate({ "description": "Indicates whether there are more evals available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalList", "description": "An object representing a list of evals.\\n", "identifier": "EvalList" })
export type RealtimeBetaClientEventConversationItemCreate = { readonly "event_id"?: string, readonly "type": "conversation.item.create", readonly "previous_item_id"?: string, readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeBetaClientEventConversationItemCreate = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("conversation.item.create").annotate({ "description": "The event type, must be \`conversation.item.create\`." }), "previous_item_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the preceding item after which the new item will be inserted. \\nIf not set, the new item will be appended to the end of the conversation.\\nIf set to \`root\`, the new item will be added to the beginning of the conversation.\\nIf set to an existing ID, it allows an item to be inserted mid-conversation. If the\\nID cannot be found, an error will be returned and the item will not be added.\\n" })), "item": RealtimeConversationItem }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Add a new Item to the Conversation's context, including messages, function \\ncalls, and function call responses. This event can be used both to populate a \\n\\"history\\" of the conversation and to add new items mid-stream, but has the \\ncurrent limitation that it cannot populate assistant audio messages.\\n\\nIf successful, the server will respond with a \`conversation.item.created\` \\nevent, otherwise an \`error\` event will be sent.\\n", "identifier": "RealtimeBetaClientEventConversationItemCreate" })
export type RealtimeBetaResponse = { readonly "id"?: string, readonly "object"?: "realtime.response", readonly "status"?: "completed" | "cancelled" | "failed" | "incomplete" | "in_progress", readonly "status_details"?: { readonly "type"?: "completed" | "cancelled" | "incomplete" | "failed", readonly "reason"?: "turn_detected" | "client_cancelled" | "max_output_tokens" | "content_filter", readonly "error"?: { readonly "type"?: string, readonly "code"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "output"?: ReadonlyArray<RealtimeConversationItem>, readonly "metadata"?: Metadata, readonly "usage"?: { readonly "total_tokens"?: number, readonly "input_tokens"?: number, readonly "output_tokens"?: number, readonly "input_token_details"?: { readonly "cached_tokens"?: number, readonly "text_tokens"?: number, readonly "image_tokens"?: number, readonly "audio_tokens"?: number, readonly "cached_tokens_details"?: { readonly "text_tokens"?: number, readonly "image_tokens"?: number, readonly "audio_tokens"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "output_token_details"?: { readonly "text_tokens"?: number, readonly "audio_tokens"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "conversation_id"?: string, readonly "voice"?: VoiceIdsShared, readonly "modalities"?: ReadonlyArray<"text" | "audio">, readonly "output_audio_format"?: "pcm16" | "g711_ulaw" | "g711_alaw", readonly "temperature"?: number, readonly "max_output_tokens"?: number | "inf", readonly [x: string]: unknown }
export const RealtimeBetaResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the response." })), "object": Schema.optionalKey(Schema.Literal("realtime.response").annotate({ "description": "The object type, must be \`realtime.response\`." })), "status": Schema.optionalKey(Schema.Literals(["completed", "cancelled", "failed", "incomplete", "in_progress"]).annotate({ "description": "The final status of the response (\`completed\`, \`cancelled\`, \`failed\`, or \\n\`incomplete\`, \`in_progress\`).\\n" })), "status_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["completed", "cancelled", "incomplete", "failed"]).annotate({ "description": "The type of error that caused the response to fail, corresponding \\nwith the \`status\` field (\`completed\`, \`cancelled\`, \`incomplete\`, \\n\`failed\`).\\n" })), "reason": Schema.optionalKey(Schema.Literals(["turn_detected", "client_cancelled", "max_output_tokens", "content_filter"]).annotate({ "description": "The reason the Response did not complete. For a \`cancelled\` Response, \\none of \`turn_detected\` (the server VAD detected a new start of speech) \\nor \`client_cancelled\` (the client sent a cancel event). For an \\n\`incomplete\` Response, one of \`max_output_tokens\` or \`content_filter\` \\n(the server-side safety filter activated and cut off the response).\\n" })), "error": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of error." })), "code": Schema.optionalKey(Schema.String.annotate({ "description": "Error code, if any." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A description of the error that caused the response to fail, \\npopulated when the \`status\` is \`failed\`.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Additional details about the status." })), "output": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem)).annotate({ "description": "The list of output items generated by the response." })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "usage": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "total_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The total number of tokens in the Response including input and output \\ntext and audio tokens.\\n" }).check(Schema.isInt())), "input_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of input tokens used in the Response, including text and \\naudio tokens.\\n" }).check(Schema.isInt())), "output_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of output tokens sent in the Response, including text and \\naudio tokens.\\n" }).check(Schema.isInt())), "input_token_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "cached_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of cached tokens used as input for the Response." }).check(Schema.isInt())), "text_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of text tokens used as input for the Response." }).check(Schema.isInt())), "image_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of image tokens used as input for the Response." }).check(Schema.isInt())), "audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of audio tokens used as input for the Response." }).check(Schema.isInt())), "cached_tokens_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "text_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of cached text tokens used as input for the Response." }).check(Schema.isInt())), "image_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of cached image tokens used as input for the Response." }).check(Schema.isInt())), "audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of cached audio tokens used as input for the Response." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details about the cached tokens used as input for the Response." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details about the input tokens used in the Response." })), "output_token_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "text_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of text tokens used in the Response." }).check(Schema.isInt())), "audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of audio tokens used in the Response." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details about the output tokens used in the Response." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Usage statistics for the Response, this will correspond to billing. A \\nRealtime API session will maintain a conversation context and append new \\nItems to the Conversation, thus output from previous turns (text and \\naudio tokens) will become the input for later turns.\\n" })), "conversation_id": Schema.optionalKey(Schema.String.annotate({ "description": "Which conversation the response is added to, determined by the \`conversation\`\\nfield in the \`response.create\` event. If \`auto\`, the response will be added to\\nthe default conversation and the value of \`conversation_id\` will be an id like\\n\`conv_1234\`. If \`none\`, the response will not be added to any conversation and\\nthe value of \`conversation_id\` will be \`null\`. If responses are being triggered\\nby server VAD, the response will be added to the default conversation, thus\\nthe \`conversation_id\` will be an id like \`conv_1234\`.\\n" })), "voice": Schema.optionalKey(Schema.suspend((): Schema.Codec<VoiceIdsShared> => VoiceIdsShared).annotate({ "description": "The voice the model used to respond.\\nCurrent voice options are \`alloy\`, \`ash\`, \`ballad\`, \`coral\`, \`echo\`, \`sage\`,\\n\`shimmer\`, and \`verse\`.\\n" })), "modalities": Schema.optionalKey(Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "The set of modalities the model used to respond. If there are multiple modalities,\\nthe model will pick one, for example if \`modalities\` is \`[\\"text\\", \\"audio\\"]\`, the model\\ncould be responding in either text or audio.\\n" })), "output_audio_format": Schema.optionalKey(Schema.Literals(["pcm16", "g711_ulaw", "g711_alaw"]).annotate({ "description": "The format of output audio. Options are \`pcm16\`, \`g711_ulaw\`, or \`g711_alaw\`.\\n" })), "temperature": Schema.optionalKey(Schema.Number.annotate({ "description": "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\\n" }).check(Schema.isFinite())), "max_output_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")]).annotate({ "description": "Maximum number of output tokens for a single assistant response,\\ninclusive of tool calls, that was used in this response.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The response resource.", "identifier": "RealtimeBetaResponse" })
export type RealtimeBetaServerEventConversationItemCreated = { readonly "event_id": string, readonly "type": "conversation.item.created", readonly "previous_item_id"?: string | null, readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeBetaServerEventConversationItemCreated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.created").annotate({ "description": "The event type, must be \`conversation.item.created\`." }), "previous_item_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the preceding item in the Conversation context, allows the\\nclient to understand the order of the conversation. Can be \`null\` if the\\nitem has no predecessor.\\n" }), Schema.Null])), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a conversation item is created. There are several scenarios that produce this event:\\n  - The server is generating a Response, which if successful will produce\\n    either one or two Items, which will be of type \`message\`\\n    (role \`assistant\`) or type \`function_call\`.\\n  - The input audio buffer has been committed, either by the client or the\\n    server (in \`server_vad\` mode). The server will take the content of the\\n    input audio buffer and add it to a new user message Item.\\n  - The client has sent a \`conversation.item.create\` event to add a new Item\\n    to the Conversation.\\n", "identifier": "RealtimeBetaServerEventConversationItemCreated" })
export type RealtimeBetaServerEventConversationItemRetrieved = { readonly "event_id": string, readonly "type": "conversation.item.retrieved", readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeBetaServerEventConversationItemRetrieved = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.retrieved").annotate({ "description": "The event type, must be \`conversation.item.retrieved\`." }), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a conversation item is retrieved with \`conversation.item.retrieve\`.\\n", "identifier": "RealtimeBetaServerEventConversationItemRetrieved" })
export type RealtimeBetaServerEventResponseOutputItemAdded = { readonly "event_id": string, readonly "type": "response.output_item.added", readonly "response_id": string, readonly "output_index": number, readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseOutputItemAdded = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_item.added").annotate({ "description": "The event type, must be \`response.output_item.added\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the Response to which the item belongs." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the Response." }).check(Schema.isInt()), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a new Item is created during Response generation.", "identifier": "RealtimeBetaServerEventResponseOutputItemAdded" })
export type RealtimeBetaServerEventResponseOutputItemDone = { readonly "event_id": string, readonly "type": "response.output_item.done", readonly "response_id": string, readonly "output_index": number, readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseOutputItemDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_item.done").annotate({ "description": "The event type, must be \`response.output_item.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the Response to which the item belongs." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the Response." }).check(Schema.isInt()), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an Item is done streaming. Also emitted when a Response is \\ninterrupted, incomplete, or cancelled.\\n", "identifier": "RealtimeBetaServerEventResponseOutputItemDone" })
export type RealtimeClientEventConversationItemCreate = { readonly "event_id"?: string, readonly "type": "conversation.item.create", readonly "previous_item_id"?: string, readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeClientEventConversationItemCreate = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("conversation.item.create").annotate({ "description": "The event type, must be \`conversation.item.create\`." }), "previous_item_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the preceding item after which the new item will be inserted. \\nIf not set, the new item will be appended to the end of the conversation.\\nIf set to \`root\`, the new item will be added to the beginning of the conversation.\\nIf set to an existing ID, it allows an item to be inserted mid-conversation. If the\\nID cannot be found, an error will be returned and the item will not be added.\\n" })), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Add a new Item to the Conversation's context, including messages, function \\ncalls, and function call responses. This event can be used both to populate a \\n\\"history\\" of the conversation and to add new items mid-stream, but has the \\ncurrent limitation that it cannot populate assistant audio messages.\\n\\nIf successful, the server will respond with a \`conversation.item.created\` \\nevent, otherwise an \`error\` event will be sent.\\n", "identifier": "RealtimeClientEventConversationItemCreate" })
export type RealtimeResponse = { readonly "id"?: string, readonly "object"?: "realtime.response", readonly "status"?: "completed" | "cancelled" | "failed" | "incomplete" | "in_progress", readonly "status_details"?: { readonly "type"?: "completed" | "cancelled" | "incomplete" | "failed", readonly "reason"?: "turn_detected" | "client_cancelled" | "max_output_tokens" | "content_filter", readonly "error"?: { readonly "type"?: string, readonly "code"?: string, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "output"?: ReadonlyArray<RealtimeConversationItem>, readonly "metadata"?: Metadata, readonly "audio"?: { readonly "output"?: { readonly "format"?: RealtimeAudioFormats, readonly "voice"?: VoiceIdsShared, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "usage"?: { readonly "total_tokens"?: number, readonly "input_tokens"?: number, readonly "output_tokens"?: number, readonly "input_token_details"?: { readonly "cached_tokens"?: number, readonly "text_tokens"?: number, readonly "image_tokens"?: number, readonly "audio_tokens"?: number, readonly "cached_tokens_details"?: { readonly "text_tokens"?: number, readonly "image_tokens"?: number, readonly "audio_tokens"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "output_token_details"?: { readonly "text_tokens"?: number, readonly "audio_tokens"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "conversation_id"?: string, readonly "output_modalities"?: ReadonlyArray<"text" | "audio">, readonly "max_output_tokens"?: number | "inf", readonly [x: string]: unknown }
export const RealtimeResponse = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the response, will look like \`resp_1234\`." })), "object": Schema.optionalKey(Schema.Literal("realtime.response").annotate({ "description": "The object type, must be \`realtime.response\`." })), "status": Schema.optionalKey(Schema.Literals(["completed", "cancelled", "failed", "incomplete", "in_progress"]).annotate({ "description": "The final status of the response (\`completed\`, \`cancelled\`, \`failed\`, or \\n\`incomplete\`, \`in_progress\`).\\n" })), "status_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literals(["completed", "cancelled", "incomplete", "failed"]).annotate({ "description": "The type of error that caused the response to fail, corresponding \\nwith the \`status\` field (\`completed\`, \`cancelled\`, \`incomplete\`, \\n\`failed\`).\\n" })), "reason": Schema.optionalKey(Schema.Literals(["turn_detected", "client_cancelled", "max_output_tokens", "content_filter"]).annotate({ "description": "The reason the Response did not complete. For a \`cancelled\` Response,  one of \`turn_detected\` (the server VAD detected a new start of speech)  or \`client_cancelled\` (the client sent a cancel event). For an  \`incomplete\` Response, one of \`max_output_tokens\` or \`content_filter\`  (the server-side safety filter activated and cut off the response).\\n" })), "error": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "The type of error." })), "code": Schema.optionalKey(Schema.String.annotate({ "description": "Error code, if any." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A description of the error that caused the response to fail, \\npopulated when the \`status\` is \`failed\`.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Additional details about the status." })), "output": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem)).annotate({ "description": "The list of output items generated by the response." })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "audio": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "output": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeAudioFormats> => RealtimeAudioFormats).annotate({ "description": "The format of the output audio." })), "voice": Schema.optionalKey(Schema.suspend((): Schema.Codec<VoiceIdsShared> => VoiceIdsShared).annotate({ "description": "The voice the model uses to respond. Voice cannot be changed during the\\nsession once the model has responded with audio at least once. Current\\nvoice options are \`alloy\`, \`ash\`, \`ballad\`, \`coral\`, \`echo\`, \`sage\`,\\n\`shimmer\`, \`verse\`, \`marin\`, and \`cedar\`. We recommend \`marin\` and \`cedar\` for\\nbest quality.\\n", "default": "alloy" })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for audio output." })), "usage": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "total_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The total number of tokens in the Response including input and output \\ntext and audio tokens.\\n" }).check(Schema.isInt())), "input_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of input tokens used in the Response, including text and \\naudio tokens.\\n" }).check(Schema.isInt())), "output_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of output tokens sent in the Response, including text and \\naudio tokens.\\n" }).check(Schema.isInt())), "input_token_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "cached_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of cached tokens used as input for the Response." }).check(Schema.isInt())), "text_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of text tokens used as input for the Response." }).check(Schema.isInt())), "image_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of image tokens used as input for the Response." }).check(Schema.isInt())), "audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of audio tokens used as input for the Response." }).check(Schema.isInt())), "cached_tokens_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "text_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of cached text tokens used as input for the Response." }).check(Schema.isInt())), "image_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of cached image tokens used as input for the Response." }).check(Schema.isInt())), "audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of cached audio tokens used as input for the Response." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details about the cached tokens used as input for the Response." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details about the input tokens used in the Response. Cached tokens are tokens from previous turns in the conversation that are included as context for the current response. Cached tokens here are counted as a subset of input tokens, meaning input tokens will include cached and uncached tokens." })), "output_token_details": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "text_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of text tokens used in the Response." }).check(Schema.isInt())), "audio_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of audio tokens used in the Response." }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Details about the output tokens used in the Response." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Usage statistics for the Response, this will correspond to billing. A \\nRealtime API session will maintain a conversation context and append new \\nItems to the Conversation, thus output from previous turns (text and \\naudio tokens) will become the input for later turns.\\n" })), "conversation_id": Schema.optionalKey(Schema.String.annotate({ "description": "Which conversation the response is added to, determined by the \`conversation\`\\nfield in the \`response.create\` event. If \`auto\`, the response will be added to\\nthe default conversation and the value of \`conversation_id\` will be an id like\\n\`conv_1234\`. If \`none\`, the response will not be added to any conversation and\\nthe value of \`conversation_id\` will be \`null\`. If responses are being triggered\\nautomatically by VAD the response will be added to the default conversation\\n" })), "output_modalities": Schema.optionalKey(Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "The set of modalities the model used to respond, currently the only possible values are\\n\`[\\\\\\"audio\\\\\\"]\`, \`[\\\\\\"text\\\\\\"]\`. Audio output always include a text transcript. Setting the\\noutput to mode \`text\` will disable audio output from the model.\\n" })), "max_output_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")]).annotate({ "description": "Maximum number of output tokens for a single assistant response,\\ninclusive of tool calls, that was used in this response.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The response resource.", "identifier": "RealtimeResponse" })
export type RealtimeServerEventConversationItemAdded = { readonly "event_id": string, readonly "type": "conversation.item.added", readonly "previous_item_id"?: string | null, readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeServerEventConversationItemAdded = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.added").annotate({ "description": "The event type, must be \`conversation.item.added\`." }), "previous_item_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the item that precedes this one, if any. This is used to\\nmaintain ordering when items are inserted.\\n" }), Schema.Null])), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Sent by the server when an Item is added to the default Conversation. This can happen in several cases:\\n- When the client sends a \`conversation.item.create\` event.\\n- When the input audio buffer is committed. In this case the item will be a user message containing the audio from the buffer.\\n- When the model is generating a Response. In this case the \`conversation.item.added\` event will be sent when the model starts generating a specific Item, and thus it will not yet have any content (and \`status\` will be \`in_progress\`).\\n\\nThe event will include the full content of the Item (except when model is generating a Response) except for audio data, which can be retrieved separately with a \`conversation.item.retrieve\` event if necessary.\\n", "identifier": "RealtimeServerEventConversationItemAdded" })
export type RealtimeServerEventConversationItemCreated = { readonly "event_id": string, readonly "type": "conversation.item.created", readonly "previous_item_id"?: string | null, readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeServerEventConversationItemCreated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.created").annotate({ "description": "The event type, must be \`conversation.item.created\`." }), "previous_item_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the preceding item in the Conversation context, allows the\\nclient to understand the order of the conversation. Can be \`null\` if the\\nitem has no predecessor.\\n" }), Schema.Null])), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a conversation item is created. There are several scenarios that produce this event:\\n  - The server is generating a Response, which if successful will produce\\n    either one or two Items, which will be of type \`message\`\\n    (role \`assistant\`) or type \`function_call\`.\\n  - The input audio buffer has been committed, either by the client or the\\n    server (in \`server_vad\` mode). The server will take the content of the\\n    input audio buffer and add it to a new user message Item.\\n  - The client has sent a \`conversation.item.create\` event to add a new Item\\n    to the Conversation.\\n", "identifier": "RealtimeServerEventConversationItemCreated" })
export type RealtimeServerEventConversationItemDone = { readonly "event_id": string, readonly "type": "conversation.item.done", readonly "previous_item_id"?: string | null, readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeServerEventConversationItemDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.done").annotate({ "description": "The event type, must be \`conversation.item.done\`." }), "previous_item_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The ID of the item that precedes this one, if any. This is used to\\nmaintain ordering when items are inserted.\\n" }), Schema.Null])), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a conversation item is finalized.\\n\\nThe event will include the full content of the Item except for audio data, which can be retrieved separately with a \`conversation.item.retrieve\` event if needed.\\n", "identifier": "RealtimeServerEventConversationItemDone" })
export type RealtimeServerEventConversationItemRetrieved = { readonly "event_id": string, readonly "type": "conversation.item.retrieved", readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeServerEventConversationItemRetrieved = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("conversation.item.retrieved").annotate({ "description": "The event type, must be \`conversation.item.retrieved\`." }), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a conversation item is retrieved with \`conversation.item.retrieve\`. This is provided as a way to fetch the server's representation of an item, for example to get access to the post-processed audio data after noise cancellation and VAD. It includes the full content of the Item, including audio data.\\n", "identifier": "RealtimeServerEventConversationItemRetrieved" })
export type RealtimeServerEventResponseOutputItemAdded = { readonly "event_id": string, readonly "type": "response.output_item.added", readonly "response_id": string, readonly "output_index": number, readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeServerEventResponseOutputItemAdded = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_item.added").annotate({ "description": "The event type, must be \`response.output_item.added\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the Response to which the item belongs." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the Response." }).check(Schema.isInt()), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a new Item is created during Response generation.", "identifier": "RealtimeServerEventResponseOutputItemAdded" })
export type RealtimeServerEventResponseOutputItemDone = { readonly "event_id": string, readonly "type": "response.output_item.done", readonly "response_id": string, readonly "output_index": number, readonly "item": RealtimeConversationItem, readonly [x: string]: unknown }
export const RealtimeServerEventResponseOutputItemDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.output_item.done").annotate({ "description": "The event type, must be \`response.output_item.done\`." }), "response_id": Schema.String.annotate({ "description": "The ID of the Response to which the item belongs." }), "output_index": Schema.Number.annotate({ "description": "The index of the output item in the Response." }).check(Schema.isInt()), "item": Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when an Item is done streaming. Also emitted when a Response is \\ninterrupted, incomplete, or cancelled.\\n", "identifier": "RealtimeServerEventResponseOutputItemDone" })
export type CreateRunRequest = { readonly "assistant_id": string, readonly "model"?: string | AssistantSupportedModels | null, readonly "reasoning_effort"?: ReasoningEffort, readonly "instructions"?: string | null, readonly "additional_instructions"?: string | null, readonly "additional_messages"?: ReadonlyArray<unknown> | null, readonly "tools"?: ReadonlyArray<unknown> | null, readonly "metadata"?: Metadata, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "stream"?: boolean | null, readonly "max_prompt_tokens"?: number | null, readonly "max_completion_tokens"?: number | null, readonly "truncation_strategy"?: unknown | null, readonly "tool_choice"?: never, readonly "parallel_tool_calls"?: ParallelToolCalls, readonly "response_format"?: AssistantsApiResponseFormatOption | null }
export const CreateRunRequest = Schema.Struct({ "assistant_id": Schema.String.annotate({ "description": "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run." }), "model": Schema.optionalKey(Schema.Union([Schema.Union([Schema.String, Schema.suspend((): Schema.Codec<AssistantSupportedModels> => AssistantSupportedModels)]).annotate({ "description": "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used." }), Schema.Null])), "reasoning_effort": Schema.optionalKey(Schema.suspend((): Schema.Codec<ReasoningEffort> => ReasoningEffort)), "instructions": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis." })), "additional_instructions": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions." })), "additional_messages": Schema.optionalKey(Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({ "description": "Adds additional messages to the thread before creating the run." })), "tools": Schema.optionalKey(Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({ "description": "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis." })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\\n", "default": 1 })), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\\n\\nWe generally recommend altering this or temperature but not both.\\n", "default": 1 })), "stream": Schema.optionalKey(Schema.Union([Schema.Boolean, Schema.Null]).annotate({ "description": "If \`true\`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a \`data: [DONE]\` message.\\n" })), "max_prompt_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status \`incomplete\`. See \`incomplete_details\` for more info.\\n" })), "max_completion_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status \`incomplete\`. See \`incomplete_details\` for more info.\\n" })), "truncation_strategy": Schema.optionalKey(Schema.Union([Schema.Unknown, Schema.Null])), "tool_choice": Schema.optionalKey(Schema.Never), "parallel_tool_calls": Schema.optionalKey(Schema.suspend((): Schema.Codec<ParallelToolCalls> => ParallelToolCalls)), "response_format": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<AssistantsApiResponseFormatOption> => AssistantsApiResponseFormatOption), Schema.Null])) }).annotate({ "identifier": "CreateRunRequest" })
export type CreateThreadAndRunRequest = { readonly "assistant_id": string, readonly "thread"?: CreateThreadRequest, readonly "model"?: string | "gpt-5" | "gpt-5-mini" | "gpt-5-nano" | "gpt-5-2025-08-07" | "gpt-5-mini-2025-08-07" | "gpt-5-nano-2025-08-07" | "gpt-4.1" | "gpt-4.1-mini" | "gpt-4.1-nano" | "gpt-4.1-2025-04-14" | "gpt-4.1-mini-2025-04-14" | "gpt-4.1-nano-2025-04-14" | "gpt-4o" | "gpt-4o-2024-11-20" | "gpt-4o-2024-08-06" | "gpt-4o-2024-05-13" | "gpt-4o-mini" | "gpt-4o-mini-2024-07-18" | "gpt-4.5-preview" | "gpt-4.5-preview-2025-02-27" | "gpt-4-turbo" | "gpt-4-turbo-2024-04-09" | "gpt-4-0125-preview" | "gpt-4-turbo-preview" | "gpt-4-1106-preview" | "gpt-4-vision-preview" | "gpt-4" | "gpt-4-0314" | "gpt-4-0613" | "gpt-4-32k" | "gpt-4-32k-0314" | "gpt-4-32k-0613" | "gpt-3.5-turbo" | "gpt-3.5-turbo-16k" | "gpt-3.5-turbo-0613" | "gpt-3.5-turbo-1106" | "gpt-3.5-turbo-0125" | "gpt-3.5-turbo-16k-0613" | null, readonly "instructions"?: string | null, readonly "tools"?: ReadonlyArray<unknown> | null, readonly "tool_resources"?: { readonly [x: string]: unknown } | null, readonly "metadata"?: Metadata, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "stream"?: boolean | null, readonly "max_prompt_tokens"?: number | null, readonly "max_completion_tokens"?: number | null, readonly "truncation_strategy"?: never, readonly "tool_choice"?: never, readonly "parallel_tool_calls"?: ParallelToolCalls, readonly "response_format"?: AssistantsApiResponseFormatOption | null }
export const CreateThreadAndRunRequest = Schema.Struct({ "assistant_id": Schema.String.annotate({ "description": "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run." }), "thread": Schema.optionalKey(CreateThreadRequest), "model": Schema.optionalKey(Schema.Union([Schema.Union([Schema.String, Schema.Literals(["gpt-5", "gpt-5-mini", "gpt-5-nano", "gpt-5-2025-08-07", "gpt-5-mini-2025-08-07", "gpt-5-nano-2025-08-07", "gpt-4.1", "gpt-4.1-mini", "gpt-4.1-nano", "gpt-4.1-2025-04-14", "gpt-4.1-mini-2025-04-14", "gpt-4.1-nano-2025-04-14", "gpt-4o", "gpt-4o-2024-11-20", "gpt-4o-2024-08-06", "gpt-4o-2024-05-13", "gpt-4o-mini", "gpt-4o-mini-2024-07-18", "gpt-4.5-preview", "gpt-4.5-preview-2025-02-27", "gpt-4-turbo", "gpt-4-turbo-2024-04-09", "gpt-4-0125-preview", "gpt-4-turbo-preview", "gpt-4-1106-preview", "gpt-4-vision-preview", "gpt-4", "gpt-4-0314", "gpt-4-0613", "gpt-4-32k", "gpt-4-32k-0314", "gpt-4-32k-0613", "gpt-3.5-turbo", "gpt-3.5-turbo-16k", "gpt-3.5-turbo-0613", "gpt-3.5-turbo-1106", "gpt-3.5-turbo-0125", "gpt-3.5-turbo-16k-0613"])]).annotate({ "description": "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used." }), Schema.Null])), "instructions": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis." })), "tools": Schema.optionalKey(Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({ "description": "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis." })), "tool_resources": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the \`code_interpreter\` tool requires a list of file IDs, while the \`file_search\` tool requires a list of vector store IDs.\\n" })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\\n", "default": 1 })), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\\n\\nWe generally recommend altering this or temperature but not both.\\n", "default": 1 })), "stream": Schema.optionalKey(Schema.Union([Schema.Boolean, Schema.Null]).annotate({ "description": "If \`true\`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a \`data: [DONE]\` message.\\n" })), "max_prompt_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status \`incomplete\`. See \`incomplete_details\` for more info.\\n" })), "max_completion_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status \`incomplete\`. See \`incomplete_details\` for more info.\\n" })), "truncation_strategy": Schema.optionalKey(Schema.Never), "tool_choice": Schema.optionalKey(Schema.Never), "parallel_tool_calls": Schema.optionalKey(Schema.suspend((): Schema.Codec<ParallelToolCalls> => ParallelToolCalls)), "response_format": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<AssistantsApiResponseFormatOption> => AssistantsApiResponseFormatOption), Schema.Null])) }).annotate({ "identifier": "CreateThreadAndRunRequest" })
export type CreateThreadAndRunRequestWithoutStream = { readonly "assistant_id": string, readonly "thread"?: CreateThreadRequest, readonly "model"?: string | "gpt-5" | "gpt-5-mini" | "gpt-5-nano" | "gpt-5-2025-08-07" | "gpt-5-mini-2025-08-07" | "gpt-5-nano-2025-08-07" | "gpt-4.1" | "gpt-4.1-mini" | "gpt-4.1-nano" | "gpt-4.1-2025-04-14" | "gpt-4.1-mini-2025-04-14" | "gpt-4.1-nano-2025-04-14" | "gpt-4o" | "gpt-4o-2024-11-20" | "gpt-4o-2024-08-06" | "gpt-4o-2024-05-13" | "gpt-4o-mini" | "gpt-4o-mini-2024-07-18" | "gpt-4.5-preview" | "gpt-4.5-preview-2025-02-27" | "gpt-4-turbo" | "gpt-4-turbo-2024-04-09" | "gpt-4-0125-preview" | "gpt-4-turbo-preview" | "gpt-4-1106-preview" | "gpt-4-vision-preview" | "gpt-4" | "gpt-4-0314" | "gpt-4-0613" | "gpt-4-32k" | "gpt-4-32k-0314" | "gpt-4-32k-0613" | "gpt-3.5-turbo" | "gpt-3.5-turbo-16k" | "gpt-3.5-turbo-0613" | "gpt-3.5-turbo-1106" | "gpt-3.5-turbo-0125" | "gpt-3.5-turbo-16k-0613" | null, readonly "instructions"?: string | null, readonly "tools"?: ReadonlyArray<unknown> | null, readonly "tool_resources"?: { readonly [x: string]: unknown } | null, readonly "metadata"?: Metadata, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "max_prompt_tokens"?: number | null, readonly "max_completion_tokens"?: number | null, readonly "truncation_strategy"?: never, readonly "tool_choice"?: never, readonly "parallel_tool_calls"?: ParallelToolCalls, readonly "response_format"?: AssistantsApiResponseFormatOption | null }
export const CreateThreadAndRunRequestWithoutStream = Schema.Struct({ "assistant_id": Schema.String.annotate({ "description": "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run." }), "thread": Schema.optionalKey(Schema.suspend((): Schema.Codec<CreateThreadRequest> => CreateThreadRequest)), "model": Schema.optionalKey(Schema.Union([Schema.Union([Schema.String, Schema.Literals(["gpt-5", "gpt-5-mini", "gpt-5-nano", "gpt-5-2025-08-07", "gpt-5-mini-2025-08-07", "gpt-5-nano-2025-08-07", "gpt-4.1", "gpt-4.1-mini", "gpt-4.1-nano", "gpt-4.1-2025-04-14", "gpt-4.1-mini-2025-04-14", "gpt-4.1-nano-2025-04-14", "gpt-4o", "gpt-4o-2024-11-20", "gpt-4o-2024-08-06", "gpt-4o-2024-05-13", "gpt-4o-mini", "gpt-4o-mini-2024-07-18", "gpt-4.5-preview", "gpt-4.5-preview-2025-02-27", "gpt-4-turbo", "gpt-4-turbo-2024-04-09", "gpt-4-0125-preview", "gpt-4-turbo-preview", "gpt-4-1106-preview", "gpt-4-vision-preview", "gpt-4", "gpt-4-0314", "gpt-4-0613", "gpt-4-32k", "gpt-4-32k-0314", "gpt-4-32k-0613", "gpt-3.5-turbo", "gpt-3.5-turbo-16k", "gpt-3.5-turbo-0613", "gpt-3.5-turbo-1106", "gpt-3.5-turbo-0125", "gpt-3.5-turbo-16k-0613"])]).annotate({ "description": "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used." }), Schema.Null])), "instructions": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis." })), "tools": Schema.optionalKey(Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({ "description": "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis." })), "tool_resources": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the \`code_interpreter\` tool requires a list of file IDs, while the \`file_search\` tool requires a list of vector store IDs.\\n" })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\\n", "default": 1 })), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\\n\\nWe generally recommend altering this or temperature but not both.\\n", "default": 1 })), "max_prompt_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status \`incomplete\`. See \`incomplete_details\` for more info.\\n" })), "max_completion_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status \`incomplete\`. See \`incomplete_details\` for more info.\\n" })), "truncation_strategy": Schema.optionalKey(Schema.Never), "tool_choice": Schema.optionalKey(Schema.Never), "parallel_tool_calls": Schema.optionalKey(Schema.suspend((): Schema.Codec<ParallelToolCalls> => ParallelToolCalls)), "response_format": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<AssistantsApiResponseFormatOption> => AssistantsApiResponseFormatOption), Schema.Null])) }).annotate({ "identifier": "CreateThreadAndRunRequestWithoutStream" })
export type CreateRunRequestWithoutStream = { readonly "assistant_id": string, readonly "model"?: string | AssistantSupportedModels | null, readonly "reasoning_effort"?: ReasoningEffort, readonly "instructions"?: string | null, readonly "additional_instructions"?: string | null, readonly "additional_messages"?: ReadonlyArray<unknown> | null, readonly "tools"?: ReadonlyArray<unknown> | null, readonly "metadata"?: Metadata, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "max_prompt_tokens"?: number | null, readonly "max_completion_tokens"?: number | null, readonly "truncation_strategy"?: never, readonly "tool_choice"?: never, readonly "parallel_tool_calls"?: ParallelToolCalls, readonly "response_format"?: AssistantsApiResponseFormatOption | null }
export const CreateRunRequestWithoutStream = Schema.Struct({ "assistant_id": Schema.String.annotate({ "description": "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run." }), "model": Schema.optionalKey(Schema.Union([Schema.Union([Schema.String, Schema.suspend((): Schema.Codec<AssistantSupportedModels> => AssistantSupportedModels)]).annotate({ "description": "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used." }), Schema.Null])), "reasoning_effort": Schema.optionalKey(Schema.suspend((): Schema.Codec<ReasoningEffort> => ReasoningEffort)), "instructions": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis." })), "additional_instructions": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions." })), "additional_messages": Schema.optionalKey(Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({ "description": "Adds additional messages to the thread before creating the run." })), "tools": Schema.optionalKey(Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({ "description": "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis." })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\\n", "default": 1 })), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\\n\\nWe generally recommend altering this or temperature but not both.\\n", "default": 1 })), "max_prompt_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status \`incomplete\`. See \`incomplete_details\` for more info.\\n" })), "max_completion_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status \`incomplete\`. See \`incomplete_details\` for more info.\\n" })), "truncation_strategy": Schema.optionalKey(Schema.Never), "tool_choice": Schema.optionalKey(Schema.Never), "parallel_tool_calls": Schema.optionalKey(Schema.suspend((): Schema.Codec<ParallelToolCalls> => ParallelToolCalls)), "response_format": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<AssistantsApiResponseFormatOption> => AssistantsApiResponseFormatOption), Schema.Null])) }).annotate({ "identifier": "CreateRunRequestWithoutStream" })
export type ResponseTextParam = { readonly "format"?: TextResponseFormatConfiguration, readonly "verbosity"?: Verbosity, readonly [x: string]: unknown }
export const ResponseTextParam = Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<TextResponseFormatConfiguration> => TextResponseFormatConfiguration)), "verbosity": Schema.optionalKey(Schema.suspend((): Schema.Codec<Verbosity> => Verbosity)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration options for a text response from the model. Can be plain\\ntext or structured JSON data. Learn more:\\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\\n", "identifier": "ResponseTextParam" })
export type RunStepDeltaStepDetailsToolCallsObject = { readonly "type": "tool_calls", readonly "tool_calls"?: ReadonlyArray<RunStepDeltaStepDetailsToolCall>, readonly [x: string]: unknown }
export const RunStepDeltaStepDetailsToolCallsObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("tool_calls").annotate({ "description": "Always \`tool_calls\`." }), "tool_calls": Schema.optionalKey(Schema.Array(RunStepDeltaStepDetailsToolCall).annotate({ "description": "An array of tool calls the run step was involved in. These can be associated with one of three types of tools: \`code_interpreter\`, \`file_search\`, or \`function\`.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tool calls", "description": "Details of the tool call.", "identifier": "RunStepDeltaStepDetailsToolCallsObject" })
export type CreateVectorStoreFileRequest = { readonly "file_id": string, readonly "chunking_strategy"?: ChunkingStrategyRequestParam, readonly "attributes"?: VectorStoreFileAttributes }
export const CreateVectorStoreFileRequest = Schema.Struct({ "file_id": Schema.String.annotate({ "description": "A [File](https://platform.openai.com/docs/api-reference/files) ID that the vector store should use. Useful for tools like \`file_search\` that can access files." }), "chunking_strategy": Schema.optionalKey(Schema.suspend((): Schema.Codec<ChunkingStrategyRequestParam> => ChunkingStrategyRequestParam)), "attributes": Schema.optionalKey(Schema.suspend((): Schema.Codec<VectorStoreFileAttributes> => VectorStoreFileAttributes)) }).annotate({ "identifier": "CreateVectorStoreFileRequest" })
export type CreateVectorStoreRequest = { readonly "file_ids"?: ReadonlyArray<string>, readonly "name"?: string, readonly "description"?: string, readonly "expires_after"?: VectorStoreExpirationAfter, readonly "chunking_strategy"?: ChunkingStrategyRequestParam, readonly "metadata"?: Metadata }
export const CreateVectorStoreRequest = Schema.Struct({ "file_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like \`file_search\` that can access files." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the vector store." })), "description": Schema.optionalKey(Schema.String.annotate({ "description": "A description for the vector store. Can be used to describe the vector store's purpose." })), "expires_after": Schema.optionalKey(VectorStoreExpirationAfter), "chunking_strategy": Schema.optionalKey(Schema.suspend((): Schema.Codec<ChunkingStrategyRequestParam> => ChunkingStrategyRequestParam)), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)) }).annotate({ "identifier": "CreateVectorStoreRequest" })
export type VectorStoreFileObject = { readonly "id": string, readonly "object": "vector_store.file", readonly "usage_bytes": number, readonly "created_at": number, readonly "vector_store_id": string, readonly "status": "in_progress" | "completed" | "cancelled" | "failed", readonly "last_error": { readonly "code": "server_error" | "unsupported_file" | "invalid_file", readonly "message": string, readonly [x: string]: unknown } | null, readonly "chunking_strategy"?: ChunkingStrategyResponse, readonly "attributes"?: VectorStoreFileAttributes, readonly [x: string]: unknown }
export const VectorStoreFileObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }), "object": Schema.Literal("vector_store.file").annotate({ "description": "The object type, which is always \`vector_store.file\`." }), "usage_bytes": Schema.Number.annotate({ "description": "The total vector store usage in bytes. Note that this may be different from the original file size." }).check(Schema.isInt()), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the vector store file was created." }).check(Schema.isInt()), "vector_store_id": Schema.String.annotate({ "description": "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to." }), "status": Schema.Literals(["in_progress", "completed", "cancelled", "failed"]).annotate({ "description": "The status of the vector store file, which can be either \`in_progress\`, \`completed\`, \`cancelled\`, or \`failed\`. The status \`completed\` indicates that the vector store file is ready for use." }), "last_error": Schema.Union([Schema.StructWithRest(Schema.Struct({ "code": Schema.Literals(["server_error", "unsupported_file", "invalid_file"]).annotate({ "description": "One of \`server_error\`, \`unsupported_file\`, or \`invalid_file\`." }), "message": Schema.String.annotate({ "description": "A human-readable description of the error." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The last error associated with this vector store file. Will be \`null\` if there are no errors." }), Schema.Null]), "chunking_strategy": Schema.optionalKey(ChunkingStrategyResponse), "attributes": Schema.optionalKey(Schema.suspend((): Schema.Codec<VectorStoreFileAttributes> => VectorStoreFileAttributes)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Vector store files", "description": "A list of files attached to a vector store.", "identifier": "VectorStoreFileObject" })
export type EvalItemContent = EvalItemContentItem | EvalItemContentArray
export const EvalItemContent = Schema.Union([EvalItemContentItem, EvalItemContentArray]).annotate({ "title": "Eval content", "description": "Inputs to the model - can contain template strings. Supports text, output text, input images, and input audio, either as a single item or an array of items.\\n", "identifier": "EvalItemContent" })
export type OutputContent = OutputTextContent | RefusalContent | ReasoningTextContent
export const OutputContent = Schema.Union([OutputTextContent, RefusalContent, ReasoningTextContent]).annotate({ "identifier": "OutputContent" })
export type OutputMessageContent = OutputTextContent | RefusalContent
export const OutputMessageContent = Schema.Union([Schema.suspend((): Schema.Codec<OutputTextContent> => OutputTextContent), Schema.suspend((): Schema.Codec<RefusalContent> => RefusalContent)]).annotate({ "identifier": "OutputMessageContent" })
export type Message = { readonly "type": "message", readonly "id": string, readonly "status": MessageStatus, readonly "role": MessageRole, readonly "content": ReadonlyArray<InputTextContent | OutputTextContent | TextContent | SummaryTextContent | ReasoningTextContent | RefusalContent | InputImageContent | ComputerScreenshotContent | InputFileContent>, readonly [x: string]: unknown }
export const Message = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("message").annotate({ "description": "The type of the message. Always set to \`message\`.", "default": "message" }), "id": Schema.String.annotate({ "description": "The unique ID of the message." }), "status": Schema.suspend((): Schema.Codec<MessageStatus> => MessageStatus).annotate({ "description": "The status of item. One of \`in_progress\`, \`completed\`, or \`incomplete\`. Populated when items are returned via API." }), "role": Schema.suspend((): Schema.Codec<MessageRole> => MessageRole).annotate({ "description": "The role of the message. One of \`unknown\`, \`user\`, \`assistant\`, \`system\`, \`critic\`, \`discriminator\`, \`developer\`, or \`tool\`." }), "content": Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<InputTextContent> => InputTextContent), Schema.suspend((): Schema.Codec<OutputTextContent> => OutputTextContent), Schema.suspend((): Schema.Codec<TextContent> => TextContent), Schema.suspend((): Schema.Codec<SummaryTextContent> => SummaryTextContent), Schema.suspend((): Schema.Codec<ReasoningTextContent> => ReasoningTextContent), Schema.suspend((): Schema.Codec<RefusalContent> => RefusalContent), Schema.suspend((): Schema.Codec<InputImageContent> => InputImageContent), Schema.suspend((): Schema.Codec<ComputerScreenshotContent> => ComputerScreenshotContent), Schema.suspend((): Schema.Codec<InputFileContent> => InputFileContent)])).annotate({ "description": "The content of the message" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Message", "description": "A message to or from the model.", "identifier": "Message" })
export type CustomToolCallOutput = { readonly "type": "custom_tool_call_output", readonly "id"?: string, readonly "call_id": string, readonly "output": string | ReadonlyArray<FunctionAndCustomToolCallOutput>, readonly [x: string]: unknown }
export const CustomToolCallOutput = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("custom_tool_call_output").annotate({ "description": "The type of the custom tool call output. Always \`custom_tool_call_output\`.\\n" }), "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the custom tool call output in the OpenAI platform.\\n" })), "call_id": Schema.String.annotate({ "description": "The call ID, used to map this custom tool call output to a custom tool call.\\n" }), "output": Schema.Union([Schema.String.annotate({ "title": "string output", "description": "A string of the output of the custom tool call.\\n" }), Schema.Array(FunctionAndCustomToolCallOutput).annotate({ "title": "output content list", "description": "Text, image, or file output of the custom tool call.\\n" })]).annotate({ "description": "The output from the custom tool call generated by your code.\\nCan be a string or an list of output content.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Custom tool call output", "description": "The output of a custom tool call from your code, being sent back to the model.\\n", "identifier": "CustomToolCallOutput" })
export type FunctionToolCallOutput = { readonly "id"?: string, readonly "type": "function_call_output", readonly "call_id": string, readonly "output": string | ReadonlyArray<FunctionAndCustomToolCallOutput>, readonly "status"?: "in_progress" | "completed" | "incomplete", readonly [x: string]: unknown }
export const FunctionToolCallOutput = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "The unique ID of the function tool call output. Populated when this item\\nis returned via API.\\n" })), "type": Schema.Literal("function_call_output").annotate({ "description": "The type of the function tool call output. Always \`function_call_output\`.\\n" }), "call_id": Schema.String.annotate({ "description": "The unique ID of the function tool call generated by the model.\\n" }), "output": Schema.Union([Schema.String.annotate({ "title": "string output", "description": "A string of the output of the function call.\\n" }), Schema.Array(Schema.suspend((): Schema.Codec<FunctionAndCustomToolCallOutput> => FunctionAndCustomToolCallOutput)).annotate({ "title": "output content list", "description": "Text, image, or file output of the function call.\\n" })]).annotate({ "description": "The output from the function call generated by your code.\\nCan be a string or an list of output content.\\n" }), "status": Schema.optionalKey(Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "description": "The status of the item. One of \`in_progress\`, \`completed\`, or\\n\`incomplete\`. Populated when items are returned via API.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Function tool call output", "description": "The output of a function tool call.\\n", "identifier": "FunctionToolCallOutput" })
export type InputMessageContentList = ReadonlyArray<InputContent>
export const InputMessageContentList = Schema.Array(Schema.suspend((): Schema.Codec<InputContent> => InputContent)).annotate({ "title": "Input item content list", "description": "A list of one or many input items to the model, containing different content \\ntypes.\\n", "identifier": "InputMessageContentList" })
export type Prompt = { readonly "id": string, readonly "version"?: string | null, readonly "variables"?: ResponsePromptVariables, readonly [x: string]: unknown } | null
export const Prompt = Schema.Union([Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique identifier of the prompt template to use." }), "version": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Optional version of the prompt template." }), Schema.Null])), "variables": Schema.optionalKey(ResponsePromptVariables) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Reference to a prompt template and its variables.\\n[Learn more](https://platform.openai.com/docs/guides/text?api-mode=responses#reusable-prompts).\\n" }), Schema.Null]).annotate({ "identifier": "Prompt" })
export type ComputerToolCall = { readonly "type": "computer_call", readonly "id": string, readonly "call_id": string, readonly "action": ComputerAction, readonly "pending_safety_checks": ReadonlyArray<ComputerCallSafetyCheckParam>, readonly "status": "in_progress" | "completed" | "incomplete", readonly [x: string]: unknown }
export const ComputerToolCall = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("computer_call").annotate({ "description": "The type of the computer call. Always \`computer_call\`.", "default": "computer_call" }), "id": Schema.String.annotate({ "description": "The unique ID of the computer call." }), "call_id": Schema.String.annotate({ "description": "An identifier used when responding to the tool call with output.\\n" }), "action": Schema.suspend((): Schema.Codec<ComputerAction> => ComputerAction), "pending_safety_checks": Schema.Array(ComputerCallSafetyCheckParam).annotate({ "description": "The pending safety checks for the computer call.\\n" }), "status": Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "description": "The status of the item. One of \`in_progress\`, \`completed\`, or\\n\`incomplete\`. Populated when items are returned via API.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Computer tool call", "description": "A tool call to a computer use tool. See the\\n[computer use guide](https://platform.openai.com/docs/guides/tools-computer-use) for more information.\\n", "identifier": "ComputerToolCall" })
export type FunctionShellCallOutputItemParam = { readonly "id"?: string | null, readonly "call_id": string, readonly "type": "shell_call_output", readonly "output": ReadonlyArray<FunctionShellCallOutputContentParam>, readonly "max_output_length"?: number | null, readonly [x: string]: unknown }
export const FunctionShellCallOutputItemParam = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The unique ID of the shell tool call output. Populated when this item is returned via API." }), Schema.Null])), "call_id": Schema.String.annotate({ "description": "The unique ID of the shell tool call generated by the model." }), "type": Schema.Literal("shell_call_output").annotate({ "description": "The type of the item. Always \`shell_call_output\`.", "default": "shell_call_output" }), "output": Schema.Array(Schema.suspend((): Schema.Codec<FunctionShellCallOutputContentParam> => FunctionShellCallOutputContentParam)).annotate({ "description": "Captured chunks of stdout and stderr output, along with their associated outcomes." }), "max_output_length": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "The maximum number of UTF-8 characters captured for this shell call's combined output." }).check(Schema.isInt()), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Shell tool call output", "description": "The streamed output items emitted by a shell tool call.", "identifier": "FunctionShellCallOutputItemParam" })
export type AssistantMessageItem = { readonly "id": string, readonly "object": "chatkit.thread_item", readonly "created_at": number, readonly "thread_id": string, readonly "type": "chatkit.assistant_message", readonly "content": ReadonlyArray<ResponseOutputText>, readonly [x: string]: unknown }
export const AssistantMessageItem = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "Identifier of the thread item." }), "object": Schema.Literal("chatkit.thread_item").annotate({ "description": "Type discriminator that is always \`chatkit.thread_item\`.", "default": "chatkit.thread_item" }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) for when the item was created." }).check(Schema.isInt()), "thread_id": Schema.String.annotate({ "description": "Identifier of the parent thread." }), "type": Schema.Literal("chatkit.assistant_message").annotate({ "description": "Type discriminator that is always \`chatkit.assistant_message\`.", "default": "chatkit.assistant_message" }), "content": Schema.Array(Schema.suspend((): Schema.Codec<ResponseOutputText> => ResponseOutputText)).annotate({ "description": "Ordered assistant response segments." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Assistant message", "description": "Assistant-authored message within a thread.", "identifier": "AssistantMessageItem" })
export type VectorStoreSearchRequest = { readonly "query": string | ReadonlyArray<string>, readonly "rewrite_query"?: boolean, readonly "max_num_results"?: number, readonly "filters"?: ComparisonFilter | CompoundFilter, readonly "ranking_options"?: { readonly "ranker"?: "none" | "auto" | "default-2024-11-15", readonly "score_threshold"?: number } }
export const VectorStoreSearchRequest = Schema.Struct({ "query": Schema.Union([Schema.String, Schema.Array(Schema.String.annotate({ "description": "A list of queries to search for." }))]).annotate({ "description": "A query string for a search" }), "rewrite_query": Schema.optionalKey(Schema.Boolean.annotate({ "description": "Whether to rewrite the natural language query for vector search.", "default": false })), "max_num_results": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum number of results to return. This number should be between 1 and 50 inclusive.", "default": 10 }).check(Schema.isInt())), "filters": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ComparisonFilter> => ComparisonFilter), Schema.suspend((): Schema.Codec<CompoundFilter> => CompoundFilter)]).annotate({ "description": "A filter to apply based on file attributes." })), "ranking_options": Schema.optionalKey(Schema.Struct({ "ranker": Schema.optionalKey(Schema.Literals(["none", "auto", "default-2024-11-15"]).annotate({ "description": "Enable re-ranking; set to \`none\` to disable, which can help reduce latency.", "default": "auto" })), "score_threshold": Schema.optionalKey(Schema.Number.annotate({ "default": 0 }).check(Schema.isFinite())) }).annotate({ "description": "Ranking options for search." })) }).annotate({ "identifier": "VectorStoreSearchRequest" })
export type Filters = ComparisonFilter | CompoundFilter
export const Filters = Schema.Union([Schema.suspend((): Schema.Codec<ComparisonFilter> => ComparisonFilter), Schema.suspend((): Schema.Codec<CompoundFilter> => CompoundFilter)]).annotate({ "identifier": "Filters" })
export type ModelIds = ModelIdsShared | ModelIdsResponses
export const ModelIds = Schema.Union([Schema.suspend((): Schema.Codec<ModelIdsShared> => ModelIdsShared), ModelIdsResponses]).annotate({ "identifier": "ModelIds" })
export type ModelIdsCompaction = ModelIdsResponses | string | null
export const ModelIdsCompaction = Schema.Union([Schema.suspend((): Schema.Codec<ModelIdsResponses> => ModelIdsResponses), Schema.String, Schema.Null]).annotate({ "description": "Model ID used to generate the response, like \`gpt-5\` or \`o3\`. OpenAI offers a wide range of models with different capabilities, performance characteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models) to browse and compare available models.", "identifier": "ModelIdsCompaction" })
export type ListAuditLogsResponse = { readonly "object": "list", readonly "data": ReadonlyArray<AuditLog>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListAuditLogsResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list"), "data": Schema.Array(Schema.suspend((): Schema.Codec<AuditLog> => AuditLog)), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListAuditLogsResponse" })
export type ChatCompletionList = { readonly "object": "list", readonly "data": ReadonlyArray<CreateChatCompletionResponse>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ChatCompletionList = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of this object. It is always set to \\"list\\".\\n", "default": "list" }), "data": Schema.Array(CreateChatCompletionResponse).annotate({ "description": "An array of chat completion objects.\\n" }), "first_id": Schema.String.annotate({ "description": "The identifier of the first chat completion in the data array." }), "last_id": Schema.String.annotate({ "description": "The identifier of the last chat completion in the data array." }), "has_more": Schema.Boolean.annotate({ "description": "Indicates whether there are more Chat Completions available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ChatCompletionList", "description": "An object representing a list of Chat Completions.\\n", "identifier": "ChatCompletionList" })
export type CreateChatCompletionRequest = { readonly "messages": ReadonlyArray<ChatCompletionRequestMessage>, readonly "model": unknown, readonly "modalities"?: ResponseModalities, readonly "verbosity"?: Verbosity, readonly "reasoning_effort"?: ReasoningEffort, readonly "max_completion_tokens"?: number | null, readonly "frequency_penalty"?: number | null, readonly "presence_penalty"?: number | null, readonly "web_search_options"?: { readonly "user_location"?: { readonly [x: string]: unknown } | null, readonly "search_context_size"?: WebSearchContextSize, readonly [x: string]: unknown }, readonly "top_logprobs"?: number | null, readonly "response_format"?: ResponseFormatText | ResponseFormatJsonSchema | ResponseFormatJsonObject, readonly "audio"?: { readonly [x: string]: unknown } | null, readonly "store"?: boolean | null, readonly "stream"?: boolean | null, readonly "stop"?: StopConfiguration, readonly "logit_bias"?: { readonly [x: string]: unknown } | null, readonly "logprobs"?: boolean | null, readonly "max_tokens"?: number | null, readonly "n"?: number | null, readonly "prediction"?: PredictionContent | null, readonly "seed"?: number | null, readonly "stream_options"?: ChatCompletionStreamOptions, readonly "tools"?: ReadonlyArray<ChatCompletionTool | CustomToolChatCompletions>, readonly "tool_choice"?: ChatCompletionToolChoiceOption, readonly "parallel_tool_calls"?: ParallelToolCalls, readonly "function_call"?: "none" | "auto" | ChatCompletionFunctionCallOption, readonly "functions"?: ReadonlyArray<ChatCompletionFunctions>, readonly [x: string]: unknown }
export const CreateChatCompletionRequest = Schema.StructWithRest(Schema.Struct({ "messages": Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionRequestMessage> => ChatCompletionRequestMessage)).annotate({ "description": "A list of messages comprising the conversation so far. Depending on the\\n[model](https://platform.openai.com/docs/models) you use, different message types (modalities) are\\nsupported, like [text](https://platform.openai.com/docs/guides/text-generation),\\n[images](https://platform.openai.com/docs/guides/vision), and [audio](https://platform.openai.com/docs/guides/audio).\\n" }), "model": Schema.Unknown.annotate({ "description": "Model ID used to generate the response, like \`gpt-4o\` or \`o3\`. OpenAI\\noffers a wide range of models with different capabilities, performance\\ncharacteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models)\\nto browse and compare available models.\\n" }), "modalities": Schema.optionalKey(ResponseModalities), "verbosity": Schema.optionalKey(Verbosity), "reasoning_effort": Schema.optionalKey(Schema.suspend((): Schema.Codec<ReasoningEffort> => ReasoningEffort)), "max_completion_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).\\n" })), "frequency_penalty": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on\\ntheir existing frequency in the text so far, decreasing the model's\\nlikelihood to repeat the same line verbatim.\\n", "default": 0 })), "presence_penalty": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on\\nwhether they appear in the text so far, increasing the model's likelihood\\nto talk about new topics.\\n", "default": 0 })), "web_search_options": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "user_location": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "Approximate location parameters for the search.\\n" })), "search_context_size": Schema.optionalKey(WebSearchContextSize) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Web search", "description": "This tool searches the web for relevant results to use in a response.\\nLearn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).\\n" })), "top_logprobs": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "An integer between 0 and 20 specifying the number of most likely tokens to\\nreturn at each token position, each with an associated log probability.\\n\`logprobs\` must be set to \`true\` if this parameter is used.\\n" })), "response_format": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ResponseFormatText> => ResponseFormatText), Schema.suspend((): Schema.Codec<ResponseFormatJsonSchema> => ResponseFormatJsonSchema), Schema.suspend((): Schema.Codec<ResponseFormatJsonObject> => ResponseFormatJsonObject)]).annotate({ "description": "An object specifying the format that the model must output.\\n\\nSetting to \`{ \\"type\\": \\"json_schema\\", \\"json_schema\\": {...} }\` enables\\nStructured Outputs which ensures the model will match your supplied JSON\\nschema. Learn more in the [Structured Outputs\\nguide](https://platform.openai.com/docs/guides/structured-outputs).\\n\\nSetting to \`{ \\"type\\": \\"json_object\\" }\` enables the older JSON mode, which\\nensures the message the model generates is valid JSON. Using \`json_schema\`\\nis preferred for models that support it.\\n" })), "audio": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "Parameters for audio output. Required when audio output is requested with\\n\`modalities: [\\"audio\\"]\`. [Learn more](https://platform.openai.com/docs/guides/audio).\\n" })), "store": Schema.optionalKey(Schema.Union([Schema.Boolean, Schema.Null]).annotate({ "description": "Whether or not to store the output of this chat completion request for\\nuse in our [model distillation](https://platform.openai.com/docs/guides/distillation) or\\n[evals](https://platform.openai.com/docs/guides/evals) products.\\n\\nSupports text and image inputs. Note: image inputs over 8MB will be dropped.\\n", "default": false })), "stream": Schema.optionalKey(Schema.Union([Schema.Boolean, Schema.Null]).annotate({ "description": "If set to true, the model response data will be streamed to the client\\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\\nSee the [Streaming section below](https://platform.openai.com/docs/api-reference/chat/streaming)\\nfor more information, along with the [streaming responses](https://platform.openai.com/docs/guides/streaming-responses)\\nguide for more information on how to handle the streaming events.\\n", "default": false })), "stop": Schema.optionalKey(StopConfiguration), "logit_bias": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "Modify the likelihood of specified tokens appearing in the completion.\\n\\nAccepts a JSON object that maps tokens (specified by their token ID in the\\ntokenizer) to an associated bias value from -100 to 100. Mathematically,\\nthe bias is added to the logits generated by the model prior to sampling.\\nThe exact effect will vary per model, but values between -1 and 1 should\\ndecrease or increase likelihood of selection; values like -100 or 100\\nshould result in a ban or exclusive selection of the relevant token.\\n", "default": null })), "logprobs": Schema.optionalKey(Schema.Union([Schema.Boolean, Schema.Null]).annotate({ "description": "Whether to return log probabilities of the output tokens or not. If true,\\nreturns the log probabilities of each output token returned in the\\n\`content\` of \`message\`.\\n", "default": false })), "max_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of [tokens](/tokenizer) that can be generated in the\\nchat completion. This value can be used to control\\n[costs](https://openai.com/api/pricing/) for text generated via API.\\n\\nThis value is now deprecated in favor of \`max_completion_tokens\`, and is\\nnot compatible with [o-series models](https://platform.openai.com/docs/guides/reasoning).\\n" })), "n": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep \`n\` as \`1\` to minimize costs.", "default": 1 })), "prediction": Schema.optionalKey(Schema.Union([Schema.Union([PredictionContent]).annotate({ "description": "Configuration for a [Predicted Output](https://platform.openai.com/docs/guides/predicted-outputs),\\nwhich can greatly improve response times when large parts of the model\\nresponse are known ahead of time. This is most common when you are\\nregenerating a file with only minor changes to most of the content.\\n" }), Schema.Null])), "seed": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "This feature is in Beta.\\nIf specified, our system will make a best effort to sample deterministically, such that repeated requests with the same \`seed\` and parameters should return the same result.\\nDeterminism is not guaranteed, and you should refer to the \`system_fingerprint\` response parameter to monitor changes in the backend.\\n" })), "stream_options": Schema.optionalKey(Schema.suspend((): Schema.Codec<ChatCompletionStreamOptions> => ChatCompletionStreamOptions)), "tools": Schema.optionalKey(Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<ChatCompletionTool> => ChatCompletionTool), CustomToolChatCompletions])).annotate({ "description": "A list of tools the model may call. You can provide either\\n[custom tools](https://platform.openai.com/docs/guides/function-calling#custom-tools) or\\n[function tools](https://platform.openai.com/docs/guides/function-calling).\\n" })), "tool_choice": Schema.optionalKey(Schema.suspend((): Schema.Codec<ChatCompletionToolChoiceOption> => ChatCompletionToolChoiceOption)), "parallel_tool_calls": Schema.optionalKey(ParallelToolCalls), "function_call": Schema.optionalKey(Schema.Union([Schema.Literals(["none", "auto"]).annotate({ "title": "function call mode", "description": "\`none\` means the model will not call a function and instead generates a message. \`auto\` means the model can pick between generating a message or calling a function.\\n" }), Schema.suspend((): Schema.Codec<ChatCompletionFunctionCallOption> => ChatCompletionFunctionCallOption)]).annotate({ "description": "Deprecated in favor of \`tool_choice\`.\\n\\nControls which (if any) function is called by the model.\\n\\n\`none\` means the model will not call a function and instead generates a\\nmessage.\\n\\n\`auto\` means the model can pick between generating a message or calling a\\nfunction.\\n\\nSpecifying a particular function via \`{\\"name\\": \\"my_function\\"}\` forces the\\nmodel to call that function.\\n\\n\`none\` is the default when no functions are present. \`auto\` is the default\\nif functions are present.\\n" })), "functions": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionFunctions> => ChatCompletionFunctions)).annotate({ "description": "Deprecated in favor of \`tools\`.\\n\\nA list of functions the model may generate JSON inputs for.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateChatCompletionRequest" })
export type RunStepDetailsToolCallsObject = { readonly "type": "tool_calls", readonly "tool_calls": ReadonlyArray<RunStepDetailsToolCall>, readonly [x: string]: unknown }
export const RunStepDetailsToolCallsObject = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("tool_calls").annotate({ "description": "Always \`tool_calls\`." }), "tool_calls": Schema.Array(RunStepDetailsToolCall).annotate({ "description": "An array of tool calls the run step was involved in. These can be associated with one of three types of tools: \`code_interpreter\`, \`file_search\`, or \`function\`.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tool calls", "description": "Details of the tool call.", "identifier": "RunStepDetailsToolCallsObject" })
export type AssistantObject = { readonly "id": string, readonly "object": "assistant", readonly "created_at": number, readonly "name": string | null, readonly "description": string | null, readonly "model": string, readonly "instructions": string | null, readonly "tools": ReadonlyArray<AssistantTool>, readonly "tool_resources"?: { readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly "file_search"?: { readonly "vector_store_ids"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly [x: string]: unknown } | null, readonly "metadata": Metadata, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "response_format"?: AssistantsApiResponseFormatOption | null, readonly [x: string]: unknown }
export const AssistantObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }), "object": Schema.Literal("assistant").annotate({ "description": "The object type, which is always \`assistant\`." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the assistant was created." }).check(Schema.isInt()), "name": Schema.Union([Schema.String.annotate({ "description": "The name of the assistant. The maximum length is 256 characters.\\n" }), Schema.Null]), "description": Schema.Union([Schema.String.annotate({ "description": "The description of the assistant. The maximum length is 512 characters.\\n" }), Schema.Null]), "model": Schema.String.annotate({ "description": "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\\n" }), "instructions": Schema.Union([Schema.String.annotate({ "description": "The system instructions that the assistant uses. The maximum length is 256,000 characters.\\n" }), Schema.Null]), "tools": Schema.Array(AssistantTool).annotate({ "description": "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types \`code_interpreter\`, \`file_search\`, or \`function\`.\\n", "default": [] }), "tool_resources": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "code_interpreter": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "file_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the \`code_interpreter\`\` tool. There can be a maximum of 20 files associated with the tool.\\n", "default": [] })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "file_search": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "vector_store_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the \`code_interpreter\` tool requires a list of file IDs, while the \`file_search\` tool requires a list of vector store IDs.\\n" }), Schema.Null])), "metadata": Metadata, "temperature": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\\n", "default": 1 }).check(Schema.isFinite()), Schema.Null])), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\\n\\nWe generally recommend altering this or temperature but not both.\\n", "default": 1 }).check(Schema.isFinite()), Schema.Null])), "response_format": Schema.optionalKey(Schema.Union([AssistantsApiResponseFormatOption, Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Assistant", "description": "Represents an \`assistant\` that can call the model and use tools.", "identifier": "AssistantObject" })
export type CreateAssistantRequest = { readonly "model": string | AssistantSupportedModels, readonly "name"?: string | null, readonly "description"?: string | null, readonly "instructions"?: string | null, readonly "reasoning_effort"?: ReasoningEffort, readonly "tools"?: ReadonlyArray<AssistantTool>, readonly "tool_resources"?: { readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly "file_search"?: { readonly "vector_store_ids": unknown, readonly [x: string]: unknown } | { readonly "vector_stores": unknown, readonly [x: string]: unknown }, readonly [x: string]: unknown } | null, readonly "metadata"?: Metadata, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "response_format"?: AssistantsApiResponseFormatOption | null }
export const CreateAssistantRequest = Schema.Struct({ "model": Schema.Union([Schema.String, Schema.suspend((): Schema.Codec<AssistantSupportedModels> => AssistantSupportedModels)]).annotate({ "description": "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\\n" }), "name": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The name of the assistant. The maximum length is 256 characters.\\n" }), Schema.Null])), "description": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The description of the assistant. The maximum length is 512 characters.\\n" }), Schema.Null])), "instructions": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The system instructions that the assistant uses. The maximum length is 256,000 characters.\\n" }), Schema.Null])), "reasoning_effort": Schema.optionalKey(ReasoningEffort), "tools": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<AssistantTool> => AssistantTool)).annotate({ "description": "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types \`code_interpreter\`, \`file_search\`, or \`function\`.\\n", "default": [] })), "tool_resources": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "code_interpreter": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "file_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the \`code_interpreter\` tool. There can be a maximum of 20 files associated with the tool.\\n", "default": [] })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "file_search": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "vector_store_ids": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)]), Schema.StructWithRest(Schema.Struct({ "vector_stores": Schema.Unknown }), [Schema.Record(Schema.String, Schema.Unknown)])])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the \`code_interpreter\` tool requires a list of file IDs, while the \`file_search\` tool requires a list of vector store IDs.\\n" }), Schema.Null])), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\\n", "default": 1 }).check(Schema.isFinite()), Schema.Null])), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\\n\\nWe generally recommend altering this or temperature but not both.\\n", "default": 1 }).check(Schema.isFinite()), Schema.Null])), "response_format": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<AssistantsApiResponseFormatOption> => AssistantsApiResponseFormatOption), Schema.Null])) }).annotate({ "identifier": "CreateAssistantRequest" })
export type ModifyAssistantRequest = { readonly "model"?: string | AssistantSupportedModels, readonly "reasoning_effort"?: ReasoningEffort, readonly "name"?: string | null, readonly "description"?: string | null, readonly "instructions"?: string | null, readonly "tools"?: ReadonlyArray<AssistantTool>, readonly "tool_resources"?: { readonly "code_interpreter"?: { readonly "file_ids"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly "file_search"?: { readonly "vector_store_ids"?: ReadonlyArray<string>, readonly [x: string]: unknown }, readonly [x: string]: unknown } | null, readonly "metadata"?: Metadata, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "response_format"?: AssistantsApiResponseFormatOption | null }
export const ModifyAssistantRequest = Schema.Struct({ "model": Schema.optionalKey(Schema.Union([Schema.String, Schema.suspend((): Schema.Codec<AssistantSupportedModels> => AssistantSupportedModels)]).annotate({ "description": "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\\n" })), "reasoning_effort": Schema.optionalKey(Schema.suspend((): Schema.Codec<ReasoningEffort> => ReasoningEffort)), "name": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The name of the assistant. The maximum length is 256 characters.\\n" }), Schema.Null])), "description": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The description of the assistant. The maximum length is 512 characters.\\n" }), Schema.Null])), "instructions": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The system instructions that the assistant uses. The maximum length is 256,000 characters.\\n" }), Schema.Null])), "tools": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<AssistantTool> => AssistantTool)).annotate({ "description": "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types \`code_interpreter\`, \`file_search\`, or \`function\`.\\n", "default": [] })), "tool_resources": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "code_interpreter": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "file_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "Overrides the list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the \`code_interpreter\` tool. There can be a maximum of 20 files associated with the tool.\\n", "default": [] })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "file_search": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "vector_store_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "Overrides the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the \`code_interpreter\` tool requires a list of file IDs, while the \`file_search\` tool requires a list of vector store IDs.\\n" }), Schema.Null])), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\\n", "default": 1 }).check(Schema.isFinite()), Schema.Null])), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\\n\\nWe generally recommend altering this or temperature but not both.\\n", "default": 1 }).check(Schema.isFinite()), Schema.Null])), "response_format": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<AssistantsApiResponseFormatOption> => AssistantsApiResponseFormatOption), Schema.Null])) }).annotate({ "identifier": "ModifyAssistantRequest" })
export type RunObject = { readonly "id": string, readonly "object": "thread.run", readonly "created_at": number, readonly "thread_id": string, readonly "assistant_id": string, readonly "status": RunStatus, readonly "required_action": { readonly [x: string]: unknown } | null, readonly "last_error": { readonly [x: string]: unknown } | null, readonly "expires_at": number | null, readonly "started_at": number | null, readonly "cancelled_at": number | null, readonly "failed_at": number | null, readonly "completed_at": number | null, readonly "incomplete_details": { readonly [x: string]: unknown } | null, readonly "model": string, readonly "instructions": string, readonly "tools": ReadonlyArray<AssistantTool>, readonly "metadata": Metadata, readonly "usage": RunCompletionUsage, readonly "temperature"?: number | null, readonly "top_p"?: number | null, readonly "max_prompt_tokens": number | null, readonly "max_completion_tokens": number | null, readonly "truncation_strategy": never, readonly "tool_choice": never, readonly "parallel_tool_calls": ParallelToolCalls, readonly "response_format": AssistantsApiResponseFormatOption | null, readonly [x: string]: unknown }
export const RunObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }), "object": Schema.Literal("thread.run").annotate({ "description": "The object type, which is always \`thread.run\`." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the run was created." }).check(Schema.isInt()), "thread_id": Schema.String.annotate({ "description": "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run." }), "assistant_id": Schema.String.annotate({ "description": "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run." }), "status": RunStatus, "required_action": Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "Details on the action required to continue the run. Will be \`null\` if no action is required." }), "last_error": Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "The last error associated with this run. Will be \`null\` if there are no errors." }), "expires_at": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The Unix timestamp (in seconds) for when the run will expire." }), "started_at": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The Unix timestamp (in seconds) for when the run was started." }), "cancelled_at": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The Unix timestamp (in seconds) for when the run was cancelled." }), "failed_at": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The Unix timestamp (in seconds) for when the run failed." }), "completed_at": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The Unix timestamp (in seconds) for when the run was completed." }), "incomplete_details": Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null]).annotate({ "description": "Details on why the run is incomplete. Will be \`null\` if the run is not incomplete." }), "model": Schema.String.annotate({ "description": "The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run." }), "instructions": Schema.String.annotate({ "description": "The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run." }), "tools": Schema.Array(Schema.suspend((): Schema.Codec<AssistantTool> => AssistantTool)).annotate({ "description": "The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run.", "default": [] }), "metadata": Schema.suspend((): Schema.Codec<Metadata> => Metadata), "usage": Schema.suspend((): Schema.Codec<RunCompletionUsage> => RunCompletionUsage), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "The sampling temperature used for this run. If not set, defaults to 1." })), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isFinite()), Schema.Null]).annotate({ "description": "The nucleus sampling value used for this run. If not set, defaults to 1." })), "max_prompt_tokens": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of prompt tokens specified to have been used over the course of the run.\\n" }), "max_completion_tokens": Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The maximum number of completion tokens specified to have been used over the course of the run.\\n" }), "truncation_strategy": Schema.Never, "tool_choice": Schema.Never, "parallel_tool_calls": Schema.suspend((): Schema.Codec<ParallelToolCalls> => ParallelToolCalls), "response_format": Schema.Union([Schema.suspend((): Schema.Codec<AssistantsApiResponseFormatOption> => AssistantsApiResponseFormatOption), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "A run on a thread", "description": "Represents an execution run on a [thread](https://platform.openai.com/docs/api-reference/threads).", "identifier": "RunObject" })
export type MessageObject = { readonly "id": string, readonly "object": "thread.message", readonly "created_at": number, readonly "thread_id": string, readonly "status": "in_progress" | "incomplete" | "completed", readonly "incomplete_details": { readonly "reason": "content_filter" | "max_tokens" | "run_cancelled" | "run_expired" | "run_failed", readonly [x: string]: unknown } | null, readonly "completed_at": number | null, readonly "incomplete_at": number | null, readonly "role": "user" | "assistant", readonly "content": ReadonlyArray<MessageContent>, readonly "assistant_id": string | null, readonly "run_id": string | null, readonly "attachments": ReadonlyArray<{ readonly "file_id"?: string, readonly "tools"?: ReadonlyArray<AssistantToolsCode | AssistantToolsFileSearchTypeOnly>, readonly [x: string]: unknown }> | null, readonly "metadata": Metadata, readonly [x: string]: unknown }
export const MessageObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier, which can be referenced in API endpoints." }), "object": Schema.Literal("thread.message").annotate({ "description": "The object type, which is always \`thread.message\`." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the message was created." }).check(Schema.isInt()), "thread_id": Schema.String.annotate({ "description": "The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to." }), "status": Schema.Literals(["in_progress", "incomplete", "completed"]).annotate({ "description": "The status of the message, which can be either \`in_progress\`, \`incomplete\`, or \`completed\`." }), "incomplete_details": Schema.Union([Schema.StructWithRest(Schema.Struct({ "reason": Schema.Literals(["content_filter", "max_tokens", "run_cancelled", "run_expired", "run_failed"]).annotate({ "description": "The reason the message is incomplete." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "On an incomplete message, details about why the message is incomplete." }), Schema.Null]), "completed_at": Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the message was completed." }).check(Schema.isInt()), Schema.Null]), "incomplete_at": Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the message was marked as incomplete." }).check(Schema.isInt()), Schema.Null]), "role": Schema.Literals(["user", "assistant"]).annotate({ "description": "The entity that produced the message. One of \`user\` or \`assistant\`." }), "content": Schema.Array(MessageContent).annotate({ "description": "The content of the message in array of text and/or images." }), "assistant_id": Schema.Union([Schema.String.annotate({ "description": "If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message." }), Schema.Null]), "run_id": Schema.Union([Schema.String.annotate({ "description": "The ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the creation of this message. Value is \`null\` when messages are created manually using the create message or create thread endpoints." }), Schema.Null]), "attachments": Schema.Union([Schema.Array(Schema.StructWithRest(Schema.Struct({ "file_id": Schema.optionalKey(Schema.String.annotate({ "description": "The ID of the file to attach to the message." })), "tools": Schema.optionalKey(Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<AssistantToolsCode> => AssistantToolsCode), Schema.suspend((): Schema.Codec<AssistantToolsFileSearchTypeOnly> => AssistantToolsFileSearchTypeOnly)])).annotate({ "description": "The tools to add this file to." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "A list of files attached to the message, and the tools they were added to." }), Schema.Null]), "metadata": Schema.suspend((): Schema.Codec<Metadata> => Metadata) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "The message object", "description": "Represents a message within a [thread](https://platform.openai.com/docs/api-reference/threads).", "identifier": "MessageObject" })
export type MessageDeltaObject = { readonly "id": string, readonly "object": "thread.message.delta", readonly "delta": { readonly "role"?: "user" | "assistant", readonly "content"?: ReadonlyArray<MessageContentDelta>, readonly [x: string]: unknown }, readonly [x: string]: unknown }
export const MessageDeltaObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier of the message, which can be referenced in API endpoints." }), "object": Schema.Literal("thread.message.delta").annotate({ "description": "The object type, which is always \`thread.message.delta\`." }), "delta": Schema.StructWithRest(Schema.Struct({ "role": Schema.optionalKey(Schema.Literals(["user", "assistant"]).annotate({ "description": "The entity that produced the message. One of \`user\` or \`assistant\`." })), "content": Schema.optionalKey(Schema.Array(MessageContentDelta).annotate({ "description": "The content of the message in array of text and/or images." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The delta containing the fields that have changed on the Message." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Message delta object", "description": "Represents a message delta i.e. any changed fields on a message during streaming.\\n", "identifier": "MessageDeltaObject" })
export type RealtimeBetaServerEventResponseCreated = { readonly "event_id": string, readonly "type": "response.created", readonly "response": RealtimeBetaResponse, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseCreated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.created").annotate({ "description": "The event type, must be \`response.created\`." }), "response": Schema.suspend((): Schema.Codec<RealtimeBetaResponse> => RealtimeBetaResponse) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a new Response is created. The first event of response creation,\\nwhere the response is in an initial state of \`in_progress\`.\\n", "identifier": "RealtimeBetaServerEventResponseCreated" })
export type RealtimeBetaServerEventResponseDone = { readonly "event_id": string, readonly "type": "response.done", readonly "response": RealtimeBetaResponse, readonly [x: string]: unknown }
export const RealtimeBetaServerEventResponseDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.done").annotate({ "description": "The event type, must be \`response.done\`." }), "response": Schema.suspend((): Schema.Codec<RealtimeBetaResponse> => RealtimeBetaResponse) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a Response is done streaming. Always emitted, no matter the \\nfinal state. The Response object included in the \`response.done\` event will \\ninclude all output Items in the Response but will omit the raw audio data.\\n", "identifier": "RealtimeBetaServerEventResponseDone" })
export type RealtimeServerEventResponseCreated = { readonly "event_id": string, readonly "type": "response.created", readonly "response": RealtimeResponse, readonly [x: string]: unknown }
export const RealtimeServerEventResponseCreated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.created").annotate({ "description": "The event type, must be \`response.created\`." }), "response": Schema.suspend((): Schema.Codec<RealtimeResponse> => RealtimeResponse) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a new Response is created. The first event of response creation,\\nwhere the response is in an initial state of \`in_progress\`.\\n", "identifier": "RealtimeServerEventResponseCreated" })
export type RealtimeServerEventResponseDone = { readonly "event_id": string, readonly "type": "response.done", readonly "response": RealtimeResponse, readonly [x: string]: unknown }
export const RealtimeServerEventResponseDone = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("response.done").annotate({ "description": "The event type, must be \`response.done\`." }), "response": Schema.suspend((): Schema.Codec<RealtimeResponse> => RealtimeResponse) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a Response is done streaming. Always emitted, no matter the \\nfinal state. The Response object included in the \`response.done\` event will \\ninclude all output Items in the Response but will omit the raw audio data.\\n\\nClients should check the \`status\` field of the Response to determine if it was successful\\n(\`completed\`) or if there was another outcome: \`cancelled\`, \`failed\`, or \`incomplete\`.\\n\\nA response will contain all output items that were generated during the response, excluding\\nany audio content.\\n", "identifier": "RealtimeServerEventResponseDone" })
export type RunStepDeltaObjectDelta = { readonly "step_details"?: RunStepDeltaStepDetailsMessageCreationObject | RunStepDeltaStepDetailsToolCallsObject, readonly [x: string]: unknown }
export const RunStepDeltaObjectDelta = Schema.StructWithRest(Schema.Struct({ "step_details": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<RunStepDeltaStepDetailsMessageCreationObject> => RunStepDeltaStepDetailsMessageCreationObject), Schema.suspend((): Schema.Codec<RunStepDeltaStepDetailsToolCallsObject> => RunStepDeltaStepDetailsToolCallsObject)]).annotate({ "description": "The details of the run step." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The delta containing the fields that have changed on the run step.", "identifier": "RunStepDeltaObjectDelta" })
export type CreateVectorStoreFileBatchRequest = { readonly "file_ids"?: ReadonlyArray<string>, readonly "files"?: ReadonlyArray<CreateVectorStoreFileRequest>, readonly "chunking_strategy"?: ChunkingStrategyRequestParam, readonly "attributes"?: VectorStoreFileAttributes }
export const CreateVectorStoreFileBatchRequest = Schema.Struct({ "file_ids": Schema.optionalKey(Schema.Array(Schema.String).annotate({ "description": "A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like \`file_search\` that can access files.  If \`attributes\` or \`chunking_strategy\` are provided, they will be  applied to all files in the batch. Mutually exclusive with \`files\`." })), "files": Schema.optionalKey(Schema.Array(CreateVectorStoreFileRequest).annotate({ "description": "A list of objects that each include a \`file_id\` plus optional \`attributes\` or \`chunking_strategy\`. Use this when you need to override metadata for specific files. The global \`attributes\` or \`chunking_strategy\` will be ignored and must be specified for each file. Mutually exclusive with \`file_ids\`." })), "chunking_strategy": Schema.optionalKey(Schema.suspend((): Schema.Codec<ChunkingStrategyRequestParam> => ChunkingStrategyRequestParam)), "attributes": Schema.optionalKey(VectorStoreFileAttributes) }).annotate({ "identifier": "CreateVectorStoreFileBatchRequest" })
export type ListVectorStoreFilesResponse = { readonly "object": string, readonly "data": ReadonlyArray<VectorStoreFileObject>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListVectorStoreFilesResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.String, "data": Schema.Array(VectorStoreFileObject), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListVectorStoreFilesResponse" })
export type EvalItem = { readonly "role": "user" | "assistant" | "system" | "developer", readonly "content": EvalItemContent, readonly "type"?: "message", readonly [x: string]: unknown }
export const EvalItem = Schema.StructWithRest(Schema.Struct({ "role": Schema.Literals(["user", "assistant", "system", "developer"]).annotate({ "description": "The role of the message input. One of \`user\`, \`assistant\`, \`system\`, or\\n\`developer\`.\\n" }), "content": EvalItemContent, "type": Schema.optionalKey(Schema.Literal("message").annotate({ "description": "The type of the message input. Always \`message\`.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalItem", "description": "A message input to the model with a role indicating instruction following\\nhierarchy. Instructions given with the \`developer\` or \`system\` role take\\nprecedence over instructions given with the \`user\` role. Messages with the\\n\`assistant\` role are presumed to have been generated by the model in previous\\ninteractions.\\n", "identifier": "EvalItem" })
export type ResponseContentPartAddedEvent = { readonly "type": "response.content_part.added", readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "part": OutputContent, readonly "sequence_number": number, readonly [x: string]: unknown }
export const ResponseContentPartAddedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.content_part.added").annotate({ "description": "The type of the event. Always \`response.content_part.added\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the output item that the content part was added to.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the content part was added to.\\n" }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part that was added.\\n" }).check(Schema.isInt()), "part": Schema.suspend((): Schema.Codec<OutputContent> => OutputContent).annotate({ "description": "The content part that was added.\\n" }), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a new content part is added.", "identifier": "ResponseContentPartAddedEvent" })
export type ResponseContentPartDoneEvent = { readonly "type": "response.content_part.done", readonly "item_id": string, readonly "output_index": number, readonly "content_index": number, readonly "sequence_number": number, readonly "part": OutputContent, readonly [x: string]: unknown }
export const ResponseContentPartDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.content_part.done").annotate({ "description": "The type of the event. Always \`response.content_part.done\`.\\n" }), "item_id": Schema.String.annotate({ "description": "The ID of the output item that the content part was added to.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that the content part was added to.\\n" }).check(Schema.isInt()), "content_index": Schema.Number.annotate({ "description": "The index of the content part that is done.\\n" }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event." }).check(Schema.isInt()), "part": Schema.suspend((): Schema.Codec<OutputContent> => OutputContent).annotate({ "description": "The content part that is done.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a content part is done.", "identifier": "ResponseContentPartDoneEvent" })
export type OutputMessage = { readonly "id": string, readonly "type": "message", readonly "role": "assistant", readonly "content": ReadonlyArray<OutputMessageContent>, readonly "status": "in_progress" | "completed" | "incomplete", readonly [x: string]: unknown }
export const OutputMessage = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique ID of the output message.\\n" }), "type": Schema.Literal("message").annotate({ "description": "The type of the output message. Always \`message\`.\\n" }), "role": Schema.Literal("assistant").annotate({ "description": "The role of the output message. Always \`assistant\`.\\n" }), "content": Schema.Array(OutputMessageContent).annotate({ "description": "The content of the output message.\\n" }), "status": Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "description": "The status of the message input. One of \`in_progress\`, \`completed\`, or\\n\`incomplete\`. Populated when input items are returned via API.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Output message", "description": "An output message from the model.\\n", "identifier": "OutputMessage" })
export type EasyInputMessage = { readonly "role": "user" | "assistant" | "system" | "developer", readonly "content": string | InputMessageContentList, readonly "type"?: "message", readonly [x: string]: unknown }
export const EasyInputMessage = Schema.StructWithRest(Schema.Struct({ "role": Schema.Literals(["user", "assistant", "system", "developer"]).annotate({ "description": "The role of the message input. One of \`user\`, \`assistant\`, \`system\`, or\\n\`developer\`.\\n" }), "content": Schema.Union([Schema.String.annotate({ "title": "Text input", "description": "A text input to the model.\\n" }), InputMessageContentList]).annotate({ "description": "Text, image, or audio input to the model, used to generate a response.\\nCan also contain previous assistant responses.\\n" }), "type": Schema.optionalKey(Schema.Literal("message").annotate({ "description": "The type of the message input. Always \`message\`.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input message", "description": "A message input to the model with a role indicating instruction following\\nhierarchy. Instructions given with the \`developer\` or \`system\` role take\\nprecedence over instructions given with the \`user\` role. Messages with the\\n\`assistant\` role are presumed to have been generated by the model in previous\\ninteractions.\\n", "identifier": "EasyInputMessage" })
export type InputMessage = { readonly "type"?: "message", readonly "role": "user" | "system" | "developer", readonly "status"?: "in_progress" | "completed" | "incomplete", readonly "content": InputMessageContentList, readonly [x: string]: unknown }
export const InputMessage = Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("message").annotate({ "description": "The type of the message input. Always set to \`message\`.\\n" })), "role": Schema.Literals(["user", "system", "developer"]).annotate({ "description": "The role of the message input. One of \`user\`, \`system\`, or \`developer\`.\\n" }), "status": Schema.optionalKey(Schema.Literals(["in_progress", "completed", "incomplete"]).annotate({ "description": "The status of item. One of \`in_progress\`, \`completed\`, or\\n\`incomplete\`. Populated when items are returned via API.\\n" })), "content": Schema.suspend((): Schema.Codec<InputMessageContentList> => InputMessageContentList) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Input message", "description": "A message input to the model with a role indicating instruction following\\nhierarchy. Instructions given with the \`developer\` or \`system\` role take\\nprecedence over instructions given with the \`user\` role.\\n", "identifier": "InputMessage" })
export type RealtimeBetaResponseCreateParams = { readonly "modalities"?: ReadonlyArray<"text" | "audio">, readonly "instructions"?: string, readonly "voice"?: VoiceIdsShared, readonly "output_audio_format"?: "pcm16" | "g711_ulaw" | "g711_alaw", readonly "tools"?: ReadonlyArray<{ readonly "type"?: "function", readonly "name"?: string, readonly "description"?: string, readonly "parameters"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }>, readonly "tool_choice"?: ToolChoiceOptions | ToolChoiceFunction | ToolChoiceMCP, readonly "temperature"?: number, readonly "max_output_tokens"?: number | "inf", readonly "conversation"?: string | "auto" | "none", readonly "metadata"?: Metadata, readonly "prompt"?: Prompt, readonly "input"?: ReadonlyArray<RealtimeConversationItem>, readonly [x: string]: unknown }
export const RealtimeBetaResponseCreateParams = Schema.StructWithRest(Schema.Struct({ "modalities": Schema.optionalKey(Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "The set of modalities the model can respond with. To disable audio,\\nset this to [\\"text\\"].\\n" })), "instructions": Schema.optionalKey(Schema.String.annotate({ "description": "The default system instructions (i.e. system message) prepended to model \\ncalls. This field allows the client to guide the model on desired \\nresponses. The model can be instructed on response content and format, \\n(e.g. \\"be extremely succinct\\", \\"act friendly\\", \\"here are examples of good \\nresponses\\") and on audio behavior (e.g. \\"talk quickly\\", \\"inject emotion \\ninto your voice\\", \\"laugh frequently\\"). The instructions are not guaranteed \\nto be followed by the model, but they provide guidance to the model on the \\ndesired behavior.\\n\\nNote that the server sets default instructions which will be used if this \\nfield is not set and are visible in the \`session.created\` event at the \\nstart of the session.\\n" })), "voice": Schema.optionalKey(Schema.suspend((): Schema.Codec<VoiceIdsShared> => VoiceIdsShared).annotate({ "description": "The voice the model uses to respond. Voice cannot be changed during the \\nsession once the model has responded with audio at least once. Current \\nvoice options are \`alloy\`, \`ash\`, \`ballad\`, \`coral\`, \`echo\`, \`sage\`,\\n\`shimmer\`, and \`verse\`.\\n" })), "output_audio_format": Schema.optionalKey(Schema.Literals(["pcm16", "g711_ulaw", "g711_alaw"]).annotate({ "description": "The format of output audio. Options are \`pcm16\`, \`g711_ulaw\`, or \`g711_alaw\`.\\n" })), "tools": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("function").annotate({ "description": "The type of the tool, i.e. \`function\`." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function." })), "description": Schema.optionalKey(Schema.String.annotate({ "description": "The description of the function, including guidance on when and how \\nto call it, and guidance about what to tell the user when calling \\n(if anything).\\n" })), "parameters": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "Parameters of the function in JSON Schema." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "Tools (functions) available to the model." })), "tool_choice": Schema.optionalKey(Schema.Union([ToolChoiceOptions, ToolChoiceFunction, ToolChoiceMCP]).annotate({ "description": "How the model chooses tools. Provide one of the string modes or force a specific\\nfunction/MCP tool.\\n", "default": "auto" })), "temperature": Schema.optionalKey(Schema.Number.annotate({ "description": "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\\n" }).check(Schema.isFinite())), "max_output_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")]).annotate({ "description": "Maximum number of output tokens for a single assistant response,\\ninclusive of tool calls. Provide an integer between 1 and 4096 to\\nlimit output tokens, or \`inf\` for the maximum available tokens for a\\ngiven model. Defaults to \`inf\`.\\n" })), "conversation": Schema.optionalKey(Schema.Union([Schema.String, Schema.Literals(["auto", "none"]).annotate({ "default": "auto" })]).annotate({ "description": "Controls which conversation the response is added to. Currently supports\\n\`auto\` and \`none\`, with \`auto\` as the default value. The \`auto\` value\\nmeans that the contents of the response will be added to the default\\nconversation. Set this to \`none\` to create an out-of-band response which \\nwill not add items to default conversation.\\n" })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "prompt": Schema.optionalKey(Schema.suspend((): Schema.Codec<Prompt> => Prompt)), "input": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem)).annotate({ "description": "Input items to include in the prompt for the model. Using this field\\ncreates a new context for this Response instead of using the default\\nconversation. An empty array \`[]\` will clear the context for this Response.\\nNote that this can include references to items from the default conversation.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Create a new Realtime response with these parameters", "identifier": "RealtimeBetaResponseCreateParams" })
export type RealtimeResponseCreateParams = { readonly "output_modalities"?: ReadonlyArray<"text" | "audio">, readonly "instructions"?: string, readonly "audio"?: { readonly "output"?: { readonly "format"?: RealtimeAudioFormats, readonly "voice"?: VoiceIdsShared, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "tools"?: ReadonlyArray<RealtimeFunctionTool | MCPTool>, readonly "tool_choice"?: ToolChoiceOptions | ToolChoiceFunction | ToolChoiceMCP, readonly "max_output_tokens"?: number | "inf", readonly "conversation"?: string | "auto" | "none", readonly "metadata"?: Metadata, readonly "prompt"?: Prompt, readonly "input"?: ReadonlyArray<RealtimeConversationItem>, readonly [x: string]: unknown }
export const RealtimeResponseCreateParams = Schema.StructWithRest(Schema.Struct({ "output_modalities": Schema.optionalKey(Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "The set of modalities the model used to respond, currently the only possible values are\\n\`[\\\\\\"audio\\\\\\"]\`, \`[\\\\\\"text\\\\\\"]\`. Audio output always include a text transcript. Setting the\\noutput to mode \`text\` will disable audio output from the model.\\n" })), "instructions": Schema.optionalKey(Schema.String.annotate({ "description": "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \\"be extremely succinct\\", \\"act friendly\\", \\"here are examples of good responses\\") and on audio behavior (e.g. \\"talk quickly\\", \\"inject emotion into your voice\\", \\"laugh frequently\\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\\nNote that the server sets default instructions which will be used if this field is not set and are visible in the \`session.created\` event at the start of the session.\\n" })), "audio": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "output": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeAudioFormats> => RealtimeAudioFormats).annotate({ "description": "The format of the output audio." })), "voice": Schema.optionalKey(Schema.suspend((): Schema.Codec<VoiceIdsShared> => VoiceIdsShared).annotate({ "description": "The voice the model uses to respond. Voice cannot be changed during the\\nsession once the model has responded with audio at least once. Current\\nvoice options are \`alloy\`, \`ash\`, \`ballad\`, \`coral\`, \`echo\`, \`sage\`,\\n\`shimmer\`, \`verse\`, \`marin\`, and \`cedar\`. We recommend \`marin\` and \`cedar\` for\\nbest quality.\\n", "default": "alloy" })) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for audio input and output." })), "tools": Schema.optionalKey(Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<RealtimeFunctionTool> => RealtimeFunctionTool), Schema.suspend((): Schema.Codec<MCPTool> => MCPTool)])).annotate({ "description": "Tools available to the model." })), "tool_choice": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ToolChoiceOptions> => ToolChoiceOptions), Schema.suspend((): Schema.Codec<ToolChoiceFunction> => ToolChoiceFunction), Schema.suspend((): Schema.Codec<ToolChoiceMCP> => ToolChoiceMCP)]).annotate({ "description": "How the model chooses tools. Provide one of the string modes or force a specific\\nfunction/MCP tool.\\n", "default": "auto" })), "max_output_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")]).annotate({ "description": "Maximum number of output tokens for a single assistant response,\\ninclusive of tool calls. Provide an integer between 1 and 4096 to\\nlimit output tokens, or \`inf\` for the maximum available tokens for a\\ngiven model. Defaults to \`inf\`.\\n" })), "conversation": Schema.optionalKey(Schema.Union([Schema.String, Schema.Literals(["auto", "none"]).annotate({ "default": "auto" })]).annotate({ "description": "Controls which conversation the response is added to. Currently supports\\n\`auto\` and \`none\`, with \`auto\` as the default value. The \`auto\` value\\nmeans that the contents of the response will be added to the default\\nconversation. Set this to \`none\` to create an out-of-band response which\\nwill not add items to default conversation.\\n" })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "prompt": Schema.optionalKey(Schema.suspend((): Schema.Codec<Prompt> => Prompt)), "input": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<RealtimeConversationItem> => RealtimeConversationItem)).annotate({ "description": "Input items to include in the prompt for the model. Using this field\\ncreates a new context for this Response instead of using the default\\nconversation. An empty array \`[]\` will clear the context for this Response.\\nNote that this can include references to items that previously appeared in the session\\nusing their id.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Create a new Realtime response with these parameters", "identifier": "RealtimeResponseCreateParams" })
export type RealtimeSession = { readonly "id"?: string, readonly "object"?: "realtime.session", readonly "modalities"?: ReadonlyArray<"text" | "audio">, readonly "model"?: string | "gpt-realtime" | "gpt-realtime-2025-08-28" | "gpt-4o-realtime-preview" | "gpt-4o-realtime-preview-2024-10-01" | "gpt-4o-realtime-preview-2024-12-17" | "gpt-4o-realtime-preview-2025-06-03" | "gpt-4o-mini-realtime-preview" | "gpt-4o-mini-realtime-preview-2024-12-17" | "gpt-realtime-mini" | "gpt-realtime-mini-2025-10-06" | "gpt-realtime-mini-2025-12-15" | "gpt-audio-mini" | "gpt-audio-mini-2025-10-06" | "gpt-audio-mini-2025-12-15", readonly "instructions"?: string, readonly "voice"?: VoiceIdsShared, readonly "input_audio_format"?: "pcm16" | "g711_ulaw" | "g711_alaw", readonly "output_audio_format"?: "pcm16" | "g711_ulaw" | "g711_alaw", readonly "input_audio_transcription"?: AudioTranscription | null, readonly "turn_detection"?: RealtimeTurnDetection, readonly "input_audio_noise_reduction"?: { readonly "type"?: NoiseReductionType, readonly [x: string]: unknown }, readonly "speed"?: number, readonly "tracing"?: "auto" | { readonly "workflow_name"?: string, readonly "group_id"?: string, readonly "metadata"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown } | null, readonly "tools"?: ReadonlyArray<RealtimeFunctionTool>, readonly "tool_choice"?: string, readonly "temperature"?: number, readonly "max_response_output_tokens"?: number | "inf", readonly "expires_at"?: number, readonly "prompt"?: Prompt | null, readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs"> | null, readonly [x: string]: unknown }
export const RealtimeSession = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "Unique identifier for the session that looks like \`sess_1234567890abcdef\`.\\n" })), "object": Schema.optionalKey(Schema.Literal("realtime.session").annotate({ "description": "The object type. Always \`realtime.session\`." })), "modalities": Schema.optionalKey(Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "The set of modalities the model can respond with. To disable audio,\\nset this to [\\"text\\"].\\n" })), "model": Schema.optionalKey(Schema.Union([Schema.String, Schema.Literals(["gpt-realtime", "gpt-realtime-2025-08-28", "gpt-4o-realtime-preview", "gpt-4o-realtime-preview-2024-10-01", "gpt-4o-realtime-preview-2024-12-17", "gpt-4o-realtime-preview-2025-06-03", "gpt-4o-mini-realtime-preview", "gpt-4o-mini-realtime-preview-2024-12-17", "gpt-realtime-mini", "gpt-realtime-mini-2025-10-06", "gpt-realtime-mini-2025-12-15", "gpt-audio-mini", "gpt-audio-mini-2025-10-06", "gpt-audio-mini-2025-12-15"])]).annotate({ "description": "The Realtime model used for this session.\\n" })), "instructions": Schema.optionalKey(Schema.String.annotate({ "description": "The default system instructions (i.e. system message) prepended to model\\ncalls. This field allows the client to guide the model on desired\\nresponses. The model can be instructed on response content and format,\\n(e.g. \\"be extremely succinct\\", \\"act friendly\\", \\"here are examples of good\\nresponses\\") and on audio behavior (e.g. \\"talk quickly\\", \\"inject emotion\\ninto your voice\\", \\"laugh frequently\\"). The instructions are not\\nguaranteed to be followed by the model, but they provide guidance to the\\nmodel on the desired behavior.\\n\\n\\nNote that the server sets default instructions which will be used if this\\nfield is not set and are visible in the \`session.created\` event at the\\nstart of the session.\\n" })), "voice": Schema.optionalKey(Schema.suspend((): Schema.Codec<VoiceIdsShared> => VoiceIdsShared).annotate({ "description": "The voice the model uses to respond. Voice cannot be changed during the\\nsession once the model has responded with audio at least once. Current\\nvoice options are \`alloy\`, \`ash\`, \`ballad\`, \`coral\`, \`echo\`, \`sage\`,\\n\`shimmer\`, and \`verse\`.\\n" })), "input_audio_format": Schema.optionalKey(Schema.Literals(["pcm16", "g711_ulaw", "g711_alaw"]).annotate({ "description": "The format of input audio. Options are \`pcm16\`, \`g711_ulaw\`, or \`g711_alaw\`.\\nFor \`pcm16\`, input audio must be 16-bit PCM at a 24kHz sample rate,\\nsingle channel (mono), and little-endian byte order.\\n", "default": "pcm16" })), "output_audio_format": Schema.optionalKey(Schema.Literals(["pcm16", "g711_ulaw", "g711_alaw"]).annotate({ "description": "The format of output audio. Options are \`pcm16\`, \`g711_ulaw\`, or \`g711_alaw\`.\\nFor \`pcm16\`, output audio is sampled at a rate of 24kHz.\\n", "default": "pcm16" })), "input_audio_transcription": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<AudioTranscription> => AudioTranscription).annotate({ "description": "Configuration for input audio transcription, defaults to off and can be set to \`null\` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\\n" }), Schema.Null])), "turn_detection": Schema.optionalKey(RealtimeTurnDetection), "input_audio_noise_reduction": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.suspend((): Schema.Codec<NoiseReductionType> => NoiseReductionType)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input audio noise reduction. This can be set to \`null\` to turn off.\\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\\n" })), "speed": Schema.optionalKey(Schema.Number.annotate({ "description": "The speed of the model's spoken response. 1.0 is the default speed. 0.25 is\\nthe minimum speed. 1.5 is the maximum speed. This value can only be changed\\nin between model turns, not while a response is in progress.\\n", "default": 1 }).check(Schema.isFinite())), "tracing": Schema.optionalKey(Schema.Union([Schema.Union([Schema.Literal("auto").annotate({ "description": "Default tracing mode for the session.\\n", "default": "auto" }), Schema.StructWithRest(Schema.Struct({ "workflow_name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the workflow to attach to this trace. This is used to\\nname the trace in the traces dashboard.\\n" })), "group_id": Schema.optionalKey(Schema.String.annotate({ "description": "The group id to attach to this trace to enable filtering and\\ngrouping in the traces dashboard.\\n" })), "metadata": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The arbitrary metadata to attach to this trace to enable\\nfiltering in the traces dashboard.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\\n" })]).annotate({ "title": "Tracing Configuration", "description": "Configuration options for tracing. Set to null to disable tracing. Once\\ntracing is enabled for a session, the configuration cannot be modified.\\n\\n\`auto\` will create a trace for the session with default values for the\\nworkflow name, group id, and metadata.\\n" }), Schema.Null])), "tools": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<RealtimeFunctionTool> => RealtimeFunctionTool)).annotate({ "description": "Tools (functions) available to the model." })), "tool_choice": Schema.optionalKey(Schema.String.annotate({ "description": "How the model chooses tools. Options are \`auto\`, \`none\`, \`required\`, or\\nspecify a function.\\n", "default": "auto" })), "temperature": Schema.optionalKey(Schema.Number.annotate({ "description": "Sampling temperature for the model, limited to [0.6, 1.2]. For audio models a temperature of 0.8 is highly recommended for best performance.\\n", "default": 0.8 }).check(Schema.isFinite())), "max_response_output_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")]).annotate({ "description": "Maximum number of output tokens for a single assistant response,\\ninclusive of tool calls. Provide an integer between 1 and 4096 to\\nlimit output tokens, or \`inf\` for the maximum available tokens for a\\ngiven model. Defaults to \`inf\`.\\n" })), "expires_at": Schema.optionalKey(Schema.Number.annotate({ "description": "Expiration timestamp for the session, in seconds since epoch." }).check(Schema.isInt())), "prompt": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<Prompt> => Prompt), Schema.Null])), "include": Schema.optionalKey(Schema.Union([Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({ "description": "Additional fields to include in server outputs.\\n- \`item.input_audio_transcription.logprobs\`: Include logprobs for input audio transcription.\\n" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Realtime session object for the beta interface.", "identifier": "RealtimeSession" })
export type RealtimeSessionCreateRequest = { readonly "client_secret": { readonly "value": string, readonly "expires_at": number, readonly [x: string]: unknown }, readonly "modalities"?: ReadonlyArray<"text" | "audio">, readonly "instructions"?: string, readonly "voice"?: VoiceIdsShared, readonly "input_audio_format"?: string, readonly "output_audio_format"?: string, readonly "input_audio_transcription"?: { readonly "model"?: string, readonly [x: string]: unknown }, readonly "speed"?: number, readonly "tracing"?: "auto" | { readonly "workflow_name"?: string, readonly "group_id"?: string, readonly "metadata"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "turn_detection"?: { readonly "type"?: string, readonly "threshold"?: number, readonly "prefix_padding_ms"?: number, readonly "silence_duration_ms"?: number, readonly [x: string]: unknown }, readonly "tools"?: ReadonlyArray<{ readonly "type"?: "function", readonly "name"?: string, readonly "description"?: string, readonly "parameters"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown }>, readonly "tool_choice"?: string, readonly "temperature"?: number, readonly "max_response_output_tokens"?: number | "inf", readonly "truncation"?: RealtimeTruncation, readonly "prompt"?: Prompt, readonly [x: string]: unknown }
export const RealtimeSessionCreateRequest = Schema.StructWithRest(Schema.Struct({ "client_secret": Schema.StructWithRest(Schema.Struct({ "value": Schema.String.annotate({ "description": "Ephemeral key usable in client environments to authenticate connections\\nto the Realtime API. Use this in client-side environments rather than\\na standard API token, which should only be used server-side.\\n" }), "expires_at": Schema.Number.annotate({ "description": "Timestamp for when the token expires. Currently, all tokens expire\\nafter one minute.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Ephemeral key returned by the API." }), "modalities": Schema.optionalKey(Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "The set of modalities the model can respond with. To disable audio,\\nset this to [\\"text\\"].\\n" })), "instructions": Schema.optionalKey(Schema.String.annotate({ "description": "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \\"be extremely succinct\\", \\"act friendly\\", \\"here are examples of good responses\\") and on audio behavior (e.g. \\"talk quickly\\", \\"inject emotion into your voice\\", \\"laugh frequently\\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\\nNote that the server sets default instructions which will be used if this field is not set and are visible in the \`session.created\` event at the start of the session.\\n" })), "voice": Schema.optionalKey(Schema.suspend((): Schema.Codec<VoiceIdsShared> => VoiceIdsShared).annotate({ "description": "The voice the model uses to respond. Voice cannot be changed during the\\nsession once the model has responded with audio at least once. Current\\nvoice options are \`alloy\`, \`ash\`, \`ballad\`, \`coral\`, \`echo\`, \`sage\`,\\n\`shimmer\`, and \`verse\`.\\n" })), "input_audio_format": Schema.optionalKey(Schema.String.annotate({ "description": "The format of input audio. Options are \`pcm16\`, \`g711_ulaw\`, or \`g711_alaw\`.\\n" })), "output_audio_format": Schema.optionalKey(Schema.String.annotate({ "description": "The format of output audio. Options are \`pcm16\`, \`g711_ulaw\`, or \`g711_alaw\`.\\n" })), "input_audio_transcription": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "model": Schema.optionalKey(Schema.String.annotate({ "description": "The model to use for transcription.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input audio transcription, defaults to off and can be\\nset to \`null\` to turn off once on. Input audio transcription is not native\\nto the model, since the model consumes audio directly. Transcription runs\\nasynchronously and should be treated as rough guidance\\nrather than the representation understood by the model.\\n" })), "speed": Schema.optionalKey(Schema.Number.annotate({ "description": "The speed of the model's spoken response. 1.0 is the default speed. 0.25 is\\nthe minimum speed. 1.5 is the maximum speed. This value can only be changed\\nin between model turns, not while a response is in progress.\\n", "default": 1 }).check(Schema.isFinite())), "tracing": Schema.optionalKey(Schema.Union([Schema.Literal("auto").annotate({ "description": "Default tracing mode for the session.\\n", "default": "auto" }), Schema.StructWithRest(Schema.Struct({ "workflow_name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the workflow to attach to this trace. This is used to\\nname the trace in the traces dashboard.\\n" })), "group_id": Schema.optionalKey(Schema.String.annotate({ "description": "The group id to attach to this trace to enable filtering and\\ngrouping in the traces dashboard.\\n" })), "metadata": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The arbitrary metadata to attach to this trace to enable\\nfiltering in the traces dashboard.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\\n" })]).annotate({ "title": "Tracing Configuration", "description": "Configuration options for tracing. Set to null to disable tracing. Once\\ntracing is enabled for a session, the configuration cannot be modified.\\n\\n\`auto\` will create a trace for the session with default values for the\\nworkflow name, group id, and metadata.\\n" })), "turn_detection": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.String.annotate({ "description": "Type of turn detection, only \`server_vad\` is currently supported.\\n" })), "threshold": Schema.optionalKey(Schema.Number.annotate({ "description": "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\\nhigher threshold will require louder audio to activate the model, and\\nthus might perform better in noisy environments.\\n" }).check(Schema.isFinite())), "prefix_padding_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Amount of audio to include before the VAD detected speech (in\\nmilliseconds). Defaults to 300ms.\\n" }).check(Schema.isInt())), "silence_duration_ms": Schema.optionalKey(Schema.Number.annotate({ "description": "Duration of silence to detect speech stop (in milliseconds). Defaults\\nto 500ms. With shorter values the model will respond more quickly,\\nbut may jump in on short pauses from the user.\\n" }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for turn detection. Can be set to \`null\` to turn off. Server\\nVAD means that the model will detect the start and end of speech based on\\naudio volume and respond at the end of user speech.\\n" })), "tools": Schema.optionalKey(Schema.Array(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.Literal("function").annotate({ "description": "The type of the tool, i.e. \`function\`." })), "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the function." })), "description": Schema.optionalKey(Schema.String.annotate({ "description": "The description of the function, including guidance on when and how\\nto call it, and guidance about what to tell the user when calling\\n(if anything).\\n" })), "parameters": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "Parameters of the function in JSON Schema." })) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "Tools (functions) available to the model." })), "tool_choice": Schema.optionalKey(Schema.String.annotate({ "description": "How the model chooses tools. Options are \`auto\`, \`none\`, \`required\`, or\\nspecify a function.\\n" })), "temperature": Schema.optionalKey(Schema.Number.annotate({ "description": "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\\n" }).check(Schema.isFinite())), "max_response_output_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")]).annotate({ "description": "Maximum number of output tokens for a single assistant response,\\ninclusive of tool calls. Provide an integer between 1 and 4096 to\\nlimit output tokens, or \`inf\` for the maximum available tokens for a\\ngiven model. Defaults to \`inf\`.\\n" })), "truncation": Schema.optionalKey(RealtimeTruncation), "prompt": Schema.optionalKey(Schema.suspend((): Schema.Codec<Prompt> => Prompt)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A new Realtime session configuration, with an ephemeral key. Default TTL\\nfor keys is one minute.\\n", "identifier": "RealtimeSessionCreateRequest" })
export type RealtimeSessionCreateRequestGA = { readonly "type": "realtime", readonly "output_modalities"?: ReadonlyArray<"text" | "audio">, readonly "model"?: string | "gpt-realtime" | "gpt-realtime-2025-08-28" | "gpt-4o-realtime-preview" | "gpt-4o-realtime-preview-2024-10-01" | "gpt-4o-realtime-preview-2024-12-17" | "gpt-4o-realtime-preview-2025-06-03" | "gpt-4o-mini-realtime-preview" | "gpt-4o-mini-realtime-preview-2024-12-17" | "gpt-realtime-mini" | "gpt-realtime-mini-2025-10-06" | "gpt-realtime-mini-2025-12-15" | "gpt-audio-mini" | "gpt-audio-mini-2025-10-06" | "gpt-audio-mini-2025-12-15", readonly "instructions"?: string, readonly "audio"?: { readonly "input"?: { readonly "format"?: RealtimeAudioFormats, readonly "transcription"?: AudioTranscription, readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType, readonly [x: string]: unknown }, readonly "turn_detection"?: RealtimeTurnDetection, readonly [x: string]: unknown }, readonly "output"?: { readonly "format"?: RealtimeAudioFormats, readonly "voice"?: VoiceIdsShared, readonly "speed"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">, readonly "tracing"?: "auto" | { readonly "workflow_name"?: string, readonly "group_id"?: string, readonly "metadata"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown } | null, readonly "tools"?: ReadonlyArray<RealtimeFunctionTool | MCPTool>, readonly "tool_choice"?: ToolChoiceOptions | ToolChoiceFunction | ToolChoiceMCP, readonly "max_output_tokens"?: number | "inf", readonly "truncation"?: RealtimeTruncation, readonly "prompt"?: Prompt, readonly [x: string]: unknown }
export const RealtimeSessionCreateRequestGA = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("realtime").annotate({ "description": "The type of session to create. Always \`realtime\` for the Realtime API.\\n" }), "output_modalities": Schema.optionalKey(Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "The set of modalities the model can respond with. It defaults to \`[\\"audio\\"]\`, indicating\\nthat the model will respond with audio plus a transcript. \`[\\"text\\"]\` can be used to make\\nthe model respond with text only. It is not possible to request both \`text\` and \`audio\` at the same time.\\n", "default": ["audio"] })), "model": Schema.optionalKey(Schema.Union([Schema.String, Schema.Literals(["gpt-realtime", "gpt-realtime-2025-08-28", "gpt-4o-realtime-preview", "gpt-4o-realtime-preview-2024-10-01", "gpt-4o-realtime-preview-2024-12-17", "gpt-4o-realtime-preview-2025-06-03", "gpt-4o-mini-realtime-preview", "gpt-4o-mini-realtime-preview-2024-12-17", "gpt-realtime-mini", "gpt-realtime-mini-2025-10-06", "gpt-realtime-mini-2025-12-15", "gpt-audio-mini", "gpt-audio-mini-2025-10-06", "gpt-audio-mini-2025-12-15"])]).annotate({ "description": "The Realtime model used for this session.\\n" })), "instructions": Schema.optionalKey(Schema.String.annotate({ "description": "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \\"be extremely succinct\\", \\"act friendly\\", \\"here are examples of good responses\\") and on audio behavior (e.g. \\"talk quickly\\", \\"inject emotion into your voice\\", \\"laugh frequently\\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\\n\\nNote that the server sets default instructions which will be used if this field is not set and are visible in the \`session.created\` event at the start of the session.\\n" })), "audio": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "input": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeAudioFormats> => RealtimeAudioFormats).annotate({ "description": "The format of the input audio." })), "transcription": Schema.optionalKey(Schema.suspend((): Schema.Codec<AudioTranscription> => AudioTranscription).annotate({ "description": "Configuration for input audio transcription, defaults to off and can be set to \`null\` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\\n" })), "noise_reduction": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.suspend((): Schema.Codec<NoiseReductionType> => NoiseReductionType)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input audio noise reduction. This can be set to \`null\` to turn off.\\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\\n" })), "turn_detection": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeTurnDetection> => RealtimeTurnDetection)) }), [Schema.Record(Schema.String, Schema.Unknown)])), "output": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeAudioFormats> => RealtimeAudioFormats).annotate({ "description": "The format of the output audio." })), "voice": Schema.optionalKey(Schema.suspend((): Schema.Codec<VoiceIdsShared> => VoiceIdsShared).annotate({ "description": "The voice the model uses to respond. Voice cannot be changed during the\\nsession once the model has responded with audio at least once. Current\\nvoice options are \`alloy\`, \`ash\`, \`ballad\`, \`coral\`, \`echo\`, \`sage\`,\\n\`shimmer\`, \`verse\`, \`marin\`, and \`cedar\`. We recommend \`marin\` and \`cedar\` for\\nbest quality.\\n", "default": "alloy" })), "speed": Schema.optionalKey(Schema.Number.annotate({ "description": "The speed of the model's spoken response as a multiple of the original speed.\\n1.0 is the default speed. 0.25 is the minimum speed. 1.5 is the maximum speed. This value can only be changed in between model turns, not while a response is in progress.\\n\\nThis parameter is a post-processing adjustment to the audio after it is generated, it's\\nalso possible to prompt the model to speak faster or slower.\\n", "default": 1 }).check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input and output audio.\\n" })), "include": Schema.optionalKey(Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({ "description": "Additional fields to include in server outputs.\\n\\n\`item.input_audio_transcription.logprobs\`: Include logprobs for input audio transcription.\\n" })), "tracing": Schema.optionalKey(Schema.Union([Schema.Union([Schema.Literal("auto").annotate({ "title": "auto", "description": "Enables tracing and sets default values for tracing configuration options. Always \`auto\`.\\n", "default": "auto" }), Schema.StructWithRest(Schema.Struct({ "workflow_name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the workflow to attach to this trace. This is used to\\nname the trace in the Traces Dashboard.\\n" })), "group_id": Schema.optionalKey(Schema.String.annotate({ "description": "The group id to attach to this trace to enable filtering and\\ngrouping in the Traces Dashboard.\\n" })), "metadata": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The arbitrary metadata to attach to this trace to enable\\nfiltering in the Traces Dashboard.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\\n" })]).annotate({ "title": "Tracing Configuration", "description": "Realtime API can write session traces to the [Traces Dashboard](/logs?api=traces). Set to null to disable tracing. Once\\ntracing is enabled for a session, the configuration cannot be modified.\\n\\n\`auto\` will create a trace for the session with default values for the\\nworkflow name, group id, and metadata.\\n" }), Schema.Null])), "tools": Schema.optionalKey(Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<RealtimeFunctionTool> => RealtimeFunctionTool), Schema.suspend((): Schema.Codec<MCPTool> => MCPTool)])).annotate({ "description": "Tools available to the model." })), "tool_choice": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ToolChoiceOptions> => ToolChoiceOptions), Schema.suspend((): Schema.Codec<ToolChoiceFunction> => ToolChoiceFunction), Schema.suspend((): Schema.Codec<ToolChoiceMCP> => ToolChoiceMCP)]).annotate({ "description": "How the model chooses tools. Provide one of the string modes or force a specific\\nfunction/MCP tool.\\n", "default": "auto" })), "max_output_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")]).annotate({ "description": "Maximum number of output tokens for a single assistant response,\\ninclusive of tool calls. Provide an integer between 1 and 4096 to\\nlimit output tokens, or \`inf\` for the maximum available tokens for a\\ngiven model. Defaults to \`inf\`.\\n" })), "truncation": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeTruncation> => RealtimeTruncation)), "prompt": Schema.optionalKey(Schema.suspend((): Schema.Codec<Prompt> => Prompt)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime session configuration", "description": "Realtime session object configuration.", "identifier": "RealtimeSessionCreateRequestGA" })
export type RealtimeSessionCreateResponseGA = { readonly "client_secret": { readonly "value": string, readonly "expires_at": number, readonly [x: string]: unknown }, readonly "type": "realtime", readonly "output_modalities"?: ReadonlyArray<"text" | "audio">, readonly "model"?: string | "gpt-realtime" | "gpt-realtime-2025-08-28" | "gpt-4o-realtime-preview" | "gpt-4o-realtime-preview-2024-10-01" | "gpt-4o-realtime-preview-2024-12-17" | "gpt-4o-realtime-preview-2025-06-03" | "gpt-4o-mini-realtime-preview" | "gpt-4o-mini-realtime-preview-2024-12-17" | "gpt-realtime-mini" | "gpt-realtime-mini-2025-10-06" | "gpt-realtime-mini-2025-12-15" | "gpt-audio-mini" | "gpt-audio-mini-2025-10-06" | "gpt-audio-mini-2025-12-15", readonly "instructions"?: string, readonly "audio"?: { readonly "input"?: { readonly "format"?: RealtimeAudioFormats, readonly "transcription"?: AudioTranscription, readonly "noise_reduction"?: { readonly "type"?: NoiseReductionType, readonly [x: string]: unknown }, readonly "turn_detection"?: RealtimeTurnDetection, readonly [x: string]: unknown }, readonly "output"?: { readonly "format"?: RealtimeAudioFormats, readonly "voice"?: VoiceIdsShared, readonly "speed"?: number, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "include"?: ReadonlyArray<"item.input_audio_transcription.logprobs">, readonly "tracing"?: "auto" | { readonly "workflow_name"?: string, readonly "group_id"?: string, readonly "metadata"?: { readonly [x: string]: unknown }, readonly [x: string]: unknown } | null, readonly "tools"?: ReadonlyArray<RealtimeFunctionTool | MCPTool>, readonly "tool_choice"?: ToolChoiceOptions | ToolChoiceFunction | ToolChoiceMCP, readonly "max_output_tokens"?: number | "inf", readonly "truncation"?: RealtimeTruncation, readonly "prompt"?: Prompt, readonly [x: string]: unknown }
export const RealtimeSessionCreateResponseGA = Schema.StructWithRest(Schema.Struct({ "client_secret": Schema.StructWithRest(Schema.Struct({ "value": Schema.String.annotate({ "description": "Ephemeral key usable in client environments to authenticate connections to the Realtime API. Use this in client-side environments rather than a standard API token, which should only be used server-side.\\n" }), "expires_at": Schema.Number.annotate({ "description": "Timestamp for when the token expires. Currently, all tokens expire\\nafter one minute.\\n" }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Ephemeral key returned by the API." }), "type": Schema.Literal("realtime").annotate({ "description": "The type of session to create. Always \`realtime\` for the Realtime API.\\n" }), "output_modalities": Schema.optionalKey(Schema.Array(Schema.Literals(["text", "audio"])).annotate({ "description": "The set of modalities the model can respond with. It defaults to \`[\\"audio\\"]\`, indicating\\nthat the model will respond with audio plus a transcript. \`[\\"text\\"]\` can be used to make\\nthe model respond with text only. It is not possible to request both \`text\` and \`audio\` at the same time.\\n", "default": ["audio"] })), "model": Schema.optionalKey(Schema.Union([Schema.String, Schema.Literals(["gpt-realtime", "gpt-realtime-2025-08-28", "gpt-4o-realtime-preview", "gpt-4o-realtime-preview-2024-10-01", "gpt-4o-realtime-preview-2024-12-17", "gpt-4o-realtime-preview-2025-06-03", "gpt-4o-mini-realtime-preview", "gpt-4o-mini-realtime-preview-2024-12-17", "gpt-realtime-mini", "gpt-realtime-mini-2025-10-06", "gpt-realtime-mini-2025-12-15", "gpt-audio-mini", "gpt-audio-mini-2025-10-06", "gpt-audio-mini-2025-12-15"])]).annotate({ "description": "The Realtime model used for this session.\\n" })), "instructions": Schema.optionalKey(Schema.String.annotate({ "description": "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \\"be extremely succinct\\", \\"act friendly\\", \\"here are examples of good responses\\") and on audio behavior (e.g. \\"talk quickly\\", \\"inject emotion into your voice\\", \\"laugh frequently\\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\\n\\nNote that the server sets default instructions which will be used if this field is not set and are visible in the \`session.created\` event at the start of the session.\\n" })), "audio": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "input": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeAudioFormats> => RealtimeAudioFormats).annotate({ "description": "The format of the input audio." })), "transcription": Schema.optionalKey(Schema.suspend((): Schema.Codec<AudioTranscription> => AudioTranscription).annotate({ "description": "Configuration for input audio transcription, defaults to off and can be set to \`null\` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\\n" })), "noise_reduction": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "type": Schema.optionalKey(Schema.suspend((): Schema.Codec<NoiseReductionType> => NoiseReductionType)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input audio noise reduction. This can be set to \`null\` to turn off.\\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\\n" })), "turn_detection": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeTurnDetection> => RealtimeTurnDetection)) }), [Schema.Record(Schema.String, Schema.Unknown)])), "output": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeAudioFormats> => RealtimeAudioFormats).annotate({ "description": "The format of the output audio." })), "voice": Schema.optionalKey(Schema.suspend((): Schema.Codec<VoiceIdsShared> => VoiceIdsShared).annotate({ "description": "The voice the model uses to respond. Voice cannot be changed during the\\nsession once the model has responded with audio at least once. Current\\nvoice options are \`alloy\`, \`ash\`, \`ballad\`, \`coral\`, \`echo\`, \`sage\`,\\n\`shimmer\`, \`verse\`, \`marin\`, and \`cedar\`. We recommend \`marin\` and \`cedar\` for\\nbest quality.\\n", "default": "alloy" })), "speed": Schema.optionalKey(Schema.Number.annotate({ "description": "The speed of the model's spoken response as a multiple of the original speed.\\n1.0 is the default speed. 0.25 is the minimum speed. 1.5 is the maximum speed. This value can only be changed in between model turns, not while a response is in progress.\\n\\nThis parameter is a post-processing adjustment to the audio after it is generated, it's\\nalso possible to prompt the model to speak faster or slower.\\n", "default": 1 }).check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for input and output audio.\\n" })), "include": Schema.optionalKey(Schema.Array(Schema.Literal("item.input_audio_transcription.logprobs")).annotate({ "description": "Additional fields to include in server outputs.\\n\\n\`item.input_audio_transcription.logprobs\`: Include logprobs for input audio transcription.\\n" })), "tracing": Schema.optionalKey(Schema.Union([Schema.Union([Schema.Literal("auto").annotate({ "title": "auto", "description": "Enables tracing and sets default values for tracing configuration options. Always \`auto\`.\\n", "default": "auto" }), Schema.StructWithRest(Schema.Struct({ "workflow_name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the workflow to attach to this trace. This is used to\\nname the trace in the Traces Dashboard.\\n" })), "group_id": Schema.optionalKey(Schema.String.annotate({ "description": "The group id to attach to this trace to enable filtering and\\ngrouping in the Traces Dashboard.\\n" })), "metadata": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The arbitrary metadata to attach to this trace to enable\\nfiltering in the Traces Dashboard.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Tracing Configuration", "description": "Granular configuration for tracing.\\n" })]).annotate({ "title": "Tracing Configuration", "description": "Realtime API can write session traces to the [Traces Dashboard](/logs?api=traces). Set to null to disable tracing. Once\\ntracing is enabled for a session, the configuration cannot be modified.\\n\\n\`auto\` will create a trace for the session with default values for the\\nworkflow name, group id, and metadata.\\n" }), Schema.Null])), "tools": Schema.optionalKey(Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<RealtimeFunctionTool> => RealtimeFunctionTool), Schema.suspend((): Schema.Codec<MCPTool> => MCPTool)])).annotate({ "description": "Tools available to the model." })), "tool_choice": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ToolChoiceOptions> => ToolChoiceOptions), Schema.suspend((): Schema.Codec<ToolChoiceFunction> => ToolChoiceFunction), Schema.suspend((): Schema.Codec<ToolChoiceMCP> => ToolChoiceMCP)]).annotate({ "description": "How the model chooses tools. Provide one of the string modes or force a specific\\nfunction/MCP tool.\\n", "default": "auto" })), "max_output_tokens": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Literal("inf")]).annotate({ "description": "Maximum number of output tokens for a single assistant response,\\ninclusive of tool calls. Provide an integer between 1 and 4096 to\\nlimit output tokens, or \`inf\` for the maximum available tokens for a\\ngiven model. Defaults to \`inf\`.\\n" })), "truncation": Schema.optionalKey(Schema.suspend((): Schema.Codec<RealtimeTruncation> => RealtimeTruncation)), "prompt": Schema.optionalKey(Schema.suspend((): Schema.Codec<Prompt> => Prompt)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A new Realtime session configuration, with an ephemeral key. Default TTL\\nfor keys is one minute.\\n", "identifier": "RealtimeSessionCreateResponseGA" })
export type ConversationItem = Message | FunctionToolCallResource | FunctionToolCallOutputResource | FileSearchToolCall | WebSearchToolCall | ImageGenToolCall | ComputerToolCall | ComputerToolCallOutputResource | ReasoningItem | CodeInterpreterToolCall | LocalShellToolCall | LocalShellToolCallOutput | FunctionShellCall | FunctionShellCallOutput | ApplyPatchToolCall | ApplyPatchToolCallOutput | MCPListTools | MCPApprovalRequest | MCPApprovalResponseResource | MCPToolCall | CustomToolCall | CustomToolCallOutput
export const ConversationItem = Schema.Union([Message, FunctionToolCallResource, FunctionToolCallOutputResource, FileSearchToolCall, WebSearchToolCall, ImageGenToolCall, Schema.suspend((): Schema.Codec<ComputerToolCall> => ComputerToolCall), Schema.suspend((): Schema.Codec<ComputerToolCallOutputResource> => ComputerToolCallOutputResource), ReasoningItem, Schema.suspend((): Schema.Codec<CodeInterpreterToolCall> => CodeInterpreterToolCall), LocalShellToolCall, LocalShellToolCallOutput, FunctionShellCall, FunctionShellCallOutput, ApplyPatchToolCall, ApplyPatchToolCallOutput, MCPListTools, MCPApprovalRequest, MCPApprovalResponseResource, MCPToolCall, CustomToolCall, CustomToolCallOutput]).annotate({ "title": "Conversation item", "description": "A single item within a conversation. The set of possible types are the same as the \`output\` type of a [Response object](https://platform.openai.com/docs/api-reference/responses/object#responses/object-output).", "identifier": "ConversationItem" })
export type ItemField = Message | FunctionToolCall | FunctionToolCallOutput | FileSearchToolCall | WebSearchToolCall | ImageGenToolCall | ComputerToolCall | ComputerToolCallOutputResource | ReasoningItem | CompactionBody | CodeInterpreterToolCall | LocalShellToolCall | LocalShellToolCallOutput | FunctionShellCall | FunctionShellCallOutput | ApplyPatchToolCall | ApplyPatchToolCallOutput | MCPListTools | MCPApprovalRequest | MCPApprovalResponseResource | MCPToolCall | CustomToolCall | CustomToolCallOutput
export const ItemField = Schema.Union([Schema.suspend((): Schema.Codec<Message> => Message), Schema.suspend((): Schema.Codec<FunctionToolCall> => FunctionToolCall), Schema.suspend((): Schema.Codec<FunctionToolCallOutput> => FunctionToolCallOutput), Schema.suspend((): Schema.Codec<FileSearchToolCall> => FileSearchToolCall), Schema.suspend((): Schema.Codec<WebSearchToolCall> => WebSearchToolCall), Schema.suspend((): Schema.Codec<ImageGenToolCall> => ImageGenToolCall), Schema.suspend((): Schema.Codec<ComputerToolCall> => ComputerToolCall), Schema.suspend((): Schema.Codec<ComputerToolCallOutputResource> => ComputerToolCallOutputResource), Schema.suspend((): Schema.Codec<ReasoningItem> => ReasoningItem), Schema.suspend((): Schema.Codec<CompactionBody> => CompactionBody), Schema.suspend((): Schema.Codec<CodeInterpreterToolCall> => CodeInterpreterToolCall), Schema.suspend((): Schema.Codec<LocalShellToolCall> => LocalShellToolCall), Schema.suspend((): Schema.Codec<LocalShellToolCallOutput> => LocalShellToolCallOutput), Schema.suspend((): Schema.Codec<FunctionShellCall> => FunctionShellCall), Schema.suspend((): Schema.Codec<FunctionShellCallOutput> => FunctionShellCallOutput), Schema.suspend((): Schema.Codec<ApplyPatchToolCall> => ApplyPatchToolCall), Schema.suspend((): Schema.Codec<ApplyPatchToolCallOutput> => ApplyPatchToolCallOutput), Schema.suspend((): Schema.Codec<MCPListTools> => MCPListTools), Schema.suspend((): Schema.Codec<MCPApprovalRequest> => MCPApprovalRequest), Schema.suspend((): Schema.Codec<MCPApprovalResponseResource> => MCPApprovalResponseResource), Schema.suspend((): Schema.Codec<MCPToolCall> => MCPToolCall), Schema.suspend((): Schema.Codec<CustomToolCall> => CustomToolCall), Schema.suspend((): Schema.Codec<CustomToolCallOutput> => CustomToolCallOutput)]).annotate({ "identifier": "ItemField" })
export type ThreadItem = UserMessageItem | AssistantMessageItem | WidgetMessageItem | ClientToolCallItem | TaskItem | TaskGroupItem
export const ThreadItem = Schema.Union([Schema.suspend((): Schema.Codec<UserMessageItem> => UserMessageItem), Schema.suspend((): Schema.Codec<AssistantMessageItem> => AssistantMessageItem), Schema.suspend((): Schema.Codec<WidgetMessageItem> => WidgetMessageItem), Schema.suspend((): Schema.Codec<ClientToolCallItem> => ClientToolCallItem), Schema.suspend((): Schema.Codec<TaskItem> => TaskItem), Schema.suspend((): Schema.Codec<TaskGroupItem> => TaskGroupItem)]).annotate({ "title": "The thread item", "identifier": "ThreadItem" })
export type FileSearchTool = { readonly "type": "file_search", readonly "vector_store_ids": ReadonlyArray<string>, readonly "max_num_results"?: number, readonly "ranking_options"?: RankingOptions, readonly "filters"?: Filters | null, readonly [x: string]: unknown }
export const FileSearchTool = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("file_search").annotate({ "description": "The type of the file search tool. Always \`file_search\`.", "default": "file_search" }), "vector_store_ids": Schema.Array(Schema.String).annotate({ "description": "The IDs of the vector stores to search." }), "max_num_results": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum number of results to return. This number should be between 1 and 50 inclusive." }).check(Schema.isInt())), "ranking_options": Schema.optionalKey(Schema.suspend((): Schema.Codec<RankingOptions> => RankingOptions).annotate({ "description": "Ranking options for search." })), "filters": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<Filters> => Filters).annotate({ "description": "A filter to apply." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "File search", "description": "A tool that searches for relevant content from uploaded files. Learn more about the [file search tool](https://platform.openai.com/docs/guides/tools-file-search).", "identifier": "FileSearchTool" })
export type RunStepObject = { readonly "id": string, readonly "object": "thread.run.step", readonly "created_at": number, readonly "assistant_id": string, readonly "thread_id": string, readonly "run_id": string, readonly "type": "message_creation" | "tool_calls", readonly "status": "in_progress" | "cancelled" | "failed" | "completed" | "expired", readonly "step_details": RunStepDetailsMessageCreationObject | RunStepDetailsToolCallsObject, readonly "last_error": { readonly "code": "server_error" | "rate_limit_exceeded", readonly "message": string, readonly [x: string]: unknown } | null, readonly "expired_at": number | null, readonly "cancelled_at": number | null, readonly "failed_at": number | null, readonly "completed_at": number | null, readonly "metadata": Metadata, readonly "usage": RunStepCompletionUsage, readonly [x: string]: unknown }
export const RunStepObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier of the run step, which can be referenced in API endpoints." }), "object": Schema.Literal("thread.run.step").annotate({ "description": "The object type, which is always \`thread.run.step\`." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the run step was created." }).check(Schema.isInt()), "assistant_id": Schema.String.annotate({ "description": "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step." }), "thread_id": Schema.String.annotate({ "description": "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run." }), "run_id": Schema.String.annotate({ "description": "The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of." }), "type": Schema.Literals(["message_creation", "tool_calls"]).annotate({ "description": "The type of run step, which can be either \`message_creation\` or \`tool_calls\`." }), "status": Schema.Literals(["in_progress", "cancelled", "failed", "completed", "expired"]).annotate({ "description": "The status of the run step, which can be either \`in_progress\`, \`cancelled\`, \`failed\`, \`completed\`, or \`expired\`." }), "step_details": Schema.Union([Schema.suspend((): Schema.Codec<RunStepDetailsMessageCreationObject> => RunStepDetailsMessageCreationObject), Schema.suspend((): Schema.Codec<RunStepDetailsToolCallsObject> => RunStepDetailsToolCallsObject)]).annotate({ "description": "The details of the run step." }), "last_error": Schema.Union([Schema.StructWithRest(Schema.Struct({ "code": Schema.Literals(["server_error", "rate_limit_exceeded"]).annotate({ "description": "One of \`server_error\` or \`rate_limit_exceeded\`." }), "message": Schema.String.annotate({ "description": "A human-readable description of the error." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The last error associated with this run step. Will be \`null\` if there are no errors." }), Schema.Null]), "expired_at": Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired." }).check(Schema.isInt()), Schema.Null]), "cancelled_at": Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the run step was cancelled." }).check(Schema.isInt()), Schema.Null]), "failed_at": Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the run step failed." }).check(Schema.isInt()), Schema.Null]), "completed_at": Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the run step completed." }).check(Schema.isInt()), Schema.Null]), "metadata": Schema.suspend((): Schema.Codec<Metadata> => Metadata), "usage": Schema.suspend((): Schema.Codec<RunStepCompletionUsage> => RunStepCompletionUsage) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Run steps", "description": "Represents a step in execution of a run.\\n", "identifier": "RunStepObject" })
export type ListAssistantsResponse = { readonly "object": string, readonly "data": ReadonlyArray<AssistantObject>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListAssistantsResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.String, "data": Schema.Array(Schema.suspend((): Schema.Codec<AssistantObject> => AssistantObject)), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListAssistantsResponse" })
export type ListRunsResponse = { readonly "object": string, readonly "data": ReadonlyArray<RunObject>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListRunsResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.String, "data": Schema.Array(RunObject), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListRunsResponse" })
export type RunStreamEvent = { readonly "event": "thread.run.created", readonly "data": RunObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.queued", readonly "data": RunObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.in_progress", readonly "data": RunObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.requires_action", readonly "data": RunObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.completed", readonly "data": RunObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.incomplete", readonly "data": RunObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.failed", readonly "data": RunObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.cancelling", readonly "data": RunObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.cancelled", readonly "data": RunObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.expired", readonly "data": RunObject, readonly [x: string]: unknown }
export const RunStreamEvent = Schema.Union([Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.created"), "data": Schema.suspend((): Schema.Codec<RunObject> => RunObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a new [run](https://platform.openai.com/docs/api-reference/runs/object) is created." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.queued"), "data": Schema.suspend((): Schema.Codec<RunObject> => RunObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a \`queued\` status." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.in_progress"), "data": Schema.suspend((): Schema.Codec<RunObject> => RunObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to an \`in_progress\` status." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.requires_action"), "data": Schema.suspend((): Schema.Codec<RunObject> => RunObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a \`requires_action\` status." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.completed"), "data": Schema.suspend((): Schema.Codec<RunObject> => RunObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is completed." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.incomplete"), "data": Schema.suspend((): Schema.Codec<RunObject> => RunObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) ends with status \`incomplete\`." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.failed"), "data": Schema.suspend((): Schema.Codec<RunObject> => RunObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) fails." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.cancelling"), "data": Schema.suspend((): Schema.Codec<RunObject> => RunObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a \`cancelling\` status." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.cancelled"), "data": Schema.suspend((): Schema.Codec<RunObject> => RunObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is cancelled." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.expired"), "data": Schema.suspend((): Schema.Codec<RunObject> => RunObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) expires." })]).annotate({ "identifier": "RunStreamEvent" })
export type ListMessagesResponse = { readonly "object": string, readonly "data": ReadonlyArray<MessageObject>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListMessagesResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.String, "data": Schema.Array(MessageObject), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListMessagesResponse" })
export type MessageStreamEvent = { readonly "event": "thread.message.created", readonly "data": MessageObject, readonly [x: string]: unknown } | { readonly "event": "thread.message.in_progress", readonly "data": MessageObject, readonly [x: string]: unknown } | { readonly "event": "thread.message.delta", readonly "data": MessageDeltaObject, readonly [x: string]: unknown } | { readonly "event": "thread.message.completed", readonly "data": MessageObject, readonly [x: string]: unknown } | { readonly "event": "thread.message.incomplete", readonly "data": MessageObject, readonly [x: string]: unknown }
export const MessageStreamEvent = Schema.Union([Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.message.created"), "data": Schema.suspend((): Schema.Codec<MessageObject> => MessageObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is created." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.message.in_progress"), "data": Schema.suspend((): Schema.Codec<MessageObject> => MessageObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) moves to an \`in_progress\` state." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.message.delta"), "data": Schema.suspend((): Schema.Codec<MessageDeltaObject> => MessageDeltaObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when parts of a [Message](https://platform.openai.com/docs/api-reference/messages/object) are being streamed." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.message.completed"), "data": Schema.suspend((): Schema.Codec<MessageObject> => MessageObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is completed." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.message.incomplete"), "data": Schema.suspend((): Schema.Codec<MessageObject> => MessageObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) ends before it is completed." })]).annotate({ "identifier": "MessageStreamEvent" })
export type RunStepDeltaObject = { readonly "id": string, readonly "object": "thread.run.step.delta", readonly "delta": RunStepDeltaObjectDelta, readonly [x: string]: unknown }
export const RunStepDeltaObject = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The identifier of the run step, which can be referenced in API endpoints." }), "object": Schema.Literal("thread.run.step.delta").annotate({ "description": "The object type, which is always \`thread.run.step.delta\`." }), "delta": RunStepDeltaObjectDelta }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Run step delta object", "description": "Represents a run step delta i.e. any changed fields on a run step during streaming.\\n", "identifier": "RunStepDeltaObject" })
export type CreateEvalItem = { readonly "role": string, readonly "content": string, readonly [x: string]: unknown } | EvalItem
export const CreateEvalItem = Schema.Union([Schema.StructWithRest(Schema.Struct({ "role": Schema.String.annotate({ "description": "The role of the message (e.g. \\"system\\", \\"assistant\\", \\"user\\")." }), "content": Schema.String.annotate({ "description": "The content of the message." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "SimpleInputMessage" }), Schema.suspend((): Schema.Codec<EvalItem> => EvalItem)]).annotate({ "title": "CreateEvalItem", "description": "A chat message that makes up the prompt or context. May include variable references to the \`item\` namespace, ie {{item.name}}.", "identifier": "CreateEvalItem" })
export type GraderLabelModel = { readonly "type": "label_model", readonly "name": string, readonly "model": string, readonly "input": ReadonlyArray<EvalItem>, readonly "labels": ReadonlyArray<string>, readonly "passing_labels": ReadonlyArray<string>, readonly [x: string]: unknown }
export const GraderLabelModel = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("label_model").annotate({ "description": "The object type, which is always \`label_model\`." }), "name": Schema.String.annotate({ "description": "The name of the grader." }), "model": Schema.String.annotate({ "description": "The model to use for the evaluation. Must support structured outputs." }), "input": Schema.Array(Schema.suspend((): Schema.Codec<EvalItem> => EvalItem)), "labels": Schema.Array(Schema.String).annotate({ "description": "The labels to assign to each item in the evaluation." }), "passing_labels": Schema.Array(Schema.String).annotate({ "description": "The labels that indicate a passing result. Must be a subset of labels." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "LabelModelGrader", "description": "A LabelModelGrader object which uses a model to assign labels to each item\\nin the evaluation.\\n", "identifier": "GraderLabelModel" })
export type GraderScoreModel = { readonly "type": "score_model", readonly "name": string, readonly "model": string, readonly "sampling_params"?: { readonly "seed"?: number | null, readonly "top_p"?: number | null, readonly "temperature"?: number | null, readonly "max_completions_tokens"?: number | null, readonly "reasoning_effort"?: ReasoningEffort, readonly [x: string]: unknown }, readonly "input": ReadonlyArray<EvalItem>, readonly "range"?: ReadonlyArray<number>, readonly [x: string]: unknown }
export const GraderScoreModel = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("score_model").annotate({ "description": "The object type, which is always \`score_model\`." }), "name": Schema.String.annotate({ "description": "The name of the grader." }), "model": Schema.String.annotate({ "description": "The model to use for the evaluation." }), "sampling_params": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "seed": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "A seed value to initialize the randomness, during sampling.\\n" }).check(Schema.isInt()), Schema.Null])), "top_p": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "An alternative to temperature for nucleus sampling; 1.0 includes all tokens.\\n", "default": 1 }).check(Schema.isFinite()), Schema.Null])), "temperature": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "A higher temperature increases randomness in the outputs.\\n" }).check(Schema.isFinite()), Schema.Null])), "max_completions_tokens": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "The maximum number of tokens the grader model may generate in its response.\\n" }).check(Schema.isInt()), Schema.Null])), "reasoning_effort": Schema.optionalKey(Schema.suspend((): Schema.Codec<ReasoningEffort> => ReasoningEffort)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The sampling parameters for the model." })), "input": Schema.Array(Schema.suspend((): Schema.Codec<EvalItem> => EvalItem)).annotate({ "description": "The input messages evaluated by the grader. Supports text, output text, input image, and input audio content blocks, and may include template strings.\\n" }), "range": Schema.optionalKey(Schema.Array(Schema.Number.check(Schema.isFinite())).annotate({ "description": "The range of the score. Defaults to \`[0, 1]\`." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ScoreModelGrader", "description": "A ScoreModelGrader object that uses a model to assign a score to the input.\\n", "identifier": "GraderScoreModel" })
export type ItemResource = InputMessageResource | OutputMessage | FileSearchToolCall | ComputerToolCall | ComputerToolCallOutputResource | WebSearchToolCall | FunctionToolCallResource | FunctionToolCallOutputResource | ImageGenToolCall | CodeInterpreterToolCall | LocalShellToolCall | LocalShellToolCallOutput | FunctionShellCall | FunctionShellCallOutput | ApplyPatchToolCall | ApplyPatchToolCallOutput | MCPListTools | MCPApprovalRequest | MCPApprovalResponseResource | MCPToolCall
export const ItemResource = Schema.Union([Schema.suspend((): Schema.Codec<InputMessageResource> => InputMessageResource), Schema.suspend((): Schema.Codec<OutputMessage> => OutputMessage), Schema.suspend((): Schema.Codec<FileSearchToolCall> => FileSearchToolCall), Schema.suspend((): Schema.Codec<ComputerToolCall> => ComputerToolCall), Schema.suspend((): Schema.Codec<ComputerToolCallOutputResource> => ComputerToolCallOutputResource), Schema.suspend((): Schema.Codec<WebSearchToolCall> => WebSearchToolCall), Schema.suspend((): Schema.Codec<FunctionToolCallResource> => FunctionToolCallResource), Schema.suspend((): Schema.Codec<FunctionToolCallOutputResource> => FunctionToolCallOutputResource), Schema.suspend((): Schema.Codec<ImageGenToolCall> => ImageGenToolCall), Schema.suspend((): Schema.Codec<CodeInterpreterToolCall> => CodeInterpreterToolCall), Schema.suspend((): Schema.Codec<LocalShellToolCall> => LocalShellToolCall), Schema.suspend((): Schema.Codec<LocalShellToolCallOutput> => LocalShellToolCallOutput), Schema.suspend((): Schema.Codec<FunctionShellCall> => FunctionShellCall), Schema.suspend((): Schema.Codec<FunctionShellCallOutput> => FunctionShellCallOutput), Schema.suspend((): Schema.Codec<ApplyPatchToolCall> => ApplyPatchToolCall), Schema.suspend((): Schema.Codec<ApplyPatchToolCallOutput> => ApplyPatchToolCallOutput), Schema.suspend((): Schema.Codec<MCPListTools> => MCPListTools), Schema.suspend((): Schema.Codec<MCPApprovalRequest> => MCPApprovalRequest), Schema.suspend((): Schema.Codec<MCPApprovalResponseResource> => MCPApprovalResponseResource), Schema.suspend((): Schema.Codec<MCPToolCall> => MCPToolCall)]).annotate({ "description": "Content item used to generate a response.\\n", "identifier": "ItemResource" })
export type OutputItem = OutputMessage | FileSearchToolCall | FunctionToolCall | WebSearchToolCall | ComputerToolCall | ReasoningItem | CompactionBody | ImageGenToolCall | CodeInterpreterToolCall | LocalShellToolCall | FunctionShellCall | FunctionShellCallOutput | ApplyPatchToolCall | ApplyPatchToolCallOutput | MCPToolCall | MCPListTools | MCPApprovalRequest | CustomToolCall
export const OutputItem = Schema.Union([Schema.suspend((): Schema.Codec<OutputMessage> => OutputMessage), Schema.suspend((): Schema.Codec<FileSearchToolCall> => FileSearchToolCall), Schema.suspend((): Schema.Codec<FunctionToolCall> => FunctionToolCall), Schema.suspend((): Schema.Codec<WebSearchToolCall> => WebSearchToolCall), Schema.suspend((): Schema.Codec<ComputerToolCall> => ComputerToolCall), Schema.suspend((): Schema.Codec<ReasoningItem> => ReasoningItem), CompactionBody, Schema.suspend((): Schema.Codec<ImageGenToolCall> => ImageGenToolCall), Schema.suspend((): Schema.Codec<CodeInterpreterToolCall> => CodeInterpreterToolCall), Schema.suspend((): Schema.Codec<LocalShellToolCall> => LocalShellToolCall), Schema.suspend((): Schema.Codec<FunctionShellCall> => FunctionShellCall), Schema.suspend((): Schema.Codec<FunctionShellCallOutput> => FunctionShellCallOutput), Schema.suspend((): Schema.Codec<ApplyPatchToolCall> => ApplyPatchToolCall), Schema.suspend((): Schema.Codec<ApplyPatchToolCallOutput> => ApplyPatchToolCallOutput), Schema.suspend((): Schema.Codec<MCPToolCall> => MCPToolCall), Schema.suspend((): Schema.Codec<MCPListTools> => MCPListTools), Schema.suspend((): Schema.Codec<MCPApprovalRequest> => MCPApprovalRequest), Schema.suspend((): Schema.Codec<CustomToolCall> => CustomToolCall)]).annotate({ "identifier": "OutputItem" })
export type CreateEvalCompletionsRunDataSource = { readonly "type": "completions", readonly "input_messages"?: { readonly "type": "template", readonly "template": ReadonlyArray<EasyInputMessage | EvalItem>, readonly [x: string]: unknown } | { readonly "type": "item_reference", readonly "item_reference": string, readonly [x: string]: unknown }, readonly "sampling_params"?: { readonly "reasoning_effort"?: ReasoningEffort, readonly "temperature"?: number, readonly "max_completion_tokens"?: number, readonly "top_p"?: number, readonly "seed"?: number, readonly "response_format"?: ResponseFormatText | ResponseFormatJsonSchema | ResponseFormatJsonObject, readonly "tools"?: ReadonlyArray<ChatCompletionTool>, readonly [x: string]: unknown }, readonly "model"?: string, readonly "source": EvalJsonlFileContentSource | EvalJsonlFileIdSource | EvalStoredCompletionsSource, readonly [x: string]: unknown }
export const CreateEvalCompletionsRunDataSource = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("completions").annotate({ "description": "The type of run data source. Always \`completions\`.", "default": "completions" }), "input_messages": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("template").annotate({ "description": "The type of input messages. Always \`template\`." }), "template": Schema.Array(Schema.Union([EasyInputMessage, EvalItem])).annotate({ "description": "A list of chat messages forming the prompt or context. May include variable references to the \`item\` namespace, ie {{item.name}}." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "TemplateInputMessages" }), Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("item_reference").annotate({ "description": "The type of input messages. Always \`item_reference\`." }), "item_reference": Schema.String.annotate({ "description": "A reference to a variable in the \`item\` namespace. Ie, \\"item.input_trajectory\\"" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ItemReferenceInputMessages" })]).annotate({ "description": "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, \`item.input_trajectory\`), or a template with variable references to the \`item\` namespace." })), "sampling_params": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "reasoning_effort": Schema.optionalKey(Schema.suspend((): Schema.Codec<ReasoningEffort> => ReasoningEffort)), "temperature": Schema.optionalKey(Schema.Number.annotate({ "description": "A higher temperature increases randomness in the outputs.", "default": 1 }).check(Schema.isFinite())), "max_completion_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum number of tokens in the generated output." }).check(Schema.isInt())), "top_p": Schema.optionalKey(Schema.Number.annotate({ "description": "An alternative to temperature for nucleus sampling; 1.0 includes all tokens.", "default": 1 }).check(Schema.isFinite())), "seed": Schema.optionalKey(Schema.Number.annotate({ "description": "A seed value to initialize the randomness, during sampling.", "default": 42 }).check(Schema.isInt())), "response_format": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ResponseFormatText> => ResponseFormatText), Schema.suspend((): Schema.Codec<ResponseFormatJsonSchema> => ResponseFormatJsonSchema), Schema.suspend((): Schema.Codec<ResponseFormatJsonObject> => ResponseFormatJsonObject)]).annotate({ "description": "An object specifying the format that the model must output.\\n\\nSetting to \`{ \\"type\\": \\"json_schema\\", \\"json_schema\\": {...} }\` enables\\nStructured Outputs which ensures the model will match your supplied JSON\\nschema. Learn more in the [Structured Outputs\\nguide](https://platform.openai.com/docs/guides/structured-outputs).\\n\\nSetting to \`{ \\"type\\": \\"json_object\\" }\` enables the older JSON mode, which\\nensures the message the model generates is valid JSON. Using \`json_schema\`\\nis preferred for models that support it.\\n" })), "tools": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<ChatCompletionTool> => ChatCompletionTool)).annotate({ "description": "A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "model": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the model to use for generating completions (e.g. \\"o3-mini\\")." })), "source": Schema.Union([EvalJsonlFileContentSource, EvalJsonlFileIdSource, EvalStoredCompletionsSource]).annotate({ "description": "Determines what populates the \`item\` namespace in this run's data source." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "CompletionsRunDataSource", "description": "A CompletionsRunDataSource object describing a model sampling configuration.\\n", "identifier": "CreateEvalCompletionsRunDataSource" })
export type InputItem = EasyInputMessage | unknown | ItemReferenceParam
export const InputItem = Schema.Union([Schema.suspend((): Schema.Codec<EasyInputMessage> => EasyInputMessage), Schema.Unknown.annotate({ "title": "Item", "description": "An item representing part of the context for the response to be\\ngenerated by the model. Can contain text, images, and audio inputs,\\nas well as previous assistant responses and tool call outputs.\\n" }), ItemReferenceParam]).annotate({ "identifier": "InputItem" })
export type Item = InputMessage | OutputMessage | FileSearchToolCall | ComputerToolCall | ComputerCallOutputItemParam | WebSearchToolCall | FunctionToolCall | FunctionCallOutputItemParam | ReasoningItem | CompactionSummaryItemParam | ImageGenToolCall | CodeInterpreterToolCall | LocalShellToolCall | LocalShellToolCallOutput | FunctionShellCallItemParam | FunctionShellCallOutputItemParam | ApplyPatchToolCallItemParam | ApplyPatchToolCallOutputItemParam | MCPListTools | MCPApprovalRequest | MCPApprovalResponse | MCPToolCall | CustomToolCallOutput | CustomToolCall
export const Item = Schema.Union([Schema.suspend((): Schema.Codec<InputMessage> => InputMessage), OutputMessage, Schema.suspend((): Schema.Codec<FileSearchToolCall> => FileSearchToolCall), Schema.suspend((): Schema.Codec<ComputerToolCall> => ComputerToolCall), ComputerCallOutputItemParam, Schema.suspend((): Schema.Codec<WebSearchToolCall> => WebSearchToolCall), Schema.suspend((): Schema.Codec<FunctionToolCall> => FunctionToolCall), FunctionCallOutputItemParam, Schema.suspend((): Schema.Codec<ReasoningItem> => ReasoningItem), CompactionSummaryItemParam, Schema.suspend((): Schema.Codec<ImageGenToolCall> => ImageGenToolCall), Schema.suspend((): Schema.Codec<CodeInterpreterToolCall> => CodeInterpreterToolCall), Schema.suspend((): Schema.Codec<LocalShellToolCall> => LocalShellToolCall), Schema.suspend((): Schema.Codec<LocalShellToolCallOutput> => LocalShellToolCallOutput), FunctionShellCallItemParam, FunctionShellCallOutputItemParam, ApplyPatchToolCallItemParam, ApplyPatchToolCallOutputItemParam, Schema.suspend((): Schema.Codec<MCPListTools> => MCPListTools), Schema.suspend((): Schema.Codec<MCPApprovalRequest> => MCPApprovalRequest), MCPApprovalResponse, Schema.suspend((): Schema.Codec<MCPToolCall> => MCPToolCall), Schema.suspend((): Schema.Codec<CustomToolCallOutput> => CustomToolCallOutput), Schema.suspend((): Schema.Codec<CustomToolCall> => CustomToolCall)]).annotate({ "description": "Content item used to generate a response.\\n", "identifier": "Item" })
export type RealtimeBetaClientEventResponseCreate = { readonly "event_id"?: string, readonly "type": "response.create", readonly "response"?: RealtimeBetaResponseCreateParams, readonly [x: string]: unknown }
export const RealtimeBetaClientEventResponseCreate = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("response.create").annotate({ "description": "The event type, must be \`response.create\`." }), "response": Schema.optionalKey(RealtimeBetaResponseCreateParams) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "This event instructs the server to create a Response, which means triggering \\nmodel inference. When in Server VAD mode, the server will create Responses \\nautomatically.\\n\\nA Response will include at least one Item, and may have two, in which case \\nthe second will be a function call. These Items will be appended to the \\nconversation history.\\n\\nThe server will respond with a \`response.created\` event, events for Items \\nand content created, and finally a \`response.done\` event to indicate the \\nResponse is complete.\\n\\nThe \`response.create\` event can optionally include inference configuration like \\n\`instructions\`, and \`temperature\`. These fields will override the Session's \\nconfiguration for this Response only.\\n\\nResponses can be created out-of-band of the default Conversation, meaning that they can\\nhave arbitrary input, and it's possible to disable writing the output to the Conversation.\\nOnly one Response can write to the default Conversation at a time, but otherwise multiple\\nResponses can be created in parallel.\\n\\nClients can set \`conversation\` to \`none\` to create a Response that does not write to the default\\nConversation. Arbitrary input can be provided with the \`input\` field, which is an array accepting\\nraw Items and references to existing Items.\\n", "identifier": "RealtimeBetaClientEventResponseCreate" })
export type RealtimeClientEventResponseCreate = { readonly "event_id"?: string, readonly "type": "response.create", readonly "response"?: RealtimeResponseCreateParams, readonly [x: string]: unknown }
export const RealtimeClientEventResponseCreate = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("response.create").annotate({ "description": "The event type, must be \`response.create\`." }), "response": Schema.optionalKey(RealtimeResponseCreateParams) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "This event instructs the server to create a Response, which means triggering \\nmodel inference. When in Server VAD mode, the server will create Responses \\nautomatically.\\n\\nA Response will include at least one Item, and may have two, in which case \\nthe second will be a function call. These Items will be appended to the \\nconversation history by default.\\n\\nThe server will respond with a \`response.created\` event, events for Items \\nand content created, and finally a \`response.done\` event to indicate the \\nResponse is complete.\\n\\nThe \`response.create\` event includes inference configuration like \\n\`instructions\` and \`tools\`. If these are set, they will override the Session's \\nconfiguration for this Response only.\\n\\nResponses can be created out-of-band of the default Conversation, meaning that they can\\nhave arbitrary input, and it's possible to disable writing the output to the Conversation.\\nOnly one Response can write to the default Conversation at a time, but otherwise multiple\\nResponses can be created in parallel. The \`metadata\` field is a good way to disambiguate\\nmultiple simultaneous Responses.\\n\\nClients can set \`conversation\` to \`none\` to create a Response that does not write to the default\\nConversation. Arbitrary input can be provided with the \`input\` field, which is an array accepting\\nraw Items and references to existing Items.\\n", "identifier": "RealtimeClientEventResponseCreate" })
export type RealtimeBetaServerEventSessionCreated = { readonly "event_id": string, readonly "type": "session.created", readonly "session": RealtimeSession, readonly [x: string]: unknown }
export const RealtimeBetaServerEventSessionCreated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("session.created").annotate({ "description": "The event type, must be \`session.created\`." }), "session": RealtimeSession }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a Session is created. Emitted automatically when a new\\nconnection is established as the first server event. This event will contain\\nthe default Session configuration.\\n", "identifier": "RealtimeBetaServerEventSessionCreated" })
export type RealtimeBetaServerEventSessionUpdated = { readonly "event_id": string, readonly "type": "session.updated", readonly "session": RealtimeSession, readonly [x: string]: unknown }
export const RealtimeBetaServerEventSessionUpdated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("session.updated").annotate({ "description": "The event type, must be \`session.updated\`." }), "session": Schema.suspend((): Schema.Codec<RealtimeSession> => RealtimeSession) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a session is updated with a \`session.update\` event, unless\\nthere is an error.\\n", "identifier": "RealtimeBetaServerEventSessionUpdated" })
export type RealtimeBetaClientEventSessionUpdate = { readonly "event_id"?: string, readonly "type": "session.update", readonly "session": RealtimeSessionCreateRequest, readonly [x: string]: unknown }
export const RealtimeBetaClientEventSessionUpdate = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event." })), "type": Schema.Literal("session.update").annotate({ "description": "The event type, must be \`session.update\`." }), "session": RealtimeSessionCreateRequest }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to update the sessions default configuration.\\nThe client may send this event at any time to update any field,\\nexcept for \`voice\`. However, note that once a session has been\\ninitialized with a particular \`model\`, it cant be changed to\\nanother model using \`session.update\`.\\n\\nWhen the server receives a \`session.update\`, it will respond\\nwith a \`session.updated\` event showing the full, effective configuration.\\nOnly the fields that are present are updated. To clear a field like\\n\`instructions\`, pass an empty string.\\n", "identifier": "RealtimeBetaClientEventSessionUpdate" })
export type RealtimeClientEventSessionUpdate = { readonly "event_id"?: string, readonly "type": "session.update", readonly "session": RealtimeSessionCreateRequestGA | RealtimeTranscriptionSessionCreateRequestGA, readonly [x: string]: unknown }
export const RealtimeClientEventSessionUpdate = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.optionalKey(Schema.String.annotate({ "description": "Optional client-generated ID used to identify this event. This is an arbitrary string that a client may assign. It will be passed back if there is an error with the event, but the corresponding \`session.updated\` event will not include it." })), "type": Schema.Literal("session.update").annotate({ "description": "The event type, must be \`session.update\`." }), "session": Schema.Union([Schema.suspend((): Schema.Codec<RealtimeSessionCreateRequestGA> => RealtimeSessionCreateRequestGA), RealtimeTranscriptionSessionCreateRequestGA]).annotate({ "description": "Update the Realtime session. Choose either a realtime\\nsession or a transcription session.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Send this event to update the sessions configuration.\\nThe client may send this event at any time to update any field\\nexcept for \`voice\` and \`model\`. \`voice\` can be updated only if there have been no other audio outputs yet.\\n\\nWhen the server receives a \`session.update\`, it will respond\\nwith a \`session.updated\` event showing the full, effective configuration.\\nOnly the fields that are present in the \`session.update\` are updated. To clear a field like\\n\`instructions\`, pass an empty string. To clear a field like \`tools\`, pass an empty array.\\nTo clear a field like \`turn_detection\`, pass \`null\`.\\n", "identifier": "RealtimeClientEventSessionUpdate" })
export type RealtimeCreateClientSecretRequest = { readonly "expires_after"?: { readonly "anchor"?: "created_at", readonly "seconds"?: number, readonly [x: string]: unknown }, readonly "session"?: RealtimeSessionCreateRequestGA | RealtimeTranscriptionSessionCreateRequestGA, readonly [x: string]: unknown }
export const RealtimeCreateClientSecretRequest = Schema.StructWithRest(Schema.Struct({ "expires_after": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "anchor": Schema.optionalKey(Schema.Literal("created_at").annotate({ "description": "The anchor point for the client secret expiration, meaning that \`seconds\` will be added to the \`created_at\` time of the client secret to produce an expiration timestamp. Only \`created_at\` is currently supported.\\n", "default": "created_at" })), "seconds": Schema.optionalKey(Schema.Number.annotate({ "description": "The number of seconds from the anchor point to the expiration. Select a value between \`10\` and \`7200\` (2 hours). This default to 600 seconds (10 minutes) if not specified.\\n", "default": 600 }).check(Schema.isInt())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Client secret expiration", "description": "Configuration for the client secret expiration. Expiration refers to the time after which\\na client secret will no longer be valid for creating sessions. The session itself may\\ncontinue after that time once started. A secret can be used to create multiple sessions\\nuntil it expires.\\n" })), "session": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<RealtimeSessionCreateRequestGA> => RealtimeSessionCreateRequestGA), Schema.suspend((): Schema.Codec<RealtimeTranscriptionSessionCreateRequestGA> => RealtimeTranscriptionSessionCreateRequestGA)]).annotate({ "title": "Session configuration", "description": "Session configuration to use for the client secret. Choose either a realtime\\nsession or a transcription session.\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime client secret creation request", "description": "Create a session and client secret for the Realtime API. The request can specify\\neither a realtime or a transcription session configuration.\\n[Learn more about the Realtime API](https://platform.openai.com/docs/guides/realtime).\\n", "identifier": "RealtimeCreateClientSecretRequest" })
export type RealtimeServerEventSessionCreated = { readonly "event_id": string, readonly "type": "session.created", readonly "session": RealtimeSessionCreateRequestGA | RealtimeTranscriptionSessionCreateRequestGA, readonly [x: string]: unknown }
export const RealtimeServerEventSessionCreated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("session.created").annotate({ "description": "The event type, must be \`session.created\`." }), "session": Schema.Union([Schema.suspend((): Schema.Codec<RealtimeSessionCreateRequestGA> => RealtimeSessionCreateRequestGA), Schema.suspend((): Schema.Codec<RealtimeTranscriptionSessionCreateRequestGA> => RealtimeTranscriptionSessionCreateRequestGA)]).annotate({ "description": "The session configuration." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a Session is created. Emitted automatically when a new\\nconnection is established as the first server event. This event will contain\\nthe default Session configuration.\\n", "identifier": "RealtimeServerEventSessionCreated" })
export type RealtimeServerEventSessionUpdated = { readonly "event_id": string, readonly "type": "session.updated", readonly "session": RealtimeSessionCreateRequestGA | RealtimeTranscriptionSessionCreateRequestGA, readonly [x: string]: unknown }
export const RealtimeServerEventSessionUpdated = Schema.StructWithRest(Schema.Struct({ "event_id": Schema.String.annotate({ "description": "The unique ID of the server event." }), "type": Schema.Literal("session.updated").annotate({ "description": "The event type, must be \`session.updated\`." }), "session": Schema.Union([Schema.suspend((): Schema.Codec<RealtimeSessionCreateRequestGA> => RealtimeSessionCreateRequestGA), Schema.suspend((): Schema.Codec<RealtimeTranscriptionSessionCreateRequestGA> => RealtimeTranscriptionSessionCreateRequestGA)]).annotate({ "description": "The session configuration." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Returned when a session is updated with a \`session.update\` event, unless\\nthere is an error.\\n", "identifier": "RealtimeServerEventSessionUpdated" })
export type RealtimeCreateClientSecretResponse = { readonly "value": string, readonly "expires_at": number, readonly "session": RealtimeSessionCreateResponseGA | RealtimeTranscriptionSessionCreateResponseGA, readonly [x: string]: unknown }
export const RealtimeCreateClientSecretResponse = Schema.StructWithRest(Schema.Struct({ "value": Schema.String.annotate({ "description": "The generated client secret value." }), "expires_at": Schema.Number.annotate({ "description": "Expiration timestamp for the client secret, in seconds since epoch." }).check(Schema.isInt()), "session": Schema.Union([RealtimeSessionCreateResponseGA, RealtimeTranscriptionSessionCreateResponseGA]).annotate({ "title": "Session configuration", "description": "The session configuration for either a realtime or transcription session.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Realtime session and client secret", "description": "Response from creating a session and client secret for the Realtime API.\\n", "identifier": "RealtimeCreateClientSecretResponse" })
export type ConversationItemList = { readonly "object": "list", readonly "data": ReadonlyArray<ConversationItem>, readonly "has_more": boolean, readonly "first_id": string, readonly "last_id": string, readonly [x: string]: unknown }
export const ConversationItemList = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be \`list\`." }), "data": Schema.Array(Schema.suspend((): Schema.Codec<ConversationItem> => ConversationItem)).annotate({ "description": "A list of conversation items." }), "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." }), "first_id": Schema.String.annotate({ "description": "The ID of the first item in the list." }), "last_id": Schema.String.annotate({ "description": "The ID of the last item in the list." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "The conversation item list", "description": "A list of Conversation items.", "identifier": "ConversationItemList" })
export type ThreadItemListResource = { readonly "object": "list", readonly "data": ReadonlyArray<ThreadItem>, readonly "first_id": string | null, readonly "last_id": string | null, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ThreadItemListResource = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be \`list\`.", "default": "list" }), "data": Schema.Array(Schema.suspend((): Schema.Codec<ThreadItem> => ThreadItem)).annotate({ "description": "A list of items" }), "first_id": Schema.Union([Schema.String.annotate({ "description": "The ID of the first item in the list." }), Schema.Null]), "last_id": Schema.Union([Schema.String.annotate({ "description": "The ID of the last item in the list." }), Schema.Null]), "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "Thread Items", "description": "A paginated list of thread items rendered for the ChatKit API.", "identifier": "ThreadItemListResource" })
export type Tool = FunctionTool | FileSearchTool | ComputerUsePreviewTool | WebSearchTool | MCPTool | CodeInterpreterTool | ImageGenTool | LocalShellToolParam | FunctionShellToolParam | CustomToolParam | WebSearchPreviewTool | ApplyPatchToolParam
export const Tool = Schema.Union([FunctionTool, FileSearchTool, ComputerUsePreviewTool, WebSearchTool, Schema.suspend((): Schema.Codec<MCPTool> => MCPTool), Schema.suspend((): Schema.Codec<CodeInterpreterTool> => CodeInterpreterTool), Schema.suspend((): Schema.Codec<ImageGenTool> => ImageGenTool), LocalShellToolParam, FunctionShellToolParam, CustomToolParam, WebSearchPreviewTool, ApplyPatchToolParam]).annotate({ "description": "A tool that can be used to generate a response.\\n", "identifier": "Tool" })
export type ListRunStepsResponse = { readonly "object": string, readonly "data": ReadonlyArray<RunStepObject>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const ListRunStepsResponse = Schema.StructWithRest(Schema.Struct({ "object": Schema.String, "data": Schema.Array(RunStepObject), "first_id": Schema.String, "last_id": Schema.String, "has_more": Schema.Boolean }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListRunStepsResponse" })
export type RunStepStreamEvent = { readonly "event": "thread.run.step.created", readonly "data": RunStepObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.step.in_progress", readonly "data": RunStepObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.step.delta", readonly "data": RunStepDeltaObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.step.completed", readonly "data": RunStepObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.step.failed", readonly "data": RunStepObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.step.cancelled", readonly "data": RunStepObject, readonly [x: string]: unknown } | { readonly "event": "thread.run.step.expired", readonly "data": RunStepObject, readonly [x: string]: unknown }
export const RunStepStreamEvent = Schema.Union([Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.step.created"), "data": Schema.suspend((): Schema.Codec<RunStepObject> => RunStepObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is created." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.step.in_progress"), "data": Schema.suspend((): Schema.Codec<RunStepObject> => RunStepObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) moves to an \`in_progress\` state." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.step.delta"), "data": Schema.suspend((): Schema.Codec<RunStepDeltaObject> => RunStepDeltaObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when parts of a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) are being streamed." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.step.completed"), "data": Schema.suspend((): Schema.Codec<RunStepObject> => RunStepObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is completed." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.step.failed"), "data": Schema.suspend((): Schema.Codec<RunStepObject> => RunStepObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) fails." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.step.cancelled"), "data": Schema.suspend((): Schema.Codec<RunStepObject> => RunStepObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is cancelled." }), Schema.StructWithRest(Schema.Struct({ "event": Schema.Literal("thread.run.step.expired"), "data": Schema.suspend((): Schema.Codec<RunStepObject> => RunStepObject) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) expires." })]).annotate({ "identifier": "RunStepStreamEvent" })
export type CreateEvalLabelModelGrader = { readonly "type": "label_model", readonly "name": string, readonly "model": string, readonly "input": ReadonlyArray<CreateEvalItem>, readonly "labels": ReadonlyArray<string>, readonly "passing_labels": ReadonlyArray<string>, readonly [x: string]: unknown }
export const CreateEvalLabelModelGrader = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("label_model").annotate({ "description": "The object type, which is always \`label_model\`." }), "name": Schema.String.annotate({ "description": "The name of the grader." }), "model": Schema.String.annotate({ "description": "The model to use for the evaluation. Must support structured outputs." }), "input": Schema.Array(Schema.suspend((): Schema.Codec<CreateEvalItem> => CreateEvalItem)).annotate({ "description": "A list of chat messages forming the prompt or context. May include variable references to the \`item\` namespace, ie {{item.name}}." }), "labels": Schema.Array(Schema.String).annotate({ "description": "The labels to classify to each item in the evaluation." }), "passing_labels": Schema.Array(Schema.String).annotate({ "description": "The labels that indicate a passing result. Must be a subset of labels." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "LabelModelGrader", "description": "A LabelModelGrader object which uses a model to assign labels to each item\\nin the evaluation.\\n", "identifier": "CreateEvalLabelModelGrader" })
export type GraderMulti = { readonly "type": "multi", readonly "name": string, readonly "graders": GraderStringCheck | GraderTextSimilarity | GraderPython | GraderScoreModel | GraderLabelModel, readonly "calculate_output": string, readonly [x: string]: unknown }
export const GraderMulti = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("multi").annotate({ "description": "The object type, which is always \`multi\`.", "default": "multi" }), "name": Schema.String.annotate({ "description": "The name of the grader." }), "graders": Schema.Union([Schema.suspend((): Schema.Codec<GraderStringCheck> => GraderStringCheck), Schema.suspend((): Schema.Codec<GraderTextSimilarity> => GraderTextSimilarity), Schema.suspend((): Schema.Codec<GraderPython> => GraderPython), Schema.suspend((): Schema.Codec<GraderScoreModel> => GraderScoreModel), Schema.suspend((): Schema.Codec<GraderLabelModel> => GraderLabelModel)]), "calculate_output": Schema.String.annotate({ "description": "A formula to calculate the output based on grader results." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "MultiGrader", "description": "A MultiGrader object combines the output of multiple graders to produce a single score.", "identifier": "GraderMulti" })
export type ResponseItemList = { readonly "object": "list", readonly "data": ReadonlyArray<ItemResource>, readonly "has_more": boolean, readonly "first_id": string, readonly "last_id": string, readonly [x: string]: unknown }
export const ResponseItemList = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of object returned, must be \`list\`." }), "data": Schema.Array(Schema.suspend((): Schema.Codec<ItemResource> => ItemResource)).annotate({ "description": "A list of items used to generate this response." }), "has_more": Schema.Boolean.annotate({ "description": "Whether there are more items available." }), "first_id": Schema.String.annotate({ "description": "The ID of the first item in the list." }), "last_id": Schema.String.annotate({ "description": "The ID of the last item in the list." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A list of Response items.", "identifier": "ResponseItemList" })
export type ResponseOutputItemAddedEvent = { readonly "type": "response.output_item.added", readonly "output_index": number, readonly "sequence_number": number, readonly "item": OutputItem, readonly [x: string]: unknown }
export const ResponseOutputItemAddedEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.output_item.added").annotate({ "description": "The type of the event. Always \`response.output_item.added\`.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that was added.\\n" }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\\n" }).check(Schema.isInt()), "item": Schema.suspend((): Schema.Codec<OutputItem> => OutputItem).annotate({ "description": "The output item that was added.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when a new output item is added.", "identifier": "ResponseOutputItemAddedEvent" })
export type ResponseOutputItemDoneEvent = { readonly "type": "response.output_item.done", readonly "output_index": number, readonly "sequence_number": number, readonly "item": OutputItem, readonly [x: string]: unknown }
export const ResponseOutputItemDoneEvent = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("response.output_item.done").annotate({ "description": "The type of the event. Always \`response.output_item.done\`.\\n" }), "output_index": Schema.Number.annotate({ "description": "The index of the output item that was marked done.\\n" }).check(Schema.isInt()), "sequence_number": Schema.Number.annotate({ "description": "The sequence number of this event.\\n" }).check(Schema.isInt()), "item": Schema.suspend((): Schema.Codec<OutputItem> => OutputItem).annotate({ "description": "The output item that was marked done.\\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Emitted when an output item is marked done.", "identifier": "ResponseOutputItemDoneEvent" })
export type CompactResource = { readonly "id": string, readonly "object": "response.compaction", readonly "output": ReadonlyArray<OutputItem>, readonly "created_at": number, readonly "usage": ResponseUsage, readonly [x: string]: unknown }
export const CompactResource = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The unique identifier for the compacted response." }), "object": Schema.Literal("response.compaction").annotate({ "description": "The object type. Always \`response.compaction\`.", "default": "response.compaction" }), "output": Schema.Array(Schema.suspend((): Schema.Codec<OutputItem> => OutputItem)).annotate({ "description": "The compacted list of output items. This is a list of all user messages, followed by a single compaction item." }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the compacted conversation was created." }).check(Schema.isInt()), "usage": Schema.suspend((): Schema.Codec<ResponseUsage> => ResponseUsage).annotate({ "description": "Token accounting for the compaction pass, including cached, reasoning, and total tokens." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "The compacted response object", "identifier": "CompactResource" })
export type InputParam = string | ReadonlyArray<InputItem>
export const InputParam = Schema.Union([Schema.String.annotate({ "title": "Text input", "description": "A text input to the model, equivalent to a text input with the\\n\`user\` role.\\n" }), Schema.Array(Schema.suspend((): Schema.Codec<InputItem> => InputItem)).annotate({ "title": "Input item list", "description": "A list of one or many input items to the model, containing\\ndifferent content types.\\n" })]).annotate({ "description": "Text, image, or file inputs to the model, used to generate a response.\\n\\nLearn more:\\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\\n- [Image inputs](https://platform.openai.com/docs/guides/images)\\n- [File inputs](https://platform.openai.com/docs/guides/pdf-files)\\n- [Conversation state](https://platform.openai.com/docs/guides/conversation-state)\\n- [Function calling](https://platform.openai.com/docs/guides/function-calling)\\n", "identifier": "InputParam" })
export type CreateConversationBody = { readonly "metadata"?: Metadata | null, readonly "items"?: ReadonlyArray<InputItem> | null, readonly [x: string]: unknown }
export const CreateConversationBody = Schema.StructWithRest(Schema.Struct({ "metadata": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<Metadata> => Metadata).annotate({ "description": "Set of 16 key-value pairs that can be attached to an object. This can be         useful for storing additional information about the object in a structured         format, and querying for objects via API or the dashboard.\\n        Keys are strings with a maximum length of 64 characters. Values are strings         with a maximum length of 512 characters." }), Schema.Null])), "items": Schema.optionalKey(Schema.Union([Schema.Array(Schema.suspend((): Schema.Codec<InputItem> => InputItem)).annotate({ "description": "Initial items to include in the conversation context. You may add up to 20 items at a time." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateConversationBody" })
export type CompactResponseMethodPublicBody = { readonly "model": ModelIdsCompaction, readonly "input"?: string | ReadonlyArray<InputItem> | null, readonly "previous_response_id"?: string | null, readonly "instructions"?: string | null, readonly [x: string]: unknown }
export const CompactResponseMethodPublicBody = Schema.StructWithRest(Schema.Struct({ "model": Schema.suspend((): Schema.Codec<ModelIdsCompaction> => ModelIdsCompaction), "input": Schema.optionalKey(Schema.Union([Schema.Union([Schema.String.annotate({ "description": "A text input to the model, equivalent to a text input with the \`user\` role." }), Schema.Array(Schema.suspend((): Schema.Codec<InputItem> => InputItem))]).annotate({ "description": "Text, image, or file inputs to the model, used to generate a response" }), Schema.Null])), "previous_response_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The unique ID of the previous response to the model. Use this to create multi-turn conversations. Learn more about [conversation state](https://platform.openai.com/docs/guides/conversation-state). Cannot be used in conjunction with \`conversation\`." }), Schema.Null])), "instructions": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "A system (or developer) message inserted into the model's context.\\nWhen used along with \`previous_response_id\`, the instructions from a previous response will not be carried over to the next response. This makes it simple to swap out system (or developer) messages in new responses." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CompactResponseMethodPublicBody" })
export type RealtimeClientEvent = RealtimeClientEventConversationItemCreate | RealtimeClientEventConversationItemDelete | RealtimeClientEventConversationItemRetrieve | RealtimeClientEventConversationItemTruncate | RealtimeClientEventInputAudioBufferAppend | RealtimeClientEventInputAudioBufferClear | RealtimeClientEventOutputAudioBufferClear | RealtimeClientEventInputAudioBufferCommit | RealtimeClientEventResponseCancel | RealtimeClientEventResponseCreate | RealtimeClientEventSessionUpdate
export const RealtimeClientEvent = Schema.Union([RealtimeClientEventConversationItemCreate, RealtimeClientEventConversationItemDelete, RealtimeClientEventConversationItemRetrieve, RealtimeClientEventConversationItemTruncate, RealtimeClientEventInputAudioBufferAppend, RealtimeClientEventInputAudioBufferClear, RealtimeClientEventOutputAudioBufferClear, RealtimeClientEventInputAudioBufferCommit, RealtimeClientEventResponseCancel, RealtimeClientEventResponseCreate, RealtimeClientEventSessionUpdate]).annotate({ "description": "A realtime client event.\\n", "identifier": "RealtimeClientEvent" })
export type RealtimeServerEvent = RealtimeServerEventConversationCreated | RealtimeServerEventConversationItemCreated | RealtimeServerEventConversationItemDeleted | RealtimeServerEventConversationItemInputAudioTranscriptionCompleted | RealtimeServerEventConversationItemInputAudioTranscriptionDelta | RealtimeServerEventConversationItemInputAudioTranscriptionFailed | RealtimeServerEventConversationItemRetrieved | RealtimeServerEventConversationItemTruncated | RealtimeServerEventError | RealtimeServerEventInputAudioBufferCleared | RealtimeServerEventInputAudioBufferCommitted | RealtimeServerEventInputAudioBufferDtmfEventReceived | RealtimeServerEventInputAudioBufferSpeechStarted | RealtimeServerEventInputAudioBufferSpeechStopped | RealtimeServerEventRateLimitsUpdated | RealtimeServerEventResponseAudioDelta | RealtimeServerEventResponseAudioDone | RealtimeServerEventResponseAudioTranscriptDelta | RealtimeServerEventResponseAudioTranscriptDone | RealtimeServerEventResponseContentPartAdded | RealtimeServerEventResponseContentPartDone | RealtimeServerEventResponseCreated | RealtimeServerEventResponseDone | RealtimeServerEventResponseFunctionCallArgumentsDelta | RealtimeServerEventResponseFunctionCallArgumentsDone | RealtimeServerEventResponseOutputItemAdded | RealtimeServerEventResponseOutputItemDone | RealtimeServerEventResponseTextDelta | RealtimeServerEventResponseTextDone | RealtimeServerEventSessionCreated | RealtimeServerEventSessionUpdated | RealtimeServerEventOutputAudioBufferStarted | RealtimeServerEventOutputAudioBufferStopped | RealtimeServerEventOutputAudioBufferCleared | RealtimeServerEventConversationItemAdded | RealtimeServerEventConversationItemDone | RealtimeServerEventInputAudioBufferTimeoutTriggered | RealtimeServerEventConversationItemInputAudioTranscriptionSegment | RealtimeServerEventMCPListToolsInProgress | RealtimeServerEventMCPListToolsCompleted | RealtimeServerEventMCPListToolsFailed | RealtimeServerEventResponseMCPCallArgumentsDelta | RealtimeServerEventResponseMCPCallArgumentsDone | RealtimeServerEventResponseMCPCallInProgress | RealtimeServerEventResponseMCPCallCompleted | RealtimeServerEventResponseMCPCallFailed
export const RealtimeServerEvent = Schema.Union([RealtimeServerEventConversationCreated, RealtimeServerEventConversationItemCreated, RealtimeServerEventConversationItemDeleted, RealtimeServerEventConversationItemInputAudioTranscriptionCompleted, RealtimeServerEventConversationItemInputAudioTranscriptionDelta, RealtimeServerEventConversationItemInputAudioTranscriptionFailed, RealtimeServerEventConversationItemRetrieved, RealtimeServerEventConversationItemTruncated, RealtimeServerEventError, RealtimeServerEventInputAudioBufferCleared, RealtimeServerEventInputAudioBufferCommitted, RealtimeServerEventInputAudioBufferDtmfEventReceived, RealtimeServerEventInputAudioBufferSpeechStarted, RealtimeServerEventInputAudioBufferSpeechStopped, RealtimeServerEventRateLimitsUpdated, RealtimeServerEventResponseAudioDelta, RealtimeServerEventResponseAudioDone, RealtimeServerEventResponseAudioTranscriptDelta, RealtimeServerEventResponseAudioTranscriptDone, RealtimeServerEventResponseContentPartAdded, RealtimeServerEventResponseContentPartDone, RealtimeServerEventResponseCreated, RealtimeServerEventResponseDone, RealtimeServerEventResponseFunctionCallArgumentsDelta, RealtimeServerEventResponseFunctionCallArgumentsDone, RealtimeServerEventResponseOutputItemAdded, RealtimeServerEventResponseOutputItemDone, RealtimeServerEventResponseTextDelta, RealtimeServerEventResponseTextDone, RealtimeServerEventSessionCreated, RealtimeServerEventSessionUpdated, RealtimeServerEventOutputAudioBufferStarted, RealtimeServerEventOutputAudioBufferStopped, RealtimeServerEventOutputAudioBufferCleared, RealtimeServerEventConversationItemAdded, RealtimeServerEventConversationItemDone, RealtimeServerEventInputAudioBufferTimeoutTriggered, RealtimeServerEventConversationItemInputAudioTranscriptionSegment, RealtimeServerEventMCPListToolsInProgress, RealtimeServerEventMCPListToolsCompleted, RealtimeServerEventMCPListToolsFailed, RealtimeServerEventResponseMCPCallArgumentsDelta, RealtimeServerEventResponseMCPCallArgumentsDone, RealtimeServerEventResponseMCPCallInProgress, RealtimeServerEventResponseMCPCallCompleted, RealtimeServerEventResponseMCPCallFailed]).annotate({ "description": "A realtime server event.\\n", "identifier": "RealtimeServerEvent" })
export type CreateEvalResponsesRunDataSource = { readonly "type": "responses", readonly "input_messages"?: { readonly "type": "template", readonly "template": ReadonlyArray<{ readonly "role": string, readonly "content": string, readonly [x: string]: unknown } | EvalItem>, readonly [x: string]: unknown } | { readonly "type": "item_reference", readonly "item_reference": string, readonly [x: string]: unknown }, readonly "sampling_params"?: { readonly "reasoning_effort"?: ReasoningEffort, readonly "temperature"?: number, readonly "max_completion_tokens"?: number, readonly "top_p"?: number, readonly "seed"?: number, readonly "tools"?: ReadonlyArray<Tool>, readonly "text"?: { readonly "format"?: TextResponseFormatConfiguration, readonly [x: string]: unknown }, readonly [x: string]: unknown }, readonly "model"?: string, readonly "source": EvalJsonlFileContentSource | EvalJsonlFileIdSource | EvalResponsesSource, readonly [x: string]: unknown }
export const CreateEvalResponsesRunDataSource = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("responses").annotate({ "description": "The type of run data source. Always \`responses\`.", "default": "responses" }), "input_messages": Schema.optionalKey(Schema.Union([Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("template").annotate({ "description": "The type of input messages. Always \`template\`." }), "template": Schema.Array(Schema.Union([Schema.StructWithRest(Schema.Struct({ "role": Schema.String.annotate({ "description": "The role of the message (e.g. \\"system\\", \\"assistant\\", \\"user\\")." }), "content": Schema.String.annotate({ "description": "The content of the message." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ChatMessage" }), Schema.suspend((): Schema.Codec<EvalItem> => EvalItem)])).annotate({ "description": "A list of chat messages forming the prompt or context. May include variable references to the \`item\` namespace, ie {{item.name}}." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "InputMessagesTemplate" }), Schema.StructWithRest(Schema.Struct({ "type": Schema.Literal("item_reference").annotate({ "description": "The type of input messages. Always \`item_reference\`." }), "item_reference": Schema.String.annotate({ "description": "A reference to a variable in the \`item\` namespace. Ie, \\"item.name\\"" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "InputMessagesItemReference" })]).annotate({ "description": "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, \`item.input_trajectory\`), or a template with variable references to the \`item\` namespace." })), "sampling_params": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "reasoning_effort": Schema.optionalKey(Schema.suspend((): Schema.Codec<ReasoningEffort> => ReasoningEffort)), "temperature": Schema.optionalKey(Schema.Number.annotate({ "description": "A higher temperature increases randomness in the outputs.", "default": 1 }).check(Schema.isFinite())), "max_completion_tokens": Schema.optionalKey(Schema.Number.annotate({ "description": "The maximum number of tokens in the generated output." }).check(Schema.isInt())), "top_p": Schema.optionalKey(Schema.Number.annotate({ "description": "An alternative to temperature for nucleus sampling; 1.0 includes all tokens.", "default": 1 }).check(Schema.isFinite())), "seed": Schema.optionalKey(Schema.Number.annotate({ "description": "A seed value to initialize the randomness, during sampling.", "default": 42 }).check(Schema.isInt())), "tools": Schema.optionalKey(Schema.Array(Tool).annotate({ "description": "An array of tools the model may call while generating a response. You\\ncan specify which tool to use by setting the \`tool_choice\` parameter.\\n\\nThe two categories of tools you can provide the model are:\\n\\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\\n  model's capabilities, like [web search](https://platform.openai.com/docs/guides/tools-web-search)\\n  or [file search](https://platform.openai.com/docs/guides/tools-file-search). Learn more about\\n  [built-in tools](https://platform.openai.com/docs/guides/tools).\\n- **Function calls (custom tools)**: Functions that are defined by you,\\n  enabling the model to call your own code. Learn more about\\n  [function calling](https://platform.openai.com/docs/guides/function-calling).\\n" })), "text": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "format": Schema.optionalKey(TextResponseFormatConfiguration) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration options for a text response from the model. Can be plain\\ntext or structured JSON data. Learn more:\\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\\n" })) }), [Schema.Record(Schema.String, Schema.Unknown)])), "model": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the model to use for generating completions (e.g. \\"o3-mini\\")." })), "source": Schema.Union([Schema.suspend((): Schema.Codec<EvalJsonlFileContentSource> => EvalJsonlFileContentSource), Schema.suspend((): Schema.Codec<EvalJsonlFileIdSource> => EvalJsonlFileIdSource), EvalResponsesSource]).annotate({ "description": "Determines what populates the \`item\` namespace in this run's data source." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "CreateEvalResponsesRunDataSource", "description": "A ResponsesRunDataSource object describing a model sampling configuration.\\n", "identifier": "CreateEvalResponsesRunDataSource" })
export type ToolsArray = ReadonlyArray<Tool>
export const ToolsArray = Schema.Array(Schema.suspend((): Schema.Codec<Tool> => Tool)).annotate({ "description": "An array of tools the model may call while generating a response. You\\ncan specify which tool to use by setting the \`tool_choice\` parameter.\\n\\nWe support the following categories of tools:\\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\\n  model's capabilities, like [web search](https://platform.openai.com/docs/guides/tools-web-search)\\n  or [file search](https://platform.openai.com/docs/guides/tools-file-search). Learn more about\\n  [built-in tools](https://platform.openai.com/docs/guides/tools).\\n- **MCP Tools**: Integrations with third-party systems via custom MCP servers\\n  or predefined connectors such as Google Drive and SharePoint. Learn more about\\n  [MCP Tools](https://platform.openai.com/docs/guides/tools-connectors-mcp).\\n- **Function calls (custom tools)**: Functions that are defined by you,\\n  enabling the model to call your own code with strongly typed arguments\\n  and outputs. Learn more about\\n  [function calling](https://platform.openai.com/docs/guides/function-calling). You can also use\\n  custom tools to call your own code.\\n", "identifier": "ToolsArray" })
export type TokenCountsBody = { readonly "model"?: string | null, readonly "input"?: string | ReadonlyArray<InputItem> | null, readonly "previous_response_id"?: string | null, readonly "tools"?: ReadonlyArray<Tool> | null, readonly "text"?: ResponseTextParam | null, readonly "reasoning"?: Reasoning | null, readonly "truncation"?: TruncationEnum, readonly "instructions"?: string | null, readonly "conversation"?: ConversationParam | null, readonly "tool_choice"?: ToolChoiceParam | null, readonly "parallel_tool_calls"?: boolean | null, readonly [x: string]: unknown }
export const TokenCountsBody = Schema.StructWithRest(Schema.Struct({ "model": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "Model ID used to generate the response, like \`gpt-4o\` or \`o3\`. OpenAI offers a wide range of models with different capabilities, performance characteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models) to browse and compare available models." }), Schema.Null])), "input": Schema.optionalKey(Schema.Union([Schema.Union([Schema.String.annotate({ "description": "A text input to the model, equivalent to a text input with the \`user\` role." }), Schema.Array(Schema.suspend((): Schema.Codec<InputItem> => InputItem))]).annotate({ "description": "Text, image, or file inputs to the model, used to generate a response" }), Schema.Null])), "previous_response_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The unique ID of the previous response to the model. Use this to create multi-turn conversations. Learn more about [conversation state](https://platform.openai.com/docs/guides/conversation-state). Cannot be used in conjunction with \`conversation\`." }), Schema.Null])), "tools": Schema.optionalKey(Schema.Union([Schema.Array(Schema.suspend((): Schema.Codec<Tool> => Tool)).annotate({ "description": "An array of tools the model may call while generating a response. You can specify which tool to use by setting the \`tool_choice\` parameter." }), Schema.Null])), "text": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ResponseTextParam> => ResponseTextParam), Schema.Null])), "reasoning": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<Reasoning> => Reasoning).annotate({ "description": "**gpt-5 and o-series models only** Configuration options for [reasoning models](https://platform.openai.com/docs/guides/reasoning)." }), Schema.Null])), "truncation": Schema.optionalKey(Schema.suspend((): Schema.Codec<TruncationEnum> => TruncationEnum).annotate({ "description": "The truncation strategy to use for the model response. - \`auto\`: If the input to this Response exceeds the model's context window size, the model will truncate the response to fit the context window by dropping items from the beginning of the conversation. - \`disabled\` (default): If the input size will exceed the context window size for a model, the request will fail with a 400 error." })), "instructions": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "A system (or developer) message inserted into the model's context.\\nWhen used along with \`previous_response_id\`, the instructions from a previous response will not be carried over to the next response. This makes it simple to swap out system (or developer) messages in new responses." }), Schema.Null])), "conversation": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ConversationParam> => ConversationParam), Schema.Null])), "tool_choice": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<ToolChoiceParam> => ToolChoiceParam), Schema.Null])), "parallel_tool_calls": Schema.optionalKey(Schema.Union([Schema.Boolean.annotate({ "description": "Whether to allow the model to run tool calls in parallel." }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "TokenCountsBody" })
export type AssistantStreamEvent = ThreadStreamEvent | RunStreamEvent | RunStepStreamEvent | MessageStreamEvent | ErrorEvent
export const AssistantStreamEvent = Schema.Union([ThreadStreamEvent, RunStreamEvent, RunStepStreamEvent, MessageStreamEvent, ErrorEvent]).annotate({ "description": "Represents an event emitted when streaming a Run.\\n\\nEach event in a server-sent events stream has an \`event\` and \`data\` property:\\n\\n\`\`\`\\nevent: thread.created\\ndata: {\\"id\\": \\"thread_123\\", \\"object\\": \\"thread\\", ...}\\n\`\`\`\\n\\nWe emit events whenever a new object is created, transitions to a new state, or is being\\nstreamed in parts (deltas). For example, we emit \`thread.run.created\` when a new run\\nis created, \`thread.run.completed\` when a run completes, and so on. When an Assistant chooses\\nto create a message during a run, we emit a \`thread.message.created event\`, a\\n\`thread.message.in_progress\` event, many \`thread.message.delta\` events, and finally a\\n\`thread.message.completed\` event.\\n\\nWe may add additional events over time, so we recommend handling unknown events gracefully\\nin your code. See the [Assistants API quickstart](https://platform.openai.com/docs/assistants/overview) to learn how to\\nintegrate the Assistants API with streaming.\\n", "identifier": "AssistantStreamEvent" })
export type CreateEvalRequest = { readonly "name"?: string, readonly "metadata"?: Metadata, readonly "data_source_config": CreateEvalCustomDataSourceConfig | CreateEvalLogsDataSourceConfig | CreateEvalStoredCompletionsDataSourceConfig, readonly "testing_criteria": ReadonlyArray<CreateEvalLabelModelGrader | EvalGraderStringCheck | EvalGraderTextSimilarity | EvalGraderPython | EvalGraderScoreModel>, readonly [x: string]: unknown }
export const CreateEvalRequest = Schema.StructWithRest(Schema.Struct({ "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the evaluation." })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "data_source_config": Schema.Union([Schema.suspend((): Schema.Codec<CreateEvalCustomDataSourceConfig> => CreateEvalCustomDataSourceConfig), Schema.suspend((): Schema.Codec<CreateEvalLogsDataSourceConfig> => CreateEvalLogsDataSourceConfig), CreateEvalStoredCompletionsDataSourceConfig]).annotate({ "description": "The configuration for the data source used for the evaluation runs. Dictates the schema of the data used in the evaluation." }), "testing_criteria": Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<CreateEvalLabelModelGrader> => CreateEvalLabelModelGrader), EvalGraderStringCheck, EvalGraderTextSimilarity, EvalGraderPython, EvalGraderScoreModel])).annotate({ "description": "A list of graders for all eval runs in this group. Graders can reference variables in the data source using double curly braces notation, like \`{{item.variable_name}}\`. To reference the model's output, use the \`sample\` namespace (ie, \`{{sample.output_text}}\`)." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "CreateEvalRequest", "identifier": "CreateEvalRequest" })
export type FineTuneReinforcementMethod = { readonly "grader": GraderStringCheck | GraderTextSimilarity | GraderPython | GraderScoreModel | GraderMulti, readonly "hyperparameters"?: FineTuneReinforcementHyperparameters, readonly [x: string]: unknown }
export const FineTuneReinforcementMethod = Schema.StructWithRest(Schema.Struct({ "grader": Schema.Union([Schema.suspend((): Schema.Codec<GraderStringCheck> => GraderStringCheck), Schema.suspend((): Schema.Codec<GraderTextSimilarity> => GraderTextSimilarity), Schema.suspend((): Schema.Codec<GraderPython> => GraderPython), Schema.suspend((): Schema.Codec<GraderScoreModel> => GraderScoreModel), GraderMulti]).annotate({ "description": "The grader used for the fine-tuning job." }), "hyperparameters": Schema.optionalKey(Schema.suspend((): Schema.Codec<FineTuneReinforcementHyperparameters> => FineTuneReinforcementHyperparameters)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Configuration for the reinforcement fine-tuning method.", "identifier": "FineTuneReinforcementMethod" })
export type RunGraderRequest = { readonly "grader": GraderStringCheck | GraderTextSimilarity | GraderPython | GraderScoreModel | GraderMulti, readonly "item"?: { readonly [x: string]: unknown }, readonly "model_sample": string, readonly [x: string]: unknown }
export const RunGraderRequest = Schema.StructWithRest(Schema.Struct({ "grader": Schema.Union([Schema.suspend((): Schema.Codec<GraderStringCheck> => GraderStringCheck), Schema.suspend((): Schema.Codec<GraderTextSimilarity> => GraderTextSimilarity), Schema.suspend((): Schema.Codec<GraderPython> => GraderPython), Schema.suspend((): Schema.Codec<GraderScoreModel> => GraderScoreModel), Schema.suspend((): Schema.Codec<GraderMulti> => GraderMulti)]).annotate({ "description": "The grader used for the fine-tuning job." }), "item": Schema.optionalKey(Schema.Record(Schema.String, Schema.Unknown).annotate({ "description": "The dataset item provided to the grader. This will be used to populate \\nthe \`item\` namespace. See [the guide](https://platform.openai.com/docs/guides/graders) for more details. \\n" })), "model_sample": Schema.String.annotate({ "description": "The model sample to be evaluated. This value will be used to populate \\nthe \`sample\` namespace. See [the guide](https://platform.openai.com/docs/guides/graders) for more details.\\nThe \`output_json\` variable will be populated if the model sample is a \\nvalid JSON string.\\n \\n" }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "RunGraderRequest", "identifier": "RunGraderRequest" })
export type ValidateGraderRequest = { readonly "grader": GraderStringCheck | GraderTextSimilarity | GraderPython | GraderScoreModel | GraderMulti, readonly [x: string]: unknown }
export const ValidateGraderRequest = Schema.StructWithRest(Schema.Struct({ "grader": Schema.Union([Schema.suspend((): Schema.Codec<GraderStringCheck> => GraderStringCheck), Schema.suspend((): Schema.Codec<GraderTextSimilarity> => GraderTextSimilarity), Schema.suspend((): Schema.Codec<GraderPython> => GraderPython), Schema.suspend((): Schema.Codec<GraderScoreModel> => GraderScoreModel), Schema.suspend((): Schema.Codec<GraderMulti> => GraderMulti)]).annotate({ "description": "The grader used for the fine-tuning job." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ValidateGraderRequest", "identifier": "ValidateGraderRequest" })
export type ValidateGraderResponse = { readonly "grader"?: GraderStringCheck | GraderTextSimilarity | GraderPython | GraderScoreModel | GraderMulti, readonly [x: string]: unknown }
export const ValidateGraderResponse = Schema.StructWithRest(Schema.Struct({ "grader": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<GraderStringCheck> => GraderStringCheck), Schema.suspend((): Schema.Codec<GraderTextSimilarity> => GraderTextSimilarity), Schema.suspend((): Schema.Codec<GraderPython> => GraderPython), Schema.suspend((): Schema.Codec<GraderScoreModel> => GraderScoreModel), Schema.suspend((): Schema.Codec<GraderMulti> => GraderMulti)]).annotate({ "description": "The grader used for the fine-tuning job." })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "ValidateGraderResponse", "identifier": "ValidateGraderResponse" })
export type ResponseStreamEvent = ResponseAudioDeltaEvent | ResponseAudioDoneEvent | ResponseAudioTranscriptDeltaEvent | ResponseAudioTranscriptDoneEvent | ResponseCodeInterpreterCallCodeDeltaEvent | ResponseCodeInterpreterCallCodeDoneEvent | ResponseCodeInterpreterCallCompletedEvent | ResponseCodeInterpreterCallInProgressEvent | ResponseCodeInterpreterCallInterpretingEvent | ResponseCompletedEvent | ResponseContentPartAddedEvent | ResponseContentPartDoneEvent | ResponseCreatedEvent | ResponseErrorEvent | ResponseFileSearchCallCompletedEvent | ResponseFileSearchCallInProgressEvent | ResponseFileSearchCallSearchingEvent | ResponseFunctionCallArgumentsDeltaEvent | ResponseFunctionCallArgumentsDoneEvent | ResponseInProgressEvent | ResponseFailedEvent | ResponseIncompleteEvent | ResponseOutputItemAddedEvent | ResponseOutputItemDoneEvent | ResponseReasoningSummaryPartAddedEvent | ResponseReasoningSummaryPartDoneEvent | ResponseReasoningSummaryTextDeltaEvent | ResponseReasoningSummaryTextDoneEvent | ResponseReasoningTextDeltaEvent | ResponseReasoningTextDoneEvent | ResponseRefusalDeltaEvent | ResponseRefusalDoneEvent | ResponseTextDeltaEvent | ResponseTextDoneEvent | ResponseWebSearchCallCompletedEvent | ResponseWebSearchCallInProgressEvent | ResponseWebSearchCallSearchingEvent | ResponseImageGenCallCompletedEvent | ResponseImageGenCallGeneratingEvent | ResponseImageGenCallInProgressEvent | ResponseImageGenCallPartialImageEvent | ResponseMCPCallArgumentsDeltaEvent | ResponseMCPCallArgumentsDoneEvent | ResponseMCPCallCompletedEvent | ResponseMCPCallFailedEvent | ResponseMCPCallInProgressEvent | ResponseMCPListToolsCompletedEvent | ResponseMCPListToolsFailedEvent | ResponseMCPListToolsInProgressEvent | ResponseOutputTextAnnotationAddedEvent | ResponseQueuedEvent | ResponseCustomToolCallInputDeltaEvent | ResponseCustomToolCallInputDoneEvent
export const ResponseStreamEvent = Schema.Union([Schema.suspend((): Schema.Codec<ResponseAudioDeltaEvent> => ResponseAudioDeltaEvent), Schema.suspend((): Schema.Codec<ResponseAudioDoneEvent> => ResponseAudioDoneEvent), Schema.suspend((): Schema.Codec<ResponseAudioTranscriptDeltaEvent> => ResponseAudioTranscriptDeltaEvent), Schema.suspend((): Schema.Codec<ResponseAudioTranscriptDoneEvent> => ResponseAudioTranscriptDoneEvent), Schema.suspend((): Schema.Codec<ResponseCodeInterpreterCallCodeDeltaEvent> => ResponseCodeInterpreterCallCodeDeltaEvent), Schema.suspend((): Schema.Codec<ResponseCodeInterpreterCallCodeDoneEvent> => ResponseCodeInterpreterCallCodeDoneEvent), Schema.suspend((): Schema.Codec<ResponseCodeInterpreterCallCompletedEvent> => ResponseCodeInterpreterCallCompletedEvent), Schema.suspend((): Schema.Codec<ResponseCodeInterpreterCallInProgressEvent> => ResponseCodeInterpreterCallInProgressEvent), Schema.suspend((): Schema.Codec<ResponseCodeInterpreterCallInterpretingEvent> => ResponseCodeInterpreterCallInterpretingEvent), Schema.suspend((): Schema.Codec<ResponseCompletedEvent> => ResponseCompletedEvent), Schema.suspend((): Schema.Codec<ResponseContentPartAddedEvent> => ResponseContentPartAddedEvent), Schema.suspend((): Schema.Codec<ResponseContentPartDoneEvent> => ResponseContentPartDoneEvent), Schema.suspend((): Schema.Codec<ResponseCreatedEvent> => ResponseCreatedEvent), Schema.suspend((): Schema.Codec<ResponseErrorEvent> => ResponseErrorEvent), Schema.suspend((): Schema.Codec<ResponseFileSearchCallCompletedEvent> => ResponseFileSearchCallCompletedEvent), Schema.suspend((): Schema.Codec<ResponseFileSearchCallInProgressEvent> => ResponseFileSearchCallInProgressEvent), Schema.suspend((): Schema.Codec<ResponseFileSearchCallSearchingEvent> => ResponseFileSearchCallSearchingEvent), Schema.suspend((): Schema.Codec<ResponseFunctionCallArgumentsDeltaEvent> => ResponseFunctionCallArgumentsDeltaEvent), Schema.suspend((): Schema.Codec<ResponseFunctionCallArgumentsDoneEvent> => ResponseFunctionCallArgumentsDoneEvent), Schema.suspend((): Schema.Codec<ResponseInProgressEvent> => ResponseInProgressEvent), Schema.suspend((): Schema.Codec<ResponseFailedEvent> => ResponseFailedEvent), Schema.suspend((): Schema.Codec<ResponseIncompleteEvent> => ResponseIncompleteEvent), Schema.suspend((): Schema.Codec<ResponseOutputItemAddedEvent> => ResponseOutputItemAddedEvent), Schema.suspend((): Schema.Codec<ResponseOutputItemDoneEvent> => ResponseOutputItemDoneEvent), Schema.suspend((): Schema.Codec<ResponseReasoningSummaryPartAddedEvent> => ResponseReasoningSummaryPartAddedEvent), Schema.suspend((): Schema.Codec<ResponseReasoningSummaryPartDoneEvent> => ResponseReasoningSummaryPartDoneEvent), Schema.suspend((): Schema.Codec<ResponseReasoningSummaryTextDeltaEvent> => ResponseReasoningSummaryTextDeltaEvent), Schema.suspend((): Schema.Codec<ResponseReasoningSummaryTextDoneEvent> => ResponseReasoningSummaryTextDoneEvent), Schema.suspend((): Schema.Codec<ResponseReasoningTextDeltaEvent> => ResponseReasoningTextDeltaEvent), Schema.suspend((): Schema.Codec<ResponseReasoningTextDoneEvent> => ResponseReasoningTextDoneEvent), Schema.suspend((): Schema.Codec<ResponseRefusalDeltaEvent> => ResponseRefusalDeltaEvent), Schema.suspend((): Schema.Codec<ResponseRefusalDoneEvent> => ResponseRefusalDoneEvent), ResponseTextDeltaEvent, ResponseTextDoneEvent, ResponseWebSearchCallCompletedEvent, ResponseWebSearchCallInProgressEvent, ResponseWebSearchCallSearchingEvent, Schema.suspend((): Schema.Codec<ResponseImageGenCallCompletedEvent> => ResponseImageGenCallCompletedEvent), Schema.suspend((): Schema.Codec<ResponseImageGenCallGeneratingEvent> => ResponseImageGenCallGeneratingEvent), Schema.suspend((): Schema.Codec<ResponseImageGenCallInProgressEvent> => ResponseImageGenCallInProgressEvent), Schema.suspend((): Schema.Codec<ResponseImageGenCallPartialImageEvent> => ResponseImageGenCallPartialImageEvent), Schema.suspend((): Schema.Codec<ResponseMCPCallArgumentsDeltaEvent> => ResponseMCPCallArgumentsDeltaEvent), Schema.suspend((): Schema.Codec<ResponseMCPCallArgumentsDoneEvent> => ResponseMCPCallArgumentsDoneEvent), Schema.suspend((): Schema.Codec<ResponseMCPCallCompletedEvent> => ResponseMCPCallCompletedEvent), Schema.suspend((): Schema.Codec<ResponseMCPCallFailedEvent> => ResponseMCPCallFailedEvent), Schema.suspend((): Schema.Codec<ResponseMCPCallInProgressEvent> => ResponseMCPCallInProgressEvent), Schema.suspend((): Schema.Codec<ResponseMCPListToolsCompletedEvent> => ResponseMCPListToolsCompletedEvent), Schema.suspend((): Schema.Codec<ResponseMCPListToolsFailedEvent> => ResponseMCPListToolsFailedEvent), Schema.suspend((): Schema.Codec<ResponseMCPListToolsInProgressEvent> => ResponseMCPListToolsInProgressEvent), Schema.suspend((): Schema.Codec<ResponseOutputTextAnnotationAddedEvent> => ResponseOutputTextAnnotationAddedEvent), Schema.suspend((): Schema.Codec<ResponseQueuedEvent> => ResponseQueuedEvent), Schema.suspend((): Schema.Codec<ResponseCustomToolCallInputDeltaEvent> => ResponseCustomToolCallInputDeltaEvent), Schema.suspend((): Schema.Codec<ResponseCustomToolCallInputDoneEvent> => ResponseCustomToolCallInputDoneEvent)]).annotate({ "identifier": "ResponseStreamEvent" })
export type CreateEvalRunRequest = { readonly "name"?: string, readonly "metadata"?: Metadata, readonly "data_source": CreateEvalJsonlRunDataSource | CreateEvalCompletionsRunDataSource | CreateEvalResponsesRunDataSource, readonly [x: string]: unknown }
export const CreateEvalRunRequest = Schema.StructWithRest(Schema.Struct({ "name": Schema.optionalKey(Schema.String.annotate({ "description": "The name of the run." })), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)), "data_source": Schema.Union([Schema.suspend((): Schema.Codec<CreateEvalJsonlRunDataSource> => CreateEvalJsonlRunDataSource), Schema.suspend((): Schema.Codec<CreateEvalCompletionsRunDataSource> => CreateEvalCompletionsRunDataSource), Schema.suspend((): Schema.Codec<CreateEvalResponsesRunDataSource> => CreateEvalResponsesRunDataSource)]).annotate({ "description": "Details about the run's data source." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "CreateEvalRunRequest", "identifier": "CreateEvalRunRequest" })
export type EvalRun = { readonly "object": "eval.run", readonly "id": string, readonly "eval_id": string, readonly "status": string, readonly "model": string, readonly "name": string, readonly "created_at": number, readonly "report_url": string, readonly "result_counts": { readonly "total": number, readonly "errored": number, readonly "failed": number, readonly "passed": number, readonly [x: string]: unknown }, readonly "per_model_usage": ReadonlyArray<{ readonly "model_name": string, readonly "invocation_count": number, readonly "prompt_tokens": number, readonly "completion_tokens": number, readonly "total_tokens": number, readonly "cached_tokens": number, readonly [x: string]: unknown }>, readonly "per_testing_criteria_results": ReadonlyArray<{ readonly "testing_criteria": string, readonly "passed": number, readonly "failed": number, readonly [x: string]: unknown }>, readonly "data_source": CreateEvalJsonlRunDataSource | CreateEvalCompletionsRunDataSource | CreateEvalResponsesRunDataSource, readonly "metadata": Metadata, readonly "error": EvalApiError, readonly [x: string]: unknown }
export const EvalRun = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("eval.run").annotate({ "description": "The type of the object. Always \\"eval.run\\".", "default": "eval.run" }), "id": Schema.String.annotate({ "description": "Unique identifier for the evaluation run." }), "eval_id": Schema.String.annotate({ "description": "The identifier of the associated evaluation." }), "status": Schema.String.annotate({ "description": "The status of the evaluation run." }), "model": Schema.String.annotate({ "description": "The model that is evaluated, if applicable." }), "name": Schema.String.annotate({ "description": "The name of the evaluation run." }), "created_at": Schema.Number.annotate({ "description": "Unix timestamp (in seconds) when the evaluation run was created." }).check(Schema.isInt()), "report_url": Schema.String.annotate({ "description": "The URL to the rendered evaluation run report on the UI dashboard." }), "result_counts": Schema.StructWithRest(Schema.Struct({ "total": Schema.Number.annotate({ "description": "Total number of executed output items." }).check(Schema.isInt()), "errored": Schema.Number.annotate({ "description": "Number of output items that resulted in an error." }).check(Schema.isInt()), "failed": Schema.Number.annotate({ "description": "Number of output items that failed to pass the evaluation." }).check(Schema.isInt()), "passed": Schema.Number.annotate({ "description": "Number of output items that passed the evaluation." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Counters summarizing the outcomes of the evaluation run." }), "per_model_usage": Schema.Array(Schema.StructWithRest(Schema.Struct({ "model_name": Schema.String.annotate({ "description": "The name of the model." }), "invocation_count": Schema.Number.annotate({ "description": "The number of invocations." }).check(Schema.isInt()), "prompt_tokens": Schema.Number.annotate({ "description": "The number of prompt tokens used." }).check(Schema.isInt()), "completion_tokens": Schema.Number.annotate({ "description": "The number of completion tokens generated." }).check(Schema.isInt()), "total_tokens": Schema.Number.annotate({ "description": "The total number of tokens used." }).check(Schema.isInt()), "cached_tokens": Schema.Number.annotate({ "description": "The number of tokens retrieved from cache." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "Usage statistics for each model during the evaluation run." }), "per_testing_criteria_results": Schema.Array(Schema.StructWithRest(Schema.Struct({ "testing_criteria": Schema.String.annotate({ "description": "A description of the testing criteria." }), "passed": Schema.Number.annotate({ "description": "Number of tests passed for this criteria." }).check(Schema.isInt()), "failed": Schema.Number.annotate({ "description": "Number of tests failed for this criteria." }).check(Schema.isInt()) }), [Schema.Record(Schema.String, Schema.Unknown)])).annotate({ "description": "Results per testing criteria applied during the evaluation run." }), "data_source": Schema.Union([Schema.suspend((): Schema.Codec<CreateEvalJsonlRunDataSource> => CreateEvalJsonlRunDataSource), Schema.suspend((): Schema.Codec<CreateEvalCompletionsRunDataSource> => CreateEvalCompletionsRunDataSource), Schema.suspend((): Schema.Codec<CreateEvalResponsesRunDataSource> => CreateEvalResponsesRunDataSource)]).annotate({ "description": "Information about the run's data source." }), "metadata": Schema.suspend((): Schema.Codec<Metadata> => Metadata), "error": Schema.suspend((): Schema.Codec<EvalApiError> => EvalApiError) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalRun", "description": "A schema representing an evaluation run.\\n", "identifier": "EvalRun" })
export type ResponseProperties = { readonly "previous_response_id"?: string | null, readonly "model"?: ModelIdsResponses, readonly "reasoning"?: Reasoning | null, readonly "background"?: boolean | null, readonly "max_output_tokens"?: number | null, readonly "max_tool_calls"?: number | null, readonly "text"?: ResponseTextParam, readonly "tools"?: ToolsArray, readonly "tool_choice"?: ToolChoiceParam, readonly "prompt"?: Prompt, readonly "truncation"?: "auto" | "disabled" | null, readonly [x: string]: unknown }
export const ResponseProperties = Schema.StructWithRest(Schema.Struct({ "previous_response_id": Schema.optionalKey(Schema.Union([Schema.String.annotate({ "description": "The unique ID of the previous response to the model. Use this to\\ncreate multi-turn conversations. Learn more about\\n[conversation state](https://platform.openai.com/docs/guides/conversation-state). Cannot be used in conjunction with \`conversation\`.\\n" }), Schema.Null])), "model": Schema.optionalKey(Schema.suspend((): Schema.Codec<ModelIdsResponses> => ModelIdsResponses).annotate({ "description": "Model ID used to generate the response, like \`gpt-4o\` or \`o3\`. OpenAI\\noffers a wide range of models with different capabilities, performance\\ncharacteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models)\\nto browse and compare available models.\\n" })), "reasoning": Schema.optionalKey(Schema.Union([Schema.suspend((): Schema.Codec<Reasoning> => Reasoning), Schema.Null])), "background": Schema.optionalKey(Schema.Union([Schema.Boolean.annotate({ "description": "Whether to run the model response in the background.\\n[Learn more](https://platform.openai.com/docs/guides/background).\\n", "default": false }), Schema.Null])), "max_output_tokens": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).\\n" }).check(Schema.isInt()), Schema.Null])), "max_tool_calls": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\\n" }).check(Schema.isInt()), Schema.Null])), "text": Schema.optionalKey(ResponseTextParam), "tools": Schema.optionalKey(ToolsArray), "tool_choice": Schema.optionalKey(ToolChoiceParam), "prompt": Schema.optionalKey(Schema.suspend((): Schema.Codec<Prompt> => Prompt)), "truncation": Schema.optionalKey(Schema.Union([Schema.Literals(["auto", "disabled"]).annotate({ "description": "The truncation strategy to use for the model response.\\n- \`auto\`: If the input to this Response exceeds\\n  the model's context window size, the model will truncate the\\n  response to fit the context window by dropping items from the beginning of the conversation.\\n- \`disabled\` (default): If the input size will exceed the context window\\n  size for a model, the request will fail with a 400 error.\\n", "default": "disabled" }), Schema.Null])) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ResponseProperties" })
export type FineTuneMethod = { readonly "type": "supervised" | "dpo" | "reinforcement", readonly "supervised"?: FineTuneSupervisedMethod, readonly "dpo"?: FineTuneDPOMethod, readonly "reinforcement"?: FineTuneReinforcementMethod, readonly [x: string]: unknown }
export const FineTuneMethod = Schema.StructWithRest(Schema.Struct({ "type": Schema.Literals(["supervised", "dpo", "reinforcement"]).annotate({ "description": "The type of method. Is either \`supervised\`, \`dpo\`, or \`reinforcement\`." }), "supervised": Schema.optionalKey(FineTuneSupervisedMethod), "dpo": Schema.optionalKey(Schema.suspend((): Schema.Codec<FineTuneDPOMethod> => FineTuneDPOMethod)), "reinforcement": Schema.optionalKey(FineTuneReinforcementMethod) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The method used for fine-tuning.", "identifier": "FineTuneMethod" })
export type EvalRunList = { readonly "object": "list", readonly "data": ReadonlyArray<EvalRun>, readonly "first_id": string, readonly "last_id": string, readonly "has_more": boolean, readonly [x: string]: unknown }
export const EvalRunList = Schema.StructWithRest(Schema.Struct({ "object": Schema.Literal("list").annotate({ "description": "The type of this object. It is always set to \\"list\\".\\n", "default": "list" }), "data": Schema.Array(Schema.suspend((): Schema.Codec<EvalRun> => EvalRun)).annotate({ "description": "An array of eval run objects.\\n" }), "first_id": Schema.String.annotate({ "description": "The identifier of the first eval run in the data array." }), "last_id": Schema.String.annotate({ "description": "The identifier of the last eval run in the data array." }), "has_more": Schema.Boolean.annotate({ "description": "Indicates whether there are more evals available." }) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "EvalRunList", "description": "An object representing a list of runs for an evaluation.\\n", "identifier": "EvalRunList" })
export type CreateFineTuningJobRequest = { readonly "model": string | "babbage-002" | "davinci-002" | "gpt-3.5-turbo" | "gpt-4o-mini", readonly "training_file": string, readonly "hyperparameters"?: { readonly "batch_size"?: "auto" | number, readonly "learning_rate_multiplier"?: "auto" | number, readonly "n_epochs"?: "auto" | number, readonly [x: string]: unknown }, readonly "suffix"?: string | null, readonly "validation_file"?: string | null, readonly "integrations"?: ReadonlyArray<unknown> | null, readonly "seed"?: number | null, readonly "method"?: FineTuneMethod, readonly "metadata"?: Metadata, readonly [x: string]: unknown }
export const CreateFineTuningJobRequest = Schema.StructWithRest(Schema.Struct({ "model": Schema.Union([Schema.String, Schema.Literals(["babbage-002", "davinci-002", "gpt-3.5-turbo", "gpt-4o-mini"]).annotate({ "title": "Preset" })]).annotate({ "description": "The name of the model to fine-tune. You can select one of the\\n[supported models](https://platform.openai.com/docs/guides/fine-tuning#which-models-can-be-fine-tuned).\\n" }), "training_file": Schema.String.annotate({ "description": "The ID of an uploaded file that contains training data.\\n\\nSee [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.\\n\\nYour dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose \`fine-tune\`.\\n\\nThe contents of the file should differ depending on if the model uses the [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input), [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input) format, or if the fine-tuning method uses the [preference](https://platform.openai.com/docs/api-reference/fine-tuning/preference-input) format.\\n\\nSee the [fine-tuning guide](https://platform.openai.com/docs/guides/model-optimization) for more details.\\n" }), "hyperparameters": Schema.optionalKey(Schema.StructWithRest(Schema.Struct({ "batch_size": Schema.optionalKey(Schema.Union([Schema.Literal("auto").annotate({ "title": "Auto" }), Schema.Number.check(Schema.isInt())]).annotate({ "description": "Number of examples in each batch. A larger batch size means that model parameters\\nare updated less frequently, but with lower variance.\\n", "default": "auto" })), "learning_rate_multiplier": Schema.optionalKey(Schema.Union([Schema.Literal("auto").annotate({ "title": "Auto" }), Schema.Number.check(Schema.isFinite())]).annotate({ "description": "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\\noverfitting.\\n" })), "n_epochs": Schema.optionalKey(Schema.Union([Schema.Literal("auto").annotate({ "title": "Auto" }), Schema.Number.check(Schema.isInt())]).annotate({ "description": "The number of epochs to train the model for. An epoch refers to one full cycle\\nthrough the training dataset.\\n", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The hyperparameters used for the fine-tuning job.\\nThis value is now deprecated in favor of \`method\`, and should be passed in under the \`method\` parameter.\\n" })), "suffix": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "A string of up to 64 characters that will be added to your fine-tuned model name.\\n\\nFor example, a \`suffix\` of \\"custom-model-name\\" would produce a model name like \`ft:gpt-4o-mini:openai:custom-model-name:7p4lURel\`.\\n", "default": null })), "validation_file": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "The ID of an uploaded file that contains validation data.\\n\\nIf you provide this file, the data is used to generate validation\\nmetrics periodically during fine-tuning. These metrics can be viewed in\\nthe fine-tuning results file.\\nThe same data should not be present in both train and validation files.\\n\\nYour dataset must be formatted as a JSONL file. You must upload your file with the purpose \`fine-tune\`.\\n\\nSee the [fine-tuning guide](https://platform.openai.com/docs/guides/model-optimization) for more details.\\n" })), "integrations": Schema.optionalKey(Schema.Union([Schema.Array(Schema.Unknown), Schema.Null]).annotate({ "description": "A list of integrations to enable for your fine-tuning job." })), "seed": Schema.optionalKey(Schema.Union([Schema.Number.check(Schema.isInt()), Schema.Null]).annotate({ "description": "The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.\\nIf a seed is not specified, one will be generated for you.\\n" })), "method": Schema.optionalKey(FineTuneMethod), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "CreateFineTuningJobRequest" })
export type FineTuningJob = { readonly "id": string, readonly "created_at": number, readonly "error": { readonly "code": string, readonly "message": string, readonly "param": string | null, readonly [x: string]: unknown } | null, readonly "fine_tuned_model": string | null, readonly "finished_at": number | null, readonly "hyperparameters": { readonly "batch_size"?: "auto" | number | null, readonly "learning_rate_multiplier"?: "auto" | number, readonly "n_epochs"?: "auto" | number, readonly [x: string]: unknown }, readonly "model": string, readonly "object": "fine_tuning.job", readonly "organization_id": string, readonly "result_files": ReadonlyArray<string>, readonly "status": "validating_files" | "queued" | "running" | "succeeded" | "failed" | "cancelled", readonly "trained_tokens": number | null, readonly "training_file": string, readonly "validation_file": string | null, readonly "integrations"?: ReadonlyArray<FineTuningIntegration> | null, readonly "seed": number, readonly "estimated_finish"?: number | null, readonly "method"?: FineTuneMethod, readonly "metadata"?: Metadata, readonly [x: string]: unknown }
export const FineTuningJob = Schema.StructWithRest(Schema.Struct({ "id": Schema.String.annotate({ "description": "The object identifier, which can be referenced in the API endpoints." }), "created_at": Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the fine-tuning job was created." }).check(Schema.isInt()), "error": Schema.Union([Schema.StructWithRest(Schema.Struct({ "code": Schema.String.annotate({ "description": "A machine-readable error code." }), "message": Schema.String.annotate({ "description": "A human-readable error message." }), "param": Schema.Union([Schema.String.annotate({ "description": "The parameter that was invalid, usually \`training_file\` or \`validation_file\`. This field will be null if the failure was not parameter-specific." }), Schema.Null]) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "For fine-tuning jobs that have \`failed\`, this will contain more information on the cause of the failure." }), Schema.Null]), "fine_tuned_model": Schema.Union([Schema.String.annotate({ "description": "The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running." }), Schema.Null]), "finished_at": Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running." }).check(Schema.isInt()), Schema.Null]), "hyperparameters": Schema.StructWithRest(Schema.Struct({ "batch_size": Schema.optionalKey(Schema.Union([Schema.Union([Schema.Literal("auto"), Schema.Number.check(Schema.isInt())]).annotate({ "title": "Auto", "description": "Number of examples in each batch. A larger batch size means that model parameters\\nare updated less frequently, but with lower variance.\\n", "default": "auto" }), Schema.Null.annotate({ "title": "Manual" })])), "learning_rate_multiplier": Schema.optionalKey(Schema.Union([Schema.Literal("auto").annotate({ "title": "Auto" }), Schema.Number.check(Schema.isFinite())]).annotate({ "description": "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\\noverfitting.\\n" })), "n_epochs": Schema.optionalKey(Schema.Union([Schema.Literal("auto").annotate({ "title": "Auto" }), Schema.Number.check(Schema.isInt())]).annotate({ "description": "The number of epochs to train the model for. An epoch refers to one full cycle\\nthrough the training dataset.\\n", "default": "auto" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "The hyperparameters used for the fine-tuning job. This value will only be returned when running \`supervised\` jobs." }), "model": Schema.String.annotate({ "description": "The base model that is being fine-tuned." }), "object": Schema.Literal("fine_tuning.job").annotate({ "description": "The object type, which is always \\"fine_tuning.job\\"." }), "organization_id": Schema.String.annotate({ "description": "The organization that owns the fine-tuning job." }), "result_files": Schema.Array(Schema.String).annotate({ "description": "The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)." }), "status": Schema.Literals(["validating_files", "queued", "running", "succeeded", "failed", "cancelled"]).annotate({ "description": "The current status of the fine-tuning job, which can be either \`validating_files\`, \`queued\`, \`running\`, \`succeeded\`, \`failed\`, or \`cancelled\`." }), "trained_tokens": Schema.Union([Schema.Number.annotate({ "description": "The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running." }).check(Schema.isInt()), Schema.Null]), "training_file": Schema.String.annotate({ "description": "The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)." }), "validation_file": Schema.Union([Schema.String.annotate({ "description": "The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)." }), Schema.Null]), "integrations": Schema.optionalKey(Schema.Union([Schema.Array(Schema.Union([Schema.suspend((): Schema.Codec<FineTuningIntegration> => FineTuningIntegration)])).annotate({ "description": "A list of integrations to enable for this fine-tuning job." }), Schema.Null])), "seed": Schema.Number.annotate({ "description": "The seed used for the fine-tuning job." }).check(Schema.isInt()), "estimated_finish": Schema.optionalKey(Schema.Union([Schema.Number.annotate({ "description": "The Unix timestamp (in seconds) for when the fine-tuning job is estimated to finish. The value will be null if the fine-tuning job is not running." }).check(Schema.isInt()), Schema.Null])), "method": Schema.optionalKey(Schema.suspend((): Schema.Codec<FineTuneMethod> => FineTuneMethod)), "metadata": Schema.optionalKey(Schema.suspend((): Schema.Codec<Metadata> => Metadata)) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "title": "FineTuningJob", "description": "The \`fine_tuning.job\` object represents a fine-tuning job that has been created through the API.\\n", "identifier": "FineTuningJob" })
export type ListPaginatedFineTuningJobsResponse = { readonly "data": ReadonlyArray<FineTuningJob>, readonly "has_more": boolean, readonly "object": "list", readonly [x: string]: unknown }
export const ListPaginatedFineTuningJobsResponse = Schema.StructWithRest(Schema.Struct({ "data": Schema.Array(Schema.suspend((): Schema.Codec<FineTuningJob> => FineTuningJob)), "has_more": Schema.Boolean, "object": Schema.Literal("list") }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "identifier": "ListPaginatedFineTuningJobsResponse" })
// schemas
export type ListAssistantsParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string, readonly "before"?: string }
export const ListAssistantsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })), "after": Schema.optionalKey(Schema.String), "before": Schema.optionalKey(Schema.String) })
export type ListAssistants200 = ListAssistantsResponse
export const ListAssistants200 = ListAssistantsResponse
export type GetAssistant200 = AssistantObject
export const GetAssistant200 = AssistantObject
export type ListVoiceConsentsParams = { readonly "after"?: string, readonly "limit"?: number }
export const ListVoiceConsentsParams = Schema.Struct({ "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())) })
export type ListVoiceConsents200 = VoiceConsentListResource
export const ListVoiceConsents200 = VoiceConsentListResource
export type GetVoiceConsent200 = VoiceConsentResource
export const GetVoiceConsent200 = VoiceConsentResource
export type ListBatchesParams = { readonly "after"?: string, readonly "limit"?: number }
export const ListBatchesParams = Schema.Struct({ "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())) })
export type ListBatches200 = ListBatchesResponse
export const ListBatches200 = ListBatchesResponse
export type RetrieveBatch200 = Batch
export const RetrieveBatch200 = Batch
export type ListChatCompletionsParams = { readonly "model"?: string, readonly "metadata"?: Metadata, readonly "after"?: string, readonly "limit"?: number, readonly "order"?: "asc" | "desc" }
export const ListChatCompletionsParams = Schema.Struct({ "model": Schema.optionalKey(Schema.String), "metadata": Schema.optionalKey(Metadata), "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "asc" })) })
export type ListChatCompletions200 = ChatCompletionList
export const ListChatCompletions200 = ChatCompletionList
export type GetChatCompletion200 = CreateChatCompletionResponse
export const GetChatCompletion200 = CreateChatCompletionResponse
export type GetChatCompletionMessagesParams = { readonly "after"?: string, readonly "limit"?: number, readonly "order"?: "asc" | "desc" }
export const GetChatCompletionMessagesParams = Schema.Struct({ "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "asc" })) })
export type GetChatCompletionMessages200 = ChatCompletionMessageList
export const GetChatCompletionMessages200 = ChatCompletionMessageList
export type ListContainersParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string }
export const ListContainersParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })), "after": Schema.optionalKey(Schema.String) })
export type ListContainers200 = ContainerListResource
export const ListContainers200 = ContainerListResource
export type RetrieveContainer200 = ContainerResource
export const RetrieveContainer200 = ContainerResource
export type ListContainerFilesParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string }
export const ListContainerFilesParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })), "after": Schema.optionalKey(Schema.String) })
export type ListContainerFiles200 = ContainerFileListResource
export const ListContainerFiles200 = ContainerFileListResource
export type RetrieveContainerFile200 = ContainerFileResource
export const RetrieveContainerFile200 = ContainerFileResource
export type ListConversationItemsParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string, readonly "include"?: ReadonlyArray<IncludeEnum> }
export const ListConversationItemsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])), "after": Schema.optionalKey(Schema.String), "include": Schema.optionalKey(Schema.Array(IncludeEnum)) })
export type ListConversationItems200 = ConversationItemList
export const ListConversationItems200 = ConversationItemList
export type GetConversationItemParams = { readonly "include"?: ReadonlyArray<IncludeEnum> }
export const GetConversationItemParams = Schema.Struct({ "include": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<IncludeEnum> => IncludeEnum))) })
export type GetConversationItem200 = ConversationItem
export const GetConversationItem200 = ConversationItem
export type ListEvalsParams = { readonly "after"?: string, readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "order_by"?: "created_at" | "updated_at" }
export const ListEvalsParams = Schema.Struct({ "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "asc" })), "order_by": Schema.optionalKey(Schema.Literals(["created_at", "updated_at"]).annotate({ "default": "created_at" })) })
export type ListEvals200 = EvalList
export const ListEvals200 = EvalList
export type GetEval200 = Eval
export const GetEval200 = Eval
export type GetEvalRunsParams = { readonly "after"?: string, readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "status"?: "queued" | "in_progress" | "completed" | "canceled" | "failed" }
export const GetEvalRunsParams = Schema.Struct({ "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "asc" })), "status": Schema.optionalKey(Schema.Literals(["queued", "in_progress", "completed", "canceled", "failed"])) })
export type GetEvalRuns200 = EvalRunList
export const GetEvalRuns200 = EvalRunList
export type GetEvalRun200 = EvalRun
export const GetEvalRun200 = EvalRun
export type GetEvalRunOutputItemsParams = { readonly "after"?: string, readonly "limit"?: number, readonly "status"?: "fail" | "pass", readonly "order"?: "asc" | "desc" }
export const GetEvalRunOutputItemsParams = Schema.Struct({ "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "status": Schema.optionalKey(Schema.Literals(["fail", "pass"])), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "asc" })) })
export type GetEvalRunOutputItems200 = EvalRunOutputItemList
export const GetEvalRunOutputItems200 = EvalRunOutputItemList
export type GetEvalRunOutputItem200 = EvalRunOutputItem
export const GetEvalRunOutputItem200 = EvalRunOutputItem
export type ListFilesParams = { readonly "purpose"?: string, readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string }
export const ListFilesParams = Schema.Struct({ "purpose": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 10000 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })), "after": Schema.optionalKey(Schema.String) })
export type ListFiles200 = ListFilesResponse
export const ListFiles200 = ListFilesResponse
export type RetrieveFile200 = OpenAIFile
export const RetrieveFile200 = OpenAIFile
export type DownloadFile200 = string
export const DownloadFile200 = Schema.String
export type ListFineTuningCheckpointPermissionsParams = { readonly "project_id"?: string, readonly "after"?: string, readonly "limit"?: number, readonly "order"?: "ascending" | "descending" }
export const ListFineTuningCheckpointPermissionsParams = Schema.Struct({ "project_id": Schema.optionalKey(Schema.String), "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 10 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["ascending", "descending"]).annotate({ "default": "descending" })) })
export type ListFineTuningCheckpointPermissions200 = ListFineTuningCheckpointPermissionResponse
export const ListFineTuningCheckpointPermissions200 = ListFineTuningCheckpointPermissionResponse
export type ListPaginatedFineTuningJobsParams = { readonly "after"?: string, readonly "limit"?: number, readonly "metadata"?: { readonly [x: string]: unknown } | null }
export const ListPaginatedFineTuningJobsParams = Schema.Struct({ "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "metadata": Schema.optionalKey(Schema.Union([Schema.Record(Schema.String, Schema.Unknown), Schema.Null])) })
export type ListPaginatedFineTuningJobs200 = ListPaginatedFineTuningJobsResponse
export const ListPaginatedFineTuningJobs200 = ListPaginatedFineTuningJobsResponse
export type RetrieveFineTuningJob200 = FineTuningJob
export const RetrieveFineTuningJob200 = FineTuningJob
export type ListFineTuningJobCheckpointsParams = { readonly "after"?: string, readonly "limit"?: number }
export const ListFineTuningJobCheckpointsParams = Schema.Struct({ "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 10 }).check(Schema.isInt())) })
export type ListFineTuningJobCheckpoints200 = ListFineTuningJobCheckpointsResponse
export const ListFineTuningJobCheckpoints200 = ListFineTuningJobCheckpointsResponse
export type ListFineTuningEventsParams = { readonly "after"?: string, readonly "limit"?: number }
export const ListFineTuningEventsParams = Schema.Struct({ "after": Schema.optionalKey(Schema.String), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())) })
export type ListFineTuningEvents200 = ListFineTuningJobEventsResponse
export const ListFineTuningEvents200 = ListFineTuningJobEventsResponse
export type ListModels200 = ListModelsResponse
export const ListModels200 = ListModelsResponse
export type RetrieveModel200 = Model
export const RetrieveModel200 = Model
export type AdminApiKeysListParams = { readonly "after"?: string | null, readonly "order"?: "asc" | "desc", readonly "limit"?: number }
export const AdminApiKeysListParams = Schema.Struct({ "after": Schema.optionalKey(Schema.Union([Schema.String, Schema.Null]).annotate({ "description": "Return keys with IDs that come after this ID in the pagination order." })), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "description": "Order results by creation time, ascending or descending.", "default": "asc" })), "limit": Schema.optionalKey(Schema.Number.annotate({ "description": "Maximum number of keys to return.", "default": 20 }).check(Schema.isInt())) })
export type AdminApiKeysList200 = ApiKeyList
export const AdminApiKeysList200 = ApiKeyList
export type AdminApiKeysGet200 = AdminApiKey
export const AdminApiKeysGet200 = AdminApiKey
export type ListAuditLogsParams = { readonly "effective_at[gt]"?: number, readonly "effective_at[gte]"?: number, readonly "effective_at[lt]"?: number, readonly "effective_at[lte]"?: number, readonly "project_ids[]"?: ReadonlyArray<string>, readonly "event_types[]"?: ReadonlyArray<AuditLogEventType>, readonly "actor_ids[]"?: ReadonlyArray<string>, readonly "actor_emails[]"?: ReadonlyArray<string>, readonly "resource_ids[]"?: ReadonlyArray<string>, readonly "limit"?: number, readonly "after"?: string, readonly "before"?: string }
export const ListAuditLogsParams = Schema.Struct({ "effective_at[gt]": Schema.optionalKey(Schema.Number.annotate({ "description": "Return only events whose \`effective_at\` (Unix seconds) is greater than this value." }).check(Schema.isInt())), "effective_at[gte]": Schema.optionalKey(Schema.Number.annotate({ "description": "Return only events whose \`effective_at\` (Unix seconds) is greater than or equal to this value." }).check(Schema.isInt())), "effective_at[lt]": Schema.optionalKey(Schema.Number.annotate({ "description": "Return only events whose \`effective_at\` (Unix seconds) is less than this value." }).check(Schema.isInt())), "effective_at[lte]": Schema.optionalKey(Schema.Number.annotate({ "description": "Return only events whose \`effective_at\` (Unix seconds) is less than or equal to this value." }).check(Schema.isInt())), "project_ids[]": Schema.optionalKey(Schema.Array(Schema.String)), "event_types[]": Schema.optionalKey(Schema.Array(AuditLogEventType)), "actor_ids[]": Schema.optionalKey(Schema.Array(Schema.String)), "actor_emails[]": Schema.optionalKey(Schema.Array(Schema.String)), "resource_ids[]": Schema.optionalKey(Schema.Array(Schema.String)), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "before": Schema.optionalKey(Schema.String) })
export type ListAuditLogs200 = ListAuditLogsResponse
export const ListAuditLogs200 = ListAuditLogsResponse
export type ListOrganizationCertificatesParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListOrganizationCertificatesParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })) })
export type ListOrganizationCertificates200 = ListCertificatesResponse
export const ListOrganizationCertificates200 = ListCertificatesResponse
export type GetCertificateParams = { readonly "include"?: ReadonlyArray<"content"> }
export const GetCertificateParams = Schema.Struct({ "include": Schema.optionalKey(Schema.Array(Schema.Literal("content"))) })
export type GetCertificate200 = Certificate
export const GetCertificate200 = Certificate
export type UsageCostsParams = { readonly "start_time": number, readonly "end_time"?: number, readonly "bucket_width"?: "1d", readonly "project_ids"?: ReadonlyArray<string>, readonly "group_by"?: ReadonlyArray<"project_id" | "line_item">, readonly "limit"?: number, readonly "page"?: string }
export const UsageCostsParams = Schema.Struct({ "start_time": Schema.Number.check(Schema.isInt()), "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "bucket_width": Schema.optionalKey(Schema.Literal("1d").annotate({ "default": "1d" })), "project_ids": Schema.optionalKey(Schema.Array(Schema.String)), "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "line_item"]))), "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 7 }).check(Schema.isInt())), "page": Schema.optionalKey(Schema.String) })
export type UsageCosts200 = UsageResponse
export const UsageCosts200 = UsageResponse
export type ListGroupsParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListGroupsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 100 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "asc" })) })
export type ListGroups200 = GroupListResource
export const ListGroups200 = GroupListResource
export type ListGroupRoleAssignmentsParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListGroupRoleAssignmentsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])) })
export type ListGroupRoleAssignments200 = RoleListResource
export const ListGroupRoleAssignments200 = RoleListResource
export type ListGroupUsersParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListGroupUsersParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 100 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })) })
export type ListGroupUsers200 = UserListResource
export const ListGroupUsers200 = UserListResource
export type ListInvitesParams = { readonly "limit"?: number, readonly "after"?: string }
export const ListInvitesParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String) })
export type ListInvites200 = InviteListResponse
export const ListInvites200 = InviteListResponse
export type RetrieveInvite200 = Invite
export const RetrieveInvite200 = Invite
export type ListProjectsParams = { readonly "limit"?: number, readonly "after"?: string, readonly "include_archived"?: boolean }
export const ListProjectsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "include_archived": Schema.optionalKey(Schema.Boolean.annotate({ "default": false })) })
export type ListProjects200 = ProjectListResponse
export const ListProjects200 = ProjectListResponse
export type RetrieveProject200 = Project
export const RetrieveProject200 = Project
export type ListProjectApiKeysParams = { readonly "limit"?: number, readonly "after"?: string }
export const ListProjectApiKeysParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String) })
export type ListProjectApiKeys200 = ProjectApiKeyListResponse
export const ListProjectApiKeys200 = ProjectApiKeyListResponse
export type RetrieveProjectApiKey200 = ProjectApiKey
export const RetrieveProjectApiKey200 = ProjectApiKey
export type ListProjectCertificatesParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListProjectCertificatesParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })) })
export type ListProjectCertificates200 = ListCertificatesResponse
export const ListProjectCertificates200 = Schema.suspend((): Schema.Codec<ListCertificatesResponse> => ListCertificatesResponse)
export type ListProjectGroupsParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListProjectGroupsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "asc" })) })
export type ListProjectGroups200 = ProjectGroupListResource
export const ListProjectGroups200 = ProjectGroupListResource
export type ListProjectRateLimitsParams = { readonly "limit"?: number, readonly "after"?: string, readonly "before"?: string }
export const ListProjectRateLimitsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 100 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "before": Schema.optionalKey(Schema.String) })
export type ListProjectRateLimits200 = ProjectRateLimitListResponse
export const ListProjectRateLimits200 = ProjectRateLimitListResponse
export type ListProjectServiceAccountsParams = { readonly "limit"?: number, readonly "after"?: string }
export const ListProjectServiceAccountsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String) })
export type ListProjectServiceAccounts200 = ProjectServiceAccountListResponse
export const ListProjectServiceAccounts200 = ProjectServiceAccountListResponse
export type ListProjectServiceAccounts400 = ErrorResponse
export const ListProjectServiceAccounts400 = ErrorResponse
export type RetrieveProjectServiceAccount200 = ProjectServiceAccount
export const RetrieveProjectServiceAccount200 = ProjectServiceAccount
export type ListProjectUsersParams = { readonly "limit"?: number, readonly "after"?: string }
export const ListProjectUsersParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String) })
export type ListProjectUsers200 = ProjectUserListResponse
export const ListProjectUsers200 = ProjectUserListResponse
export type ListProjectUsers400 = ErrorResponse
export const ListProjectUsers400 = Schema.suspend((): Schema.Codec<ErrorResponse> => ErrorResponse)
export type RetrieveProjectUser200 = ProjectUser
export const RetrieveProjectUser200 = ProjectUser
export type ListRolesParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListRolesParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 1000 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "asc" })) })
export type ListRoles200 = PublicRoleListResource
export const ListRoles200 = PublicRoleListResource
export type UsageAudioSpeechesParams = { readonly "start_time": number, readonly "end_time"?: number, readonly "bucket_width"?: "1m" | "1h" | "1d", readonly "project_ids"?: ReadonlyArray<string>, readonly "user_ids"?: ReadonlyArray<string>, readonly "api_key_ids"?: ReadonlyArray<string>, readonly "models"?: ReadonlyArray<string>, readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model">, readonly "limit"?: number, readonly "page"?: string }
export const UsageAudioSpeechesParams = Schema.Struct({ "start_time": Schema.Number.check(Schema.isInt()), "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"]).annotate({ "default": "1d" })), "project_ids": Schema.optionalKey(Schema.Array(Schema.String)), "user_ids": Schema.optionalKey(Schema.Array(Schema.String)), "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)), "models": Schema.optionalKey(Schema.Array(Schema.String)), "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model"]))), "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "page": Schema.optionalKey(Schema.String) })
export type UsageAudioSpeeches200 = UsageResponse
export const UsageAudioSpeeches200 = Schema.suspend((): Schema.Codec<UsageResponse> => UsageResponse)
export type UsageAudioTranscriptionsParams = { readonly "start_time": number, readonly "end_time"?: number, readonly "bucket_width"?: "1m" | "1h" | "1d", readonly "project_ids"?: ReadonlyArray<string>, readonly "user_ids"?: ReadonlyArray<string>, readonly "api_key_ids"?: ReadonlyArray<string>, readonly "models"?: ReadonlyArray<string>, readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model">, readonly "limit"?: number, readonly "page"?: string }
export const UsageAudioTranscriptionsParams = Schema.Struct({ "start_time": Schema.Number.check(Schema.isInt()), "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"]).annotate({ "default": "1d" })), "project_ids": Schema.optionalKey(Schema.Array(Schema.String)), "user_ids": Schema.optionalKey(Schema.Array(Schema.String)), "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)), "models": Schema.optionalKey(Schema.Array(Schema.String)), "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model"]))), "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "page": Schema.optionalKey(Schema.String) })
export type UsageAudioTranscriptions200 = UsageResponse
export const UsageAudioTranscriptions200 = Schema.suspend((): Schema.Codec<UsageResponse> => UsageResponse)
export type UsageCodeInterpreterSessionsParams = { readonly "start_time": number, readonly "end_time"?: number, readonly "bucket_width"?: "1m" | "1h" | "1d", readonly "project_ids"?: ReadonlyArray<string>, readonly "group_by"?: ReadonlyArray<"project_id">, readonly "limit"?: number, readonly "page"?: string }
export const UsageCodeInterpreterSessionsParams = Schema.Struct({ "start_time": Schema.Number.check(Schema.isInt()), "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"]).annotate({ "default": "1d" })), "project_ids": Schema.optionalKey(Schema.Array(Schema.String)), "group_by": Schema.optionalKey(Schema.Array(Schema.Literal("project_id"))), "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "page": Schema.optionalKey(Schema.String) })
export type UsageCodeInterpreterSessions200 = UsageResponse
export const UsageCodeInterpreterSessions200 = Schema.suspend((): Schema.Codec<UsageResponse> => UsageResponse)
export type UsageCompletionsParams = { readonly "start_time": number, readonly "end_time"?: number, readonly "bucket_width"?: "1m" | "1h" | "1d", readonly "project_ids"?: ReadonlyArray<string>, readonly "user_ids"?: ReadonlyArray<string>, readonly "api_key_ids"?: ReadonlyArray<string>, readonly "models"?: ReadonlyArray<string>, readonly "batch"?: boolean, readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model" | "batch" | "service_tier">, readonly "limit"?: number, readonly "page"?: string }
export const UsageCompletionsParams = Schema.Struct({ "start_time": Schema.Number.check(Schema.isInt()), "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"]).annotate({ "default": "1d" })), "project_ids": Schema.optionalKey(Schema.Array(Schema.String)), "user_ids": Schema.optionalKey(Schema.Array(Schema.String)), "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)), "models": Schema.optionalKey(Schema.Array(Schema.String)), "batch": Schema.optionalKey(Schema.Boolean), "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model", "batch", "service_tier"]))), "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "page": Schema.optionalKey(Schema.String) })
export type UsageCompletions200 = UsageResponse
export const UsageCompletions200 = Schema.suspend((): Schema.Codec<UsageResponse> => UsageResponse)
export type UsageEmbeddingsParams = { readonly "start_time": number, readonly "end_time"?: number, readonly "bucket_width"?: "1m" | "1h" | "1d", readonly "project_ids"?: ReadonlyArray<string>, readonly "user_ids"?: ReadonlyArray<string>, readonly "api_key_ids"?: ReadonlyArray<string>, readonly "models"?: ReadonlyArray<string>, readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model">, readonly "limit"?: number, readonly "page"?: string }
export const UsageEmbeddingsParams = Schema.Struct({ "start_time": Schema.Number.check(Schema.isInt()), "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"]).annotate({ "default": "1d" })), "project_ids": Schema.optionalKey(Schema.Array(Schema.String)), "user_ids": Schema.optionalKey(Schema.Array(Schema.String)), "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)), "models": Schema.optionalKey(Schema.Array(Schema.String)), "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model"]))), "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "page": Schema.optionalKey(Schema.String) })
export type UsageEmbeddings200 = UsageResponse
export const UsageEmbeddings200 = Schema.suspend((): Schema.Codec<UsageResponse> => UsageResponse)
export type UsageImagesParams = { readonly "start_time": number, readonly "end_time"?: number, readonly "bucket_width"?: "1m" | "1h" | "1d", readonly "sources"?: ReadonlyArray<"image.generation" | "image.edit" | "image.variation">, readonly "sizes"?: ReadonlyArray<"256x256" | "512x512" | "1024x1024" | "1792x1792" | "1024x1792">, readonly "project_ids"?: ReadonlyArray<string>, readonly "user_ids"?: ReadonlyArray<string>, readonly "api_key_ids"?: ReadonlyArray<string>, readonly "models"?: ReadonlyArray<string>, readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model" | "size" | "source">, readonly "limit"?: number, readonly "page"?: string }
export const UsageImagesParams = Schema.Struct({ "start_time": Schema.Number.check(Schema.isInt()), "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"]).annotate({ "default": "1d" })), "sources": Schema.optionalKey(Schema.Array(Schema.Literals(["image.generation", "image.edit", "image.variation"]))), "sizes": Schema.optionalKey(Schema.Array(Schema.Literals(["256x256", "512x512", "1024x1024", "1792x1792", "1024x1792"]))), "project_ids": Schema.optionalKey(Schema.Array(Schema.String)), "user_ids": Schema.optionalKey(Schema.Array(Schema.String)), "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)), "models": Schema.optionalKey(Schema.Array(Schema.String)), "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model", "size", "source"]))), "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "page": Schema.optionalKey(Schema.String) })
export type UsageImages200 = UsageResponse
export const UsageImages200 = Schema.suspend((): Schema.Codec<UsageResponse> => UsageResponse)
export type UsageModerationsParams = { readonly "start_time": number, readonly "end_time"?: number, readonly "bucket_width"?: "1m" | "1h" | "1d", readonly "project_ids"?: ReadonlyArray<string>, readonly "user_ids"?: ReadonlyArray<string>, readonly "api_key_ids"?: ReadonlyArray<string>, readonly "models"?: ReadonlyArray<string>, readonly "group_by"?: ReadonlyArray<"project_id" | "user_id" | "api_key_id" | "model">, readonly "limit"?: number, readonly "page"?: string }
export const UsageModerationsParams = Schema.Struct({ "start_time": Schema.Number.check(Schema.isInt()), "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"]).annotate({ "default": "1d" })), "project_ids": Schema.optionalKey(Schema.Array(Schema.String)), "user_ids": Schema.optionalKey(Schema.Array(Schema.String)), "api_key_ids": Schema.optionalKey(Schema.Array(Schema.String)), "models": Schema.optionalKey(Schema.Array(Schema.String)), "group_by": Schema.optionalKey(Schema.Array(Schema.Literals(["project_id", "user_id", "api_key_id", "model"]))), "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "page": Schema.optionalKey(Schema.String) })
export type UsageModerations200 = UsageResponse
export const UsageModerations200 = Schema.suspend((): Schema.Codec<UsageResponse> => UsageResponse)
export type UsageVectorStoresParams = { readonly "start_time": number, readonly "end_time"?: number, readonly "bucket_width"?: "1m" | "1h" | "1d", readonly "project_ids"?: ReadonlyArray<string>, readonly "group_by"?: ReadonlyArray<"project_id">, readonly "limit"?: number, readonly "page"?: string }
export const UsageVectorStoresParams = Schema.Struct({ "start_time": Schema.Number.check(Schema.isInt()), "end_time": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "bucket_width": Schema.optionalKey(Schema.Literals(["1m", "1h", "1d"]).annotate({ "default": "1d" })), "project_ids": Schema.optionalKey(Schema.Array(Schema.String)), "group_by": Schema.optionalKey(Schema.Array(Schema.Literal("project_id"))), "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "page": Schema.optionalKey(Schema.String) })
export type UsageVectorStores200 = UsageResponse
export const UsageVectorStores200 = Schema.suspend((): Schema.Codec<UsageResponse> => UsageResponse)
export type ListUsersParams = { readonly "limit"?: number, readonly "after"?: string, readonly "emails"?: ReadonlyArray<string> }
export const ListUsersParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "emails": Schema.optionalKey(Schema.Array(Schema.String)) })
export type ListUsers200 = UserListResponse
export const ListUsers200 = UserListResponse
export type RetrieveUser200 = User
export const RetrieveUser200 = User
export type ListUserRoleAssignmentsParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListUserRoleAssignmentsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])) })
export type ListUserRoleAssignments200 = RoleListResource
export const ListUserRoleAssignments200 = Schema.suspend((): Schema.Codec<RoleListResource> => RoleListResource)
export type ListProjectGroupRoleAssignmentsParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListProjectGroupRoleAssignmentsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])) })
export type ListProjectGroupRoleAssignments200 = RoleListResource
export const ListProjectGroupRoleAssignments200 = Schema.suspend((): Schema.Codec<RoleListResource> => RoleListResource)
export type ListProjectRolesParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListProjectRolesParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 1000 }).check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "asc" })) })
export type ListProjectRoles200 = PublicRoleListResource
export const ListProjectRoles200 = Schema.suspend((): Schema.Codec<PublicRoleListResource> => PublicRoleListResource)
export type ListProjectUserRoleAssignmentsParams = { readonly "limit"?: number, readonly "after"?: string, readonly "order"?: "asc" | "desc" }
export const ListProjectUserRoleAssignmentsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "after": Schema.optionalKey(Schema.String), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])) })
export type ListProjectUserRoleAssignments200 = RoleListResource
export const ListProjectUserRoleAssignments200 = Schema.suspend((): Schema.Codec<RoleListResource> => RoleListResource)
export type GetResponseParams = { readonly "include"?: ReadonlyArray<IncludeEnum>, readonly "stream"?: boolean, readonly "starting_after"?: number, readonly "include_obfuscation"?: boolean }
export const GetResponseParams = Schema.Struct({ "include": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<IncludeEnum> => IncludeEnum))), "stream": Schema.optionalKey(Schema.Boolean), "starting_after": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "include_obfuscation": Schema.optionalKey(Schema.Boolean) })
export type GetResponse200 = Response
export const GetResponse200 = Response
export type ListInputItemsParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string, readonly "include"?: ReadonlyArray<IncludeEnum> }
export const ListInputItemsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"])), "after": Schema.optionalKey(Schema.String), "include": Schema.optionalKey(Schema.Array(Schema.suspend((): Schema.Codec<IncludeEnum> => IncludeEnum))) })
export type ListInputItems200 = ResponseItemList
export const ListInputItems200 = ResponseItemList
export type GetThread200 = ThreadObject
export const GetThread200 = ThreadObject
export type ListMessagesParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string, readonly "before"?: string, readonly "run_id"?: string }
export const ListMessagesParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })), "after": Schema.optionalKey(Schema.String), "before": Schema.optionalKey(Schema.String), "run_id": Schema.optionalKey(Schema.String) })
export type ListMessages200 = ListMessagesResponse
export const ListMessages200 = ListMessagesResponse
export type GetMessage200 = MessageObject
export const GetMessage200 = MessageObject
export type ListRunsParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string, readonly "before"?: string }
export const ListRunsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })), "after": Schema.optionalKey(Schema.String), "before": Schema.optionalKey(Schema.String) })
export type ListRuns200 = ListRunsResponse
export const ListRuns200 = ListRunsResponse
export type GetRun200 = RunObject
export const GetRun200 = RunObject
export type ListRunStepsParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string, readonly "before"?: string, readonly "include[]"?: ReadonlyArray<"step_details.tool_calls[*].file_search.results[*].content"> }
export const ListRunStepsParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })), "after": Schema.optionalKey(Schema.String), "before": Schema.optionalKey(Schema.String), "include[]": Schema.optionalKey(Schema.Array(Schema.Literal("step_details.tool_calls[*].file_search.results[*].content"))) })
export type ListRunSteps200 = ListRunStepsResponse
export const ListRunSteps200 = ListRunStepsResponse
export type GetRunStepParams = { readonly "include[]"?: ReadonlyArray<"step_details.tool_calls[*].file_search.results[*].content"> }
export const GetRunStepParams = Schema.Struct({ "include[]": Schema.optionalKey(Schema.Array(Schema.Literal("step_details.tool_calls[*].file_search.results[*].content"))) })
export type GetRunStep200 = RunStepObject
export const GetRunStep200 = RunStepObject
export type ListVectorStoresParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string, readonly "before"?: string }
export const ListVectorStoresParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })), "after": Schema.optionalKey(Schema.String), "before": Schema.optionalKey(Schema.String) })
export type ListVectorStores200 = ListVectorStoresResponse
export const ListVectorStores200 = ListVectorStoresResponse
export type GetVectorStore200 = VectorStoreObject
export const GetVectorStore200 = VectorStoreObject
export type GetVectorStoreFileBatch200 = VectorStoreFileBatchObject
export const GetVectorStoreFileBatch200 = VectorStoreFileBatchObject
export type ListFilesInVectorStoreBatchParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string, readonly "before"?: string, readonly "filter"?: "in_progress" | "completed" | "failed" | "cancelled" }
export const ListFilesInVectorStoreBatchParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })), "after": Schema.optionalKey(Schema.String), "before": Schema.optionalKey(Schema.String), "filter": Schema.optionalKey(Schema.Literals(["in_progress", "completed", "failed", "cancelled"])) })
export type ListFilesInVectorStoreBatch200 = ListVectorStoreFilesResponse
export const ListFilesInVectorStoreBatch200 = ListVectorStoreFilesResponse
export type ListVectorStoreFilesParams = { readonly "limit"?: number, readonly "order"?: "asc" | "desc", readonly "after"?: string, readonly "before"?: string, readonly "filter"?: "in_progress" | "completed" | "failed" | "cancelled" }
export const ListVectorStoreFilesParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.annotate({ "default": 20 }).check(Schema.isInt())), "order": Schema.optionalKey(Schema.Literals(["asc", "desc"]).annotate({ "default": "desc" })), "after": Schema.optionalKey(Schema.String), "before": Schema.optionalKey(Schema.String), "filter": Schema.optionalKey(Schema.Literals(["in_progress", "completed", "failed", "cancelled"])) })
export type ListVectorStoreFiles200 = ListVectorStoreFilesResponse
export const ListVectorStoreFiles200 = Schema.suspend((): Schema.Codec<ListVectorStoreFilesResponse> => ListVectorStoreFilesResponse)
export type GetVectorStoreFile200 = VectorStoreFileObject
export const GetVectorStoreFile200 = VectorStoreFileObject
export type RetrieveVectorStoreFileContent200 = VectorStoreFileContentResponse
export const RetrieveVectorStoreFileContent200 = VectorStoreFileContentResponse
export type GetConversation200 = ConversationResource
export const GetConversation200 = ConversationResource
export type ListVideosParams = { readonly "limit"?: number, readonly "order"?: OrderEnum, readonly "after"?: string }
export const ListVideosParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "order": Schema.optionalKey(OrderEnum), "after": Schema.optionalKey(Schema.String.annotate({ "description": "Identifier for the last item from the previous pagination request" })) })
export type ListVideos200 = VideoListResource
export const ListVideos200 = VideoListResource
export type GetVideo200 = VideoResource
export const GetVideo200 = VideoResource
export type RetrieveVideoContentParams = { readonly "variant"?: VideoContentVariant }
export const RetrieveVideoContentParams = Schema.Struct({ "variant": Schema.optionalKey(VideoContentVariant) })
export type RetrieveVideoContent200 = string
export const RetrieveVideoContent200 = Schema.String
export type ListThreadItemsMethodParams = { readonly "limit"?: number, readonly "order"?: OrderEnum, readonly "after"?: string, readonly "before"?: string }
export const ListThreadItemsMethodParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "order": Schema.optionalKey(Schema.suspend((): Schema.Codec<OrderEnum> => OrderEnum)), "after": Schema.optionalKey(Schema.String.annotate({ "description": "List items created after this thread item ID. Defaults to null for the first page." })), "before": Schema.optionalKey(Schema.String.annotate({ "description": "List items created before this thread item ID. Defaults to null for the newest results." })) })
export type ListThreadItemsMethod200 = ThreadItemListResource
export const ListThreadItemsMethod200 = ThreadItemListResource
export type GetThreadMethod200 = ThreadResource
export const GetThreadMethod200 = ThreadResource
export type ListThreadsMethodParams = { readonly "limit"?: number, readonly "order"?: OrderEnum, readonly "after"?: string, readonly "before"?: string, readonly "user"?: string }
export const ListThreadsMethodParams = Schema.Struct({ "limit": Schema.optionalKey(Schema.Number.check(Schema.isInt())), "order": Schema.optionalKey(Schema.suspend((): Schema.Codec<OrderEnum> => OrderEnum)), "after": Schema.optionalKey(Schema.String.annotate({ "description": "List items created after this thread item ID. Defaults to null for the first page." })), "before": Schema.optionalKey(Schema.String.annotate({ "description": "List items created before this thread item ID. Defaults to null for the newest results." })), "user": Schema.optionalKey(Schema.String.annotate({ "description": "Filter threads that belong to this user identifier. Defaults to null to return all users." })) })
export type ListThreadsMethod200 = ThreadListResource
export const ListThreadsMethod200 = ThreadListResource

export interface OperationConfig {
  /**
   * Whether or not the response should be included in the value returned from
   * an operation.
   *
   * If set to \`true\`, a tuple of \`[A, HttpClientResponse]\` will be returned,
   * where \`A\` is the success type of the operation.
   *
   * If set to \`false\`, only the success type of the operation will be returned.
   */
  readonly includeResponse?: boolean | undefined
}

/**
 * A utility type which optionally includes the response in the return result
 * of an operation based upon the value of the \`includeResponse\` configuration
 * option.
 */
export type WithOptionalResponse<A, Config extends OperationConfig> = Config extends {
  readonly includeResponse: true
} ? [A, HttpClientResponse.HttpClientResponse] : A

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): TestClient => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse = <Config extends OperationConfig>(config: Config | undefined) => <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ): (request: HttpClientRequest.HttpClientRequest) => Effect.Effect<any, any> => {
    const withOptionalResponse = (
      config?.includeResponse
        ? (response: HttpClientResponse.HttpClientResponse) => Effect.map(f(response), (a) => [a, response])
        : (response: HttpClientResponse.HttpClientResponse) => f(response)
    ) as any
    return options?.transformClient
      ? (request) =>
          Effect.flatMap(
            Effect.flatMap(options.transformClient!(httpClient), (client) => client.execute(request)),
            withOptionalResponse
          )
      : (request) => Effect.flatMap(httpClient.execute(request), withOptionalResponse)
  }
  const decodeSuccess =
    <Schema extends Schema.Top>(schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, Schema extends Schema.Top>(tag: Tag, schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(TestClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "listAssistants": (options) => HttpClientRequest.get(\`/assistants\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListAssistants200),
      orElse: unexpectedStatus
    }))
  ),
  "getAssistant": (assistantId, options) => HttpClientRequest.get(\`/assistants/\${assistantId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetAssistant200),
      orElse: unexpectedStatus
    }))
  ),
  "listVoiceConsents": (options) => HttpClientRequest.get(\`/audio/voice_consents\`).pipe(
    HttpClientRequest.setUrlParams({ "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListVoiceConsents200),
      orElse: unexpectedStatus
    }))
  ),
  "getVoiceConsent": (consentId, options) => HttpClientRequest.get(\`/audio/voice_consents/\${consentId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetVoiceConsent200),
      orElse: unexpectedStatus
    }))
  ),
  "listBatches": (options) => HttpClientRequest.get(\`/batches\`).pipe(
    HttpClientRequest.setUrlParams({ "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListBatches200),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveBatch": (batchId, options) => HttpClientRequest.get(\`/batches/\${batchId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveBatch200),
      orElse: unexpectedStatus
    }))
  ),
  "listChatCompletions": (options) => HttpClientRequest.get(\`/chat/completions\`).pipe(
    HttpClientRequest.setUrlParams({ "model": options?.params?.["model"] as any, "metadata": options?.params?.["metadata"] as any, "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListChatCompletions200),
      orElse: unexpectedStatus
    }))
  ),
  "getChatCompletion": (completionId, options) => HttpClientRequest.get(\`/chat/completions/\${completionId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetChatCompletion200),
      orElse: unexpectedStatus
    }))
  ),
  "getChatCompletionMessages": (completionId, options) => HttpClientRequest.get(\`/chat/completions/\${completionId}/messages\`).pipe(
    HttpClientRequest.setUrlParams({ "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetChatCompletionMessages200),
      orElse: unexpectedStatus
    }))
  ),
  "ListContainers": (options) => HttpClientRequest.get(\`/containers\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListContainers200),
      orElse: unexpectedStatus
    }))
  ),
  "RetrieveContainer": (containerId, options) => HttpClientRequest.get(\`/containers/\${containerId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveContainer200),
      orElse: unexpectedStatus
    }))
  ),
  "ListContainerFiles": (containerId, options) => HttpClientRequest.get(\`/containers/\${containerId}/files\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListContainerFiles200),
      orElse: unexpectedStatus
    }))
  ),
  "RetrieveContainerFile": (containerId, fileId, options) => HttpClientRequest.get(\`/containers/\${containerId}/files/\${fileId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveContainerFile200),
      orElse: unexpectedStatus
    }))
  ),
  "RetrieveContainerFileContent": (containerId, fileId, options) => HttpClientRequest.get(\`/containers/\${containerId}/files/\${fileId}/content\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "200": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "listConversationItems": (conversationId, options) => HttpClientRequest.get(\`/conversations/\${conversationId}/items\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "include": options?.params?.["include"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListConversationItems200),
      orElse: unexpectedStatus
    }))
  ),
  "getConversationItem": (conversationId, itemId, options) => HttpClientRequest.get(\`/conversations/\${conversationId}/items/\${itemId}\`).pipe(
    HttpClientRequest.setUrlParams({ "include": options?.params?.["include"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetConversationItem200),
      orElse: unexpectedStatus
    }))
  ),
  "listEvals": (options) => HttpClientRequest.get(\`/evals\`).pipe(
    HttpClientRequest.setUrlParams({ "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "order_by": options?.params?.["order_by"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListEvals200),
      orElse: unexpectedStatus
    }))
  ),
  "getEval": (evalId, options) => HttpClientRequest.get(\`/evals/\${evalId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetEval200),
      orElse: unexpectedStatus
    }))
  ),
  "getEvalRuns": (evalId, options) => HttpClientRequest.get(\`/evals/\${evalId}/runs\`).pipe(
    HttpClientRequest.setUrlParams({ "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "status": options?.params?.["status"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetEvalRuns200),
      orElse: unexpectedStatus
    }))
  ),
  "getEvalRun": (evalId, runId, options) => HttpClientRequest.get(\`/evals/\${evalId}/runs/\${runId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetEvalRun200),
      orElse: unexpectedStatus
    }))
  ),
  "getEvalRunOutputItems": (evalId, runId, options) => HttpClientRequest.get(\`/evals/\${evalId}/runs/\${runId}/output_items\`).pipe(
    HttpClientRequest.setUrlParams({ "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any, "status": options?.params?.["status"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetEvalRunOutputItems200),
      orElse: unexpectedStatus
    }))
  ),
  "getEvalRunOutputItem": (evalId, runId, outputItemId, options) => HttpClientRequest.get(\`/evals/\${evalId}/runs/\${runId}/output_items/\${outputItemId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetEvalRunOutputItem200),
      orElse: unexpectedStatus
    }))
  ),
  "listFiles": (options) => HttpClientRequest.get(\`/files\`).pipe(
    HttpClientRequest.setUrlParams({ "purpose": options?.params?.["purpose"] as any, "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListFiles200),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveFile": (fileId, options) => HttpClientRequest.get(\`/files/\${fileId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveFile200),
      orElse: unexpectedStatus
    }))
  ),
  "downloadFile": (fileId, options) => HttpClientRequest.get(\`/files/\${fileId}/content\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(DownloadFile200),
      orElse: unexpectedStatus
    }))
  ),
  "listFineTuningCheckpointPermissions": (fineTunedModelCheckpoint, options) => HttpClientRequest.get(\`/fine_tuning/checkpoints/\${fineTunedModelCheckpoint}/permissions\`).pipe(
    HttpClientRequest.setUrlParams({ "project_id": options?.params?.["project_id"] as any, "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListFineTuningCheckpointPermissions200),
      orElse: unexpectedStatus
    }))
  ),
  "listPaginatedFineTuningJobs": (options) => HttpClientRequest.get(\`/fine_tuning/jobs\`).pipe(
    HttpClientRequest.setUrlParams({ "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any, "metadata": options?.params?.["metadata"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListPaginatedFineTuningJobs200),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveFineTuningJob": (fineTuningJobId, options) => HttpClientRequest.get(\`/fine_tuning/jobs/\${fineTuningJobId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveFineTuningJob200),
      orElse: unexpectedStatus
    }))
  ),
  "listFineTuningJobCheckpoints": (fineTuningJobId, options) => HttpClientRequest.get(\`/fine_tuning/jobs/\${fineTuningJobId}/checkpoints\`).pipe(
    HttpClientRequest.setUrlParams({ "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListFineTuningJobCheckpoints200),
      orElse: unexpectedStatus
    }))
  ),
  "listFineTuningEvents": (fineTuningJobId, options) => HttpClientRequest.get(\`/fine_tuning/jobs/\${fineTuningJobId}/events\`).pipe(
    HttpClientRequest.setUrlParams({ "after": options?.params?.["after"] as any, "limit": options?.params?.["limit"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListFineTuningEvents200),
      orElse: unexpectedStatus
    }))
  ),
  "listModels": (options) => HttpClientRequest.get(\`/models\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListModels200),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveModel": (model, options) => HttpClientRequest.get(\`/models/\${model}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveModel200),
      orElse: unexpectedStatus
    }))
  ),
  "adminApiKeysList": (options) => HttpClientRequest.get(\`/organization/admin_api_keys\`).pipe(
    HttpClientRequest.setUrlParams({ "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any, "limit": options?.params?.["limit"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AdminApiKeysList200),
      orElse: unexpectedStatus
    }))
  ),
  "adminApiKeysGet": (keyId, options) => HttpClientRequest.get(\`/organization/admin_api_keys/\${keyId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AdminApiKeysGet200),
      orElse: unexpectedStatus
    }))
  ),
  "listAuditLogs": (options) => HttpClientRequest.get(\`/organization/audit_logs\`).pipe(
    HttpClientRequest.setUrlParams({ "effective_at[gt]": options?.params?.["effective_at[gt]"] as any, "effective_at[gte]": options?.params?.["effective_at[gte]"] as any, "effective_at[lt]": options?.params?.["effective_at[lt]"] as any, "effective_at[lte]": options?.params?.["effective_at[lte]"] as any, "project_ids[]": options?.params?.["project_ids[]"] as any, "event_types[]": options?.params?.["event_types[]"] as any, "actor_ids[]": options?.params?.["actor_ids[]"] as any, "actor_emails[]": options?.params?.["actor_emails[]"] as any, "resource_ids[]": options?.params?.["resource_ids[]"] as any, "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListAuditLogs200),
      orElse: unexpectedStatus
    }))
  ),
  "listOrganizationCertificates": (options) => HttpClientRequest.get(\`/organization/certificates\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListOrganizationCertificates200),
      orElse: unexpectedStatus
    }))
  ),
  "getCertificate": (certificateId, options) => HttpClientRequest.get(\`/organization/certificates/\${certificateId}\`).pipe(
    HttpClientRequest.setUrlParams({ "include": options?.params?.["include"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetCertificate200),
      orElse: unexpectedStatus
    }))
  ),
  "usageCosts": (options) => HttpClientRequest.get(\`/organization/costs\`).pipe(
    HttpClientRequest.setUrlParams({ "start_time": options.params["start_time"] as any, "end_time": options.params["end_time"] as any, "bucket_width": options.params["bucket_width"] as any, "project_ids": options.params["project_ids"] as any, "group_by": options.params["group_by"] as any, "limit": options.params["limit"] as any, "page": options.params["page"] as any }),
    withResponse(options.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UsageCosts200),
      orElse: unexpectedStatus
    }))
  ),
  "listGroups": (options) => HttpClientRequest.get(\`/organization/groups\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListGroups200),
      orElse: unexpectedStatus
    }))
  ),
  "listGroupRoleAssignments": (groupId, options) => HttpClientRequest.get(\`/organization/groups/\${groupId}/roles\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListGroupRoleAssignments200),
      orElse: unexpectedStatus
    }))
  ),
  "listGroupUsers": (groupId, options) => HttpClientRequest.get(\`/organization/groups/\${groupId}/users\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListGroupUsers200),
      orElse: unexpectedStatus
    }))
  ),
  "listInvites": (options) => HttpClientRequest.get(\`/organization/invites\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListInvites200),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveInvite": (inviteId, options) => HttpClientRequest.get(\`/organization/invites/\${inviteId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveInvite200),
      orElse: unexpectedStatus
    }))
  ),
  "listProjects": (options) => HttpClientRequest.get(\`/organization/projects\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "include_archived": options?.params?.["include_archived"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListProjects200),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveProject": (projectId, options) => HttpClientRequest.get(\`/organization/projects/\${projectId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveProject200),
      orElse: unexpectedStatus
    }))
  ),
  "listProjectApiKeys": (projectId, options) => HttpClientRequest.get(\`/organization/projects/\${projectId}/api_keys\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListProjectApiKeys200),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveProjectApiKey": (projectId, keyId, options) => HttpClientRequest.get(\`/organization/projects/\${projectId}/api_keys/\${keyId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveProjectApiKey200),
      orElse: unexpectedStatus
    }))
  ),
  "listProjectCertificates": (projectId, options) => HttpClientRequest.get(\`/organization/projects/\${projectId}/certificates\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListProjectCertificates200),
      orElse: unexpectedStatus
    }))
  ),
  "listProjectGroups": (projectId, options) => HttpClientRequest.get(\`/organization/projects/\${projectId}/groups\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListProjectGroups200),
      orElse: unexpectedStatus
    }))
  ),
  "listProjectRateLimits": (projectId, options) => HttpClientRequest.get(\`/organization/projects/\${projectId}/rate_limits\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListProjectRateLimits200),
      orElse: unexpectedStatus
    }))
  ),
  "listProjectServiceAccounts": (projectId, options) => HttpClientRequest.get(\`/organization/projects/\${projectId}/service_accounts\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListProjectServiceAccounts200),
      "400": decodeError("ListProjectServiceAccounts400", ListProjectServiceAccounts400),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveProjectServiceAccount": (projectId, serviceAccountId, options) => HttpClientRequest.get(\`/organization/projects/\${projectId}/service_accounts/\${serviceAccountId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveProjectServiceAccount200),
      orElse: unexpectedStatus
    }))
  ),
  "listProjectUsers": (projectId, options) => HttpClientRequest.get(\`/organization/projects/\${projectId}/users\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListProjectUsers200),
      "400": decodeError("ListProjectUsers400", ListProjectUsers400),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveProjectUser": (projectId, userId, options) => HttpClientRequest.get(\`/organization/projects/\${projectId}/users/\${userId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveProjectUser200),
      orElse: unexpectedStatus
    }))
  ),
  "listRoles": (options) => HttpClientRequest.get(\`/organization/roles\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListRoles200),
      orElse: unexpectedStatus
    }))
  ),
  "usageAudioSpeeches": (options) => HttpClientRequest.get(\`/organization/usage/audio_speeches\`).pipe(
    HttpClientRequest.setUrlParams({ "start_time": options.params["start_time"] as any, "end_time": options.params["end_time"] as any, "bucket_width": options.params["bucket_width"] as any, "project_ids": options.params["project_ids"] as any, "user_ids": options.params["user_ids"] as any, "api_key_ids": options.params["api_key_ids"] as any, "models": options.params["models"] as any, "group_by": options.params["group_by"] as any, "limit": options.params["limit"] as any, "page": options.params["page"] as any }),
    withResponse(options.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UsageAudioSpeeches200),
      orElse: unexpectedStatus
    }))
  ),
  "usageAudioTranscriptions": (options) => HttpClientRequest.get(\`/organization/usage/audio_transcriptions\`).pipe(
    HttpClientRequest.setUrlParams({ "start_time": options.params["start_time"] as any, "end_time": options.params["end_time"] as any, "bucket_width": options.params["bucket_width"] as any, "project_ids": options.params["project_ids"] as any, "user_ids": options.params["user_ids"] as any, "api_key_ids": options.params["api_key_ids"] as any, "models": options.params["models"] as any, "group_by": options.params["group_by"] as any, "limit": options.params["limit"] as any, "page": options.params["page"] as any }),
    withResponse(options.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UsageAudioTranscriptions200),
      orElse: unexpectedStatus
    }))
  ),
  "usageCodeInterpreterSessions": (options) => HttpClientRequest.get(\`/organization/usage/code_interpreter_sessions\`).pipe(
    HttpClientRequest.setUrlParams({ "start_time": options.params["start_time"] as any, "end_time": options.params["end_time"] as any, "bucket_width": options.params["bucket_width"] as any, "project_ids": options.params["project_ids"] as any, "group_by": options.params["group_by"] as any, "limit": options.params["limit"] as any, "page": options.params["page"] as any }),
    withResponse(options.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UsageCodeInterpreterSessions200),
      orElse: unexpectedStatus
    }))
  ),
  "usageCompletions": (options) => HttpClientRequest.get(\`/organization/usage/completions\`).pipe(
    HttpClientRequest.setUrlParams({ "start_time": options.params["start_time"] as any, "end_time": options.params["end_time"] as any, "bucket_width": options.params["bucket_width"] as any, "project_ids": options.params["project_ids"] as any, "user_ids": options.params["user_ids"] as any, "api_key_ids": options.params["api_key_ids"] as any, "models": options.params["models"] as any, "batch": options.params["batch"] as any, "group_by": options.params["group_by"] as any, "limit": options.params["limit"] as any, "page": options.params["page"] as any }),
    withResponse(options.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UsageCompletions200),
      orElse: unexpectedStatus
    }))
  ),
  "usageEmbeddings": (options) => HttpClientRequest.get(\`/organization/usage/embeddings\`).pipe(
    HttpClientRequest.setUrlParams({ "start_time": options.params["start_time"] as any, "end_time": options.params["end_time"] as any, "bucket_width": options.params["bucket_width"] as any, "project_ids": options.params["project_ids"] as any, "user_ids": options.params["user_ids"] as any, "api_key_ids": options.params["api_key_ids"] as any, "models": options.params["models"] as any, "group_by": options.params["group_by"] as any, "limit": options.params["limit"] as any, "page": options.params["page"] as any }),
    withResponse(options.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UsageEmbeddings200),
      orElse: unexpectedStatus
    }))
  ),
  "usageImages": (options) => HttpClientRequest.get(\`/organization/usage/images\`).pipe(
    HttpClientRequest.setUrlParams({ "start_time": options.params["start_time"] as any, "end_time": options.params["end_time"] as any, "bucket_width": options.params["bucket_width"] as any, "sources": options.params["sources"] as any, "sizes": options.params["sizes"] as any, "project_ids": options.params["project_ids"] as any, "user_ids": options.params["user_ids"] as any, "api_key_ids": options.params["api_key_ids"] as any, "models": options.params["models"] as any, "group_by": options.params["group_by"] as any, "limit": options.params["limit"] as any, "page": options.params["page"] as any }),
    withResponse(options.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UsageImages200),
      orElse: unexpectedStatus
    }))
  ),
  "usageModerations": (options) => HttpClientRequest.get(\`/organization/usage/moderations\`).pipe(
    HttpClientRequest.setUrlParams({ "start_time": options.params["start_time"] as any, "end_time": options.params["end_time"] as any, "bucket_width": options.params["bucket_width"] as any, "project_ids": options.params["project_ids"] as any, "user_ids": options.params["user_ids"] as any, "api_key_ids": options.params["api_key_ids"] as any, "models": options.params["models"] as any, "group_by": options.params["group_by"] as any, "limit": options.params["limit"] as any, "page": options.params["page"] as any }),
    withResponse(options.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UsageModerations200),
      orElse: unexpectedStatus
    }))
  ),
  "usageVectorStores": (options) => HttpClientRequest.get(\`/organization/usage/vector_stores\`).pipe(
    HttpClientRequest.setUrlParams({ "start_time": options.params["start_time"] as any, "end_time": options.params["end_time"] as any, "bucket_width": options.params["bucket_width"] as any, "project_ids": options.params["project_ids"] as any, "group_by": options.params["group_by"] as any, "limit": options.params["limit"] as any, "page": options.params["page"] as any }),
    withResponse(options.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UsageVectorStores200),
      orElse: unexpectedStatus
    }))
  ),
  "listUsers": (options) => HttpClientRequest.get(\`/organization/users\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "emails": options?.params?.["emails"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListUsers200),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveUser": (userId, options) => HttpClientRequest.get(\`/organization/users/\${userId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveUser200),
      orElse: unexpectedStatus
    }))
  ),
  "listUserRoleAssignments": (userId, options) => HttpClientRequest.get(\`/organization/users/\${userId}/roles\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListUserRoleAssignments200),
      orElse: unexpectedStatus
    }))
  ),
  "listProjectGroupRoleAssignments": (projectId, groupId, options) => HttpClientRequest.get(\`/projects/\${projectId}/groups/\${groupId}/roles\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListProjectGroupRoleAssignments200),
      orElse: unexpectedStatus
    }))
  ),
  "listProjectRoles": (projectId, options) => HttpClientRequest.get(\`/projects/\${projectId}/roles\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListProjectRoles200),
      orElse: unexpectedStatus
    }))
  ),
  "listProjectUserRoleAssignments": (projectId, userId, options) => HttpClientRequest.get(\`/projects/\${projectId}/users/\${userId}/roles\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "after": options?.params?.["after"] as any, "order": options?.params?.["order"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListProjectUserRoleAssignments200),
      orElse: unexpectedStatus
    }))
  ),
  "getResponse": (responseId, options) => HttpClientRequest.get(\`/responses/\${responseId}\`).pipe(
    HttpClientRequest.setUrlParams({ "include": options?.params?.["include"] as any, "stream": options?.params?.["stream"] as any, "starting_after": options?.params?.["starting_after"] as any, "include_obfuscation": options?.params?.["include_obfuscation"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetResponse200),
      orElse: unexpectedStatus
    }))
  ),
  "listInputItems": (responseId, options) => HttpClientRequest.get(\`/responses/\${responseId}/input_items\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "include": options?.params?.["include"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListInputItems200),
      orElse: unexpectedStatus
    }))
  ),
  "getThread": (threadId, options) => HttpClientRequest.get(\`/threads/\${threadId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetThread200),
      orElse: unexpectedStatus
    }))
  ),
  "listMessages": (threadId, options) => HttpClientRequest.get(\`/threads/\${threadId}/messages\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any, "run_id": options?.params?.["run_id"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListMessages200),
      orElse: unexpectedStatus
    }))
  ),
  "getMessage": (threadId, messageId, options) => HttpClientRequest.get(\`/threads/\${threadId}/messages/\${messageId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetMessage200),
      orElse: unexpectedStatus
    }))
  ),
  "listRuns": (threadId, options) => HttpClientRequest.get(\`/threads/\${threadId}/runs\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListRuns200),
      orElse: unexpectedStatus
    }))
  ),
  "getRun": (threadId, runId, options) => HttpClientRequest.get(\`/threads/\${threadId}/runs/\${runId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetRun200),
      orElse: unexpectedStatus
    }))
  ),
  "listRunSteps": (threadId, runId, options) => HttpClientRequest.get(\`/threads/\${threadId}/runs/\${runId}/steps\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any, "include[]": options?.params?.["include[]"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListRunSteps200),
      orElse: unexpectedStatus
    }))
  ),
  "getRunStep": (threadId, runId, stepId, options) => HttpClientRequest.get(\`/threads/\${threadId}/runs/\${runId}/steps/\${stepId}\`).pipe(
    HttpClientRequest.setUrlParams({ "include[]": options?.params?.["include[]"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetRunStep200),
      orElse: unexpectedStatus
    }))
  ),
  "listVectorStores": (options) => HttpClientRequest.get(\`/vector_stores\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListVectorStores200),
      orElse: unexpectedStatus
    }))
  ),
  "getVectorStore": (vectorStoreId, options) => HttpClientRequest.get(\`/vector_stores/\${vectorStoreId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetVectorStore200),
      orElse: unexpectedStatus
    }))
  ),
  "getVectorStoreFileBatch": (vectorStoreId, batchId, options) => HttpClientRequest.get(\`/vector_stores/\${vectorStoreId}/file_batches/\${batchId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetVectorStoreFileBatch200),
      orElse: unexpectedStatus
    }))
  ),
  "listFilesInVectorStoreBatch": (vectorStoreId, batchId, options) => HttpClientRequest.get(\`/vector_stores/\${vectorStoreId}/file_batches/\${batchId}/files\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any, "filter": options?.params?.["filter"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListFilesInVectorStoreBatch200),
      orElse: unexpectedStatus
    }))
  ),
  "listVectorStoreFiles": (vectorStoreId, options) => HttpClientRequest.get(\`/vector_stores/\${vectorStoreId}/files\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any, "filter": options?.params?.["filter"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListVectorStoreFiles200),
      orElse: unexpectedStatus
    }))
  ),
  "getVectorStoreFile": (vectorStoreId, fileId, options) => HttpClientRequest.get(\`/vector_stores/\${vectorStoreId}/files/\${fileId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetVectorStoreFile200),
      orElse: unexpectedStatus
    }))
  ),
  "retrieveVectorStoreFileContent": (vectorStoreId, fileId, options) => HttpClientRequest.get(\`/vector_stores/\${vectorStoreId}/files/\${fileId}/content\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveVectorStoreFileContent200),
      orElse: unexpectedStatus
    }))
  ),
  "getConversation": (conversationId, options) => HttpClientRequest.get(\`/conversations/\${conversationId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetConversation200),
      orElse: unexpectedStatus
    }))
  ),
  "ListVideos": (options) => HttpClientRequest.get(\`/videos\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListVideos200),
      orElse: unexpectedStatus
    }))
  ),
  "GetVideo": (videoId, options) => HttpClientRequest.get(\`/videos/\${videoId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetVideo200),
      orElse: unexpectedStatus
    }))
  ),
  "RetrieveVideoContent": (videoId, options) => HttpClientRequest.get(\`/videos/\${videoId}/content\`).pipe(
    HttpClientRequest.setUrlParams({ "variant": options?.params?.["variant"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(RetrieveVideoContent200),
      orElse: unexpectedStatus
    }))
  ),
  "ListThreadItemsMethod": (threadId, options) => HttpClientRequest.get(\`/chatkit/threads/\${threadId}/items\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListThreadItemsMethod200),
      orElse: unexpectedStatus
    }))
  ),
  "GetThreadMethod": (threadId, options) => HttpClientRequest.get(\`/chatkit/threads/\${threadId}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetThreadMethod200),
      orElse: unexpectedStatus
    }))
  ),
  "ListThreadsMethod": (options) => HttpClientRequest.get(\`/chatkit/threads\`).pipe(
    HttpClientRequest.setUrlParams({ "limit": options?.params?.["limit"] as any, "order": options?.params?.["order"] as any, "after": options?.params?.["after"] as any, "before": options?.params?.["before"] as any, "user": options?.params?.["user"] as any }),
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ListThreadsMethod200),
      orElse: unexpectedStatus
    }))
  )
  }
}

export interface TestClient {
  readonly httpClient: HttpClient.HttpClient
  /**
* Returns a list of assistants.
*/
readonly "listAssistants": <Config extends OperationConfig>(options: { readonly params?: typeof ListAssistantsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListAssistants200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves an assistant.
*/
readonly "getAssistant": <Config extends OperationConfig>(assistantId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetAssistant200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of voice consent recordings.
*/
readonly "listVoiceConsents": <Config extends OperationConfig>(options: { readonly params?: typeof ListVoiceConsentsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListVoiceConsents200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a voice consent recording.
*/
readonly "getVoiceConsent": <Config extends OperationConfig>(consentId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetVoiceConsent200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List your organization's batches.
*/
readonly "listBatches": <Config extends OperationConfig>(options: { readonly params?: typeof ListBatchesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListBatches200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a batch.
*/
readonly "retrieveBatch": <Config extends OperationConfig>(batchId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveBatch200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List stored Chat Completions. Only Chat Completions that have been stored
* with the \`store\` parameter set to \`true\` will be returned.
*/
readonly "listChatCompletions": <Config extends OperationConfig>(options: { readonly params?: typeof ListChatCompletionsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListChatCompletions200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get a stored chat completion. Only Chat Completions that have been created
* with the \`store\` parameter set to \`true\` will be returned.
*/
readonly "getChatCompletion": <Config extends OperationConfig>(completionId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetChatCompletion200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get the messages in a stored chat completion. Only Chat Completions that
* have been created with the \`store\` parameter set to \`true\` will be
* returned.
*/
readonly "getChatCompletionMessages": <Config extends OperationConfig>(completionId: string, options: { readonly params?: typeof GetChatCompletionMessagesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetChatCompletionMessages200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List Containers
*/
readonly "ListContainers": <Config extends OperationConfig>(options: { readonly params?: typeof ListContainersParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListContainers200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieve Container
*/
readonly "RetrieveContainer": <Config extends OperationConfig>(containerId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveContainer200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List Container files
*/
readonly "ListContainerFiles": <Config extends OperationConfig>(containerId: string, options: { readonly params?: typeof ListContainerFilesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListContainerFiles200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieve Container File
*/
readonly "RetrieveContainerFile": <Config extends OperationConfig>(containerId: string, fileId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveContainerFile200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieve Container File Content
*/
readonly "RetrieveContainerFileContent": <Config extends OperationConfig>(containerId: string, fileId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<void, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List all items for a conversation with the given ID.
*/
readonly "listConversationItems": <Config extends OperationConfig>(conversationId: string, options: { readonly params?: typeof ListConversationItemsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListConversationItems200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get a single item from a conversation with the given IDs.
*/
readonly "getConversationItem": <Config extends OperationConfig>(conversationId: string, itemId: string, options: { readonly params?: typeof GetConversationItemParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetConversationItem200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List evaluations for a project.
*/
readonly "listEvals": <Config extends OperationConfig>(options: { readonly params?: typeof ListEvalsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListEvals200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get an evaluation by ID.
*/
readonly "getEval": <Config extends OperationConfig>(evalId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetEval200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get a list of runs for an evaluation.
*/
readonly "getEvalRuns": <Config extends OperationConfig>(evalId: string, options: { readonly params?: typeof GetEvalRunsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetEvalRuns200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get an evaluation run by ID.
*/
readonly "getEvalRun": <Config extends OperationConfig>(evalId: string, runId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetEvalRun200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get a list of output items for an evaluation run.
*/
readonly "getEvalRunOutputItems": <Config extends OperationConfig>(evalId: string, runId: string, options: { readonly params?: typeof GetEvalRunOutputItemsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetEvalRunOutputItems200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get an evaluation run output item by ID.
*/
readonly "getEvalRunOutputItem": <Config extends OperationConfig>(evalId: string, runId: string, outputItemId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetEvalRunOutputItem200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of files.
*/
readonly "listFiles": <Config extends OperationConfig>(options: { readonly params?: typeof ListFilesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListFiles200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns information about a specific file.
*/
readonly "retrieveFile": <Config extends OperationConfig>(fileId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveFile200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns the contents of the specified file.
*/
readonly "downloadFile": <Config extends OperationConfig>(fileId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof DownloadFile200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
* 
* Organization owners can use this endpoint to view all permissions for a fine-tuned model checkpoint.
*/
readonly "listFineTuningCheckpointPermissions": <Config extends OperationConfig>(fineTunedModelCheckpoint: string, options: { readonly params?: typeof ListFineTuningCheckpointPermissionsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListFineTuningCheckpointPermissions200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List your organization's fine-tuning jobs
*/
readonly "listPaginatedFineTuningJobs": <Config extends OperationConfig>(options: { readonly params?: typeof ListPaginatedFineTuningJobsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListPaginatedFineTuningJobs200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get info about a fine-tuning job.
* 
* [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
*/
readonly "retrieveFineTuningJob": <Config extends OperationConfig>(fineTuningJobId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveFineTuningJob200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List checkpoints for a fine-tuning job.
*/
readonly "listFineTuningJobCheckpoints": <Config extends OperationConfig>(fineTuningJobId: string, options: { readonly params?: typeof ListFineTuningJobCheckpointsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListFineTuningJobCheckpoints200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get status updates for a fine-tuning job.
*/
readonly "listFineTuningEvents": <Config extends OperationConfig>(fineTuningJobId: string, options: { readonly params?: typeof ListFineTuningEventsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListFineTuningEvents200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists the currently available models, and provides basic information about each one such as the owner and availability.
*/
readonly "listModels": <Config extends OperationConfig>(options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListModels200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
*/
readonly "retrieveModel": <Config extends OperationConfig>(model: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveModel200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List organization API keys
*/
readonly "adminApiKeysList": <Config extends OperationConfig>(options: { readonly params?: typeof AdminApiKeysListParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof AdminApiKeysList200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieve a single organization API key
*/
readonly "adminApiKeysGet": <Config extends OperationConfig>(keyId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof AdminApiKeysGet200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List user actions and configuration changes within this organization.
*/
readonly "listAuditLogs": <Config extends OperationConfig>(options: { readonly params?: typeof ListAuditLogsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListAuditLogs200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List uploaded certificates for this organization.
*/
readonly "listOrganizationCertificates": <Config extends OperationConfig>(options: { readonly params?: typeof ListOrganizationCertificatesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListOrganizationCertificates200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get a certificate that has been uploaded to the organization.
* 
* You can get a certificate regardless of whether it is active or not.
*/
readonly "getCertificate": <Config extends OperationConfig>(certificateId: string, options: { readonly params?: typeof GetCertificateParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetCertificate200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get costs details for the organization.
*/
readonly "usageCosts": <Config extends OperationConfig>(options: { readonly params: typeof UsageCostsParams.Encoded; readonly config?: Config | undefined }) => Effect.Effect<WithOptionalResponse<typeof UsageCosts200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists all groups in the organization.
*/
readonly "listGroups": <Config extends OperationConfig>(options: { readonly params?: typeof ListGroupsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListGroups200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists the organization roles assigned to a group within the organization.
*/
readonly "listGroupRoleAssignments": <Config extends OperationConfig>(groupId: string, options: { readonly params?: typeof ListGroupRoleAssignmentsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListGroupRoleAssignments200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists the users assigned to a group.
*/
readonly "listGroupUsers": <Config extends OperationConfig>(groupId: string, options: { readonly params?: typeof ListGroupUsersParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListGroupUsers200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of invites in the organization.
*/
readonly "listInvites": <Config extends OperationConfig>(options: { readonly params?: typeof ListInvitesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListInvites200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves an invite.
*/
readonly "retrieveInvite": <Config extends OperationConfig>(inviteId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveInvite200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of projects.
*/
readonly "listProjects": <Config extends OperationConfig>(options: { readonly params?: typeof ListProjectsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListProjects200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a project.
*/
readonly "retrieveProject": <Config extends OperationConfig>(projectId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveProject200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of API keys in the project.
*/
readonly "listProjectApiKeys": <Config extends OperationConfig>(projectId: string, options: { readonly params?: typeof ListProjectApiKeysParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListProjectApiKeys200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves an API key in the project.
*/
readonly "retrieveProjectApiKey": <Config extends OperationConfig>(projectId: string, keyId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveProjectApiKey200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List certificates for this project.
*/
readonly "listProjectCertificates": <Config extends OperationConfig>(projectId: string, options: { readonly params?: typeof ListProjectCertificatesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListProjectCertificates200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists the groups that have access to a project.
*/
readonly "listProjectGroups": <Config extends OperationConfig>(projectId: string, options: { readonly params?: typeof ListProjectGroupsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListProjectGroups200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns the rate limits per model for a project.
*/
readonly "listProjectRateLimits": <Config extends OperationConfig>(projectId: string, options: { readonly params?: typeof ListProjectRateLimitsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListProjectRateLimits200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of service accounts in the project.
*/
readonly "listProjectServiceAccounts": <Config extends OperationConfig>(projectId: string, options: { readonly params?: typeof ListProjectServiceAccountsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListProjectServiceAccounts200.Type, Config>, HttpClientError.HttpClientError | SchemaError | TestClientError<"ListProjectServiceAccounts400", typeof ListProjectServiceAccounts400.Type>>
  /**
* Retrieves a service account in the project.
*/
readonly "retrieveProjectServiceAccount": <Config extends OperationConfig>(projectId: string, serviceAccountId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveProjectServiceAccount200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of users in the project.
*/
readonly "listProjectUsers": <Config extends OperationConfig>(projectId: string, options: { readonly params?: typeof ListProjectUsersParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListProjectUsers200.Type, Config>, HttpClientError.HttpClientError | SchemaError | TestClientError<"ListProjectUsers400", typeof ListProjectUsers400.Type>>
  /**
* Retrieves a user in the project.
*/
readonly "retrieveProjectUser": <Config extends OperationConfig>(projectId: string, userId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveProjectUser200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists the roles configured for the organization.
*/
readonly "listRoles": <Config extends OperationConfig>(options: { readonly params?: typeof ListRolesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListRoles200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get audio speeches usage details for the organization.
*/
readonly "usageAudioSpeeches": <Config extends OperationConfig>(options: { readonly params: typeof UsageAudioSpeechesParams.Encoded; readonly config?: Config | undefined }) => Effect.Effect<WithOptionalResponse<typeof UsageAudioSpeeches200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get audio transcriptions usage details for the organization.
*/
readonly "usageAudioTranscriptions": <Config extends OperationConfig>(options: { readonly params: typeof UsageAudioTranscriptionsParams.Encoded; readonly config?: Config | undefined }) => Effect.Effect<WithOptionalResponse<typeof UsageAudioTranscriptions200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get code interpreter sessions usage details for the organization.
*/
readonly "usageCodeInterpreterSessions": <Config extends OperationConfig>(options: { readonly params: typeof UsageCodeInterpreterSessionsParams.Encoded; readonly config?: Config | undefined }) => Effect.Effect<WithOptionalResponse<typeof UsageCodeInterpreterSessions200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get completions usage details for the organization.
*/
readonly "usageCompletions": <Config extends OperationConfig>(options: { readonly params: typeof UsageCompletionsParams.Encoded; readonly config?: Config | undefined }) => Effect.Effect<WithOptionalResponse<typeof UsageCompletions200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get embeddings usage details for the organization.
*/
readonly "usageEmbeddings": <Config extends OperationConfig>(options: { readonly params: typeof UsageEmbeddingsParams.Encoded; readonly config?: Config | undefined }) => Effect.Effect<WithOptionalResponse<typeof UsageEmbeddings200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get images usage details for the organization.
*/
readonly "usageImages": <Config extends OperationConfig>(options: { readonly params: typeof UsageImagesParams.Encoded; readonly config?: Config | undefined }) => Effect.Effect<WithOptionalResponse<typeof UsageImages200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get moderations usage details for the organization.
*/
readonly "usageModerations": <Config extends OperationConfig>(options: { readonly params: typeof UsageModerationsParams.Encoded; readonly config?: Config | undefined }) => Effect.Effect<WithOptionalResponse<typeof UsageModerations200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get vector stores usage details for the organization.
*/
readonly "usageVectorStores": <Config extends OperationConfig>(options: { readonly params: typeof UsageVectorStoresParams.Encoded; readonly config?: Config | undefined }) => Effect.Effect<WithOptionalResponse<typeof UsageVectorStores200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists all of the users in the organization.
*/
readonly "listUsers": <Config extends OperationConfig>(options: { readonly params?: typeof ListUsersParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListUsers200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a user by their identifier.
*/
readonly "retrieveUser": <Config extends OperationConfig>(userId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveUser200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists the organization roles assigned to a user within the organization.
*/
readonly "listUserRoleAssignments": <Config extends OperationConfig>(userId: string, options: { readonly params?: typeof ListUserRoleAssignmentsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListUserRoleAssignments200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists the project roles assigned to a group within a project.
*/
readonly "listProjectGroupRoleAssignments": <Config extends OperationConfig>(projectId: string, groupId: string, options: { readonly params?: typeof ListProjectGroupRoleAssignmentsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListProjectGroupRoleAssignments200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists the roles configured for a project.
*/
readonly "listProjectRoles": <Config extends OperationConfig>(projectId: string, options: { readonly params?: typeof ListProjectRolesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListProjectRoles200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Lists the project roles assigned to a user within a project.
*/
readonly "listProjectUserRoleAssignments": <Config extends OperationConfig>(projectId: string, userId: string, options: { readonly params?: typeof ListProjectUserRoleAssignmentsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListProjectUserRoleAssignments200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a model response with the given ID.
*/
readonly "getResponse": <Config extends OperationConfig>(responseId: string, options: { readonly params?: typeof GetResponseParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetResponse200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of input items for a given response.
*/
readonly "listInputItems": <Config extends OperationConfig>(responseId: string, options: { readonly params?: typeof ListInputItemsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListInputItems200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a thread.
*/
readonly "getThread": <Config extends OperationConfig>(threadId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetThread200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of messages for a given thread.
*/
readonly "listMessages": <Config extends OperationConfig>(threadId: string, options: { readonly params?: typeof ListMessagesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListMessages200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieve a message.
*/
readonly "getMessage": <Config extends OperationConfig>(threadId: string, messageId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetMessage200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of runs belonging to a thread.
*/
readonly "listRuns": <Config extends OperationConfig>(threadId: string, options: { readonly params?: typeof ListRunsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListRuns200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a run.
*/
readonly "getRun": <Config extends OperationConfig>(threadId: string, runId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetRun200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of run steps belonging to a run.
*/
readonly "listRunSteps": <Config extends OperationConfig>(threadId: string, runId: string, options: { readonly params?: typeof ListRunStepsParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListRunSteps200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a run step.
*/
readonly "getRunStep": <Config extends OperationConfig>(threadId: string, runId: string, stepId: string, options: { readonly params?: typeof GetRunStepParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetRunStep200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of vector stores.
*/
readonly "listVectorStores": <Config extends OperationConfig>(options: { readonly params?: typeof ListVectorStoresParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListVectorStores200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a vector store.
*/
readonly "getVectorStore": <Config extends OperationConfig>(vectorStoreId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetVectorStore200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a vector store file batch.
*/
readonly "getVectorStoreFileBatch": <Config extends OperationConfig>(vectorStoreId: string, batchId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetVectorStoreFileBatch200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of vector store files in a batch.
*/
readonly "listFilesInVectorStoreBatch": <Config extends OperationConfig>(vectorStoreId: string, batchId: string, options: { readonly params?: typeof ListFilesInVectorStoreBatchParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListFilesInVectorStoreBatch200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Returns a list of vector store files.
*/
readonly "listVectorStoreFiles": <Config extends OperationConfig>(vectorStoreId: string, options: { readonly params?: typeof ListVectorStoreFilesParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListVectorStoreFiles200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieves a vector store file.
*/
readonly "getVectorStoreFile": <Config extends OperationConfig>(vectorStoreId: string, fileId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetVectorStoreFile200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieve the parsed contents of a vector store file.
*/
readonly "retrieveVectorStoreFileContent": <Config extends OperationConfig>(vectorStoreId: string, fileId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveVectorStoreFileContent200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Get a conversation
*/
readonly "getConversation": <Config extends OperationConfig>(conversationId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetConversation200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List videos
*/
readonly "ListVideos": <Config extends OperationConfig>(options: { readonly params?: typeof ListVideosParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListVideos200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieve a video
*/
readonly "GetVideo": <Config extends OperationConfig>(videoId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetVideo200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Download video content
*/
readonly "RetrieveVideoContent": <Config extends OperationConfig>(videoId: string, options: { readonly params?: typeof RetrieveVideoContentParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof RetrieveVideoContent200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List ChatKit thread items
*/
readonly "ListThreadItemsMethod": <Config extends OperationConfig>(threadId: string, options: { readonly params?: typeof ListThreadItemsMethodParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListThreadItemsMethod200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* Retrieve a ChatKit thread
*/
readonly "GetThreadMethod": <Config extends OperationConfig>(threadId: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetThreadMethod200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
  /**
* List ChatKit threads
*/
readonly "ListThreadsMethod": <Config extends OperationConfig>(options: { readonly params?: typeof ListThreadsMethodParams.Encoded | undefined; readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof ListThreadsMethod200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
}

export interface TestClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class TestClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const TestClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): TestClientError<Tag, E> =>
  new TestClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any"
`;

exports[`OpenApiGenerator > identifier sanitization > handles collision when sanitized name already exists 2`] = `
"import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type { SchemaError } from "effect/Schema"
import * as Schema from "effect/Schema"
import type * as HttpClient from "effect/unstable/http/HttpClient"
import * as HttpClientError from "effect/unstable/http/HttpClientError"
import * as HttpClientRequest from "effect/unstable/http/HttpClientRequest"
import * as HttpClientResponse from "effect/unstable/http/HttpClientResponse"
// schemas
export type GetUser200 = { readonly "id": string, readonly "name": string }
export const GetUser200 = Schema.Struct({ "id": Schema.String, "name": Schema.String }).annotate({ "description": "User object" })

export interface OperationConfig {
  /**
   * Whether or not the response should be included in the value returned from
   * an operation.
   *
   * If set to \`true\`, a tuple of \`[A, HttpClientResponse]\` will be returned,
   * where \`A\` is the success type of the operation.
   *
   * If set to \`false\`, only the success type of the operation will be returned.
   */
  readonly includeResponse?: boolean | undefined
}

/**
 * A utility type which optionally includes the response in the return result
 * of an operation based upon the value of the \`includeResponse\` configuration
 * option.
 */
export type WithOptionalResponse<A, Config extends OperationConfig> = Config extends {
  readonly includeResponse: true
} ? [A, HttpClientResponse.HttpClientResponse] : A

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): TestClient => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse = <Config extends OperationConfig>(config: Config | undefined) => <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ): (request: HttpClientRequest.HttpClientRequest) => Effect.Effect<any, any> => {
    const withOptionalResponse = (
      config?.includeResponse
        ? (response: HttpClientResponse.HttpClientResponse) => Effect.map(f(response), (a) => [a, response])
        : (response: HttpClientResponse.HttpClientResponse) => f(response)
    ) as any
    return options?.transformClient
      ? (request) =>
          Effect.flatMap(
            Effect.flatMap(options.transformClient!(httpClient), (client) => client.execute(request)),
            withOptionalResponse
          )
      : (request) => Effect.flatMap(httpClient.execute(request), withOptionalResponse)
  }
  const decodeSuccess =
    <Schema extends Schema.Top>(schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, Schema extends Schema.Top>(tag: Tag, schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(TestClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "getUser": (id, options) => HttpClientRequest.get(\`/users/\${id}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetUser200),
      orElse: unexpectedStatus
    }))
  )
  }
}

export interface TestClient {
  readonly httpClient: HttpClient.HttpClient
  readonly "getUser": <Config extends OperationConfig>(id: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetUser200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
}

export interface TestClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class TestClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const TestClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): TestClientError<Tag, E> =>
  new TestClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any"
`;

exports[`OpenApiGenerator > identifier sanitization > handles collision when sanitized name already exists 3`] = `
"import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type * as HttpClient from "effect/unstable/http/HttpClient"
import * as HttpClientError from "effect/unstable/http/HttpClientError"
import * as HttpClientRequest from "effect/unstable/http/HttpClientRequest"
import * as HttpClientResponse from "effect/unstable/http/HttpClientResponse"
// schemas
export type GetUser200 = { readonly "id": string, readonly "name": string }

export interface OperationConfig {
  /**
   * Whether or not the response should be included in the value returned from
   * an operation.
   *
   * If set to \`true\`, a tuple of \`[A, HttpClientResponse]\` will be returned,
   * where \`A\` is the success type of the operation.
   *
   * If set to \`false\`, only the success type of the operation will be returned.
   */
  readonly includeResponse?: boolean | undefined
}

/**
 * A utility type which optionally includes the response in the return result
 * of an operation based upon the value of the \`includeResponse\` configuration
 * option.
 */
export type WithOptionalResponse<A, Config extends OperationConfig> = Config extends {
  readonly includeResponse: true
} ? [A, HttpClientResponse.HttpClientResponse] : A

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): TestClient => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse = <Config extends OperationConfig>(config: Config | undefined) => <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ): (request: HttpClientRequest.HttpClientRequest) => Effect.Effect<any, any> => {
    const withOptionalResponse = (
      config?.includeResponse
        ? (response: HttpClientResponse.HttpClientResponse) => Effect.map(f(response), (a) => [a, response])
        : (response: HttpClientResponse.HttpClientResponse) => f(response)
    ) as any
    return options?.transformClient
      ? (request) =>
          Effect.flatMap(
            Effect.flatMap(options.transformClient!(httpClient), (client) => client.execute(request)),
            withOptionalResponse
          )
      : (request) => Effect.flatMap(httpClient.execute(request), withOptionalResponse)
  }
  const decodeSuccess = <A>(response: HttpClientResponse.HttpClientResponse) =>
    response.json as Effect.Effect<A, HttpClientError.ResponseError>
  const decodeVoid = (_response: HttpClientResponse.HttpClientResponse) =>
    Effect.void
  const decodeError =
    <Tag extends string, E>(tag: Tag) =>
    (
      response: HttpClientResponse.HttpClientResponse,
    ): Effect.Effect<
      never,
      TestClientError<Tag, E> | HttpClientError.ResponseError
    > =>
      Effect.flatMap(
        response.json as Effect.Effect<E, HttpClientError.ResponseError>,
        (cause) => Effect.fail(TestClientError(tag, cause, response)),
      )
  const onRequest = <Config extends OperationConfig>(config: Config | undefined) => (
    successCodes: ReadonlyArray<string>,
    errorCodes?: Record<string, string>,
  ) => {
    const cases: any = { orElse: unexpectedStatus }
    for (const code of successCodes) {
      cases[code] = decodeSuccess
    }
    if (errorCodes) {
      for (const [code, tag] of Object.entries(errorCodes)) {
        cases[code] = decodeError(tag)
      }
    }
    if (successCodes.length === 0) {
      cases["2xx"] = decodeVoid
    }
    return withResponse(config)(HttpClientResponse.matchStatus(cases) as any)
  }
  return {
    httpClient,
    "getUser": (id, options) => HttpClientRequest.get(\`/users/\${id}\`).pipe(
    onRequest(options?.config)(["2xx"])
  )
  }
}

export interface TestClient {
  readonly httpClient: HttpClient.HttpClient
  readonly "getUser": <Config extends OperationConfig>(id: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<GetUser200, Config>, HttpClientError.HttpClientError>
}

export interface TestClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class TestClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const TestClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): TestClientError<Tag, E> =>
  new TestClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any"
`;

exports[`OpenApiGenerator > identifier sanitization > handles collision when sanitized name already exists 4`] = `
"import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type { SchemaError } from "effect/Schema"
import * as Schema from "effect/Schema"
import type * as HttpClient from "effect/unstable/http/HttpClient"
import * as HttpClientError from "effect/unstable/http/HttpClientError"
import * as HttpClientRequest from "effect/unstable/http/HttpClientRequest"
import * as HttpClientResponse from "effect/unstable/http/HttpClientResponse"
// non-recursive definitions
export type Conversation_2 = { readonly "id"?: string, readonly [x: string]: unknown }
export const Conversation_2 = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "Conversation ID" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A conversation object", "identifier": "Conversation-2" })
export type Error_2 = { readonly "code"?: string, readonly "message"?: string, readonly [x: string]: unknown }
export const Error_2 = Schema.StructWithRest(Schema.Struct({ "code": Schema.optionalKey(Schema.String.annotate({ "description": "Error code" })), "message": Schema.optionalKey(Schema.String.annotate({ "description": "Error message" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "An error object", "identifier": "Error-2" })
// schemas
export type GetUser200 = { readonly "id": string, readonly "name": string }
export const GetUser200 = Schema.Struct({ "id": Schema.String, "name": Schema.String }).annotate({ "description": "User object" })

export interface OperationConfig {
  /**
   * Whether or not the response should be included in the value returned from
   * an operation.
   *
   * If set to \`true\`, a tuple of \`[A, HttpClientResponse]\` will be returned,
   * where \`A\` is the success type of the operation.
   *
   * If set to \`false\`, only the success type of the operation will be returned.
   */
  readonly includeResponse?: boolean | undefined
}

/**
 * A utility type which optionally includes the response in the return result
 * of an operation based upon the value of the \`includeResponse\` configuration
 * option.
 */
export type WithOptionalResponse<A, Config extends OperationConfig> = Config extends {
  readonly includeResponse: true
} ? [A, HttpClientResponse.HttpClientResponse] : A

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): TestClient => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse = <Config extends OperationConfig>(config: Config | undefined) => <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ): (request: HttpClientRequest.HttpClientRequest) => Effect.Effect<any, any> => {
    const withOptionalResponse = (
      config?.includeResponse
        ? (response: HttpClientResponse.HttpClientResponse) => Effect.map(f(response), (a) => [a, response])
        : (response: HttpClientResponse.HttpClientResponse) => f(response)
    ) as any
    return options?.transformClient
      ? (request) =>
          Effect.flatMap(
            Effect.flatMap(options.transformClient!(httpClient), (client) => client.execute(request)),
            withOptionalResponse
          )
      : (request) => Effect.flatMap(httpClient.execute(request), withOptionalResponse)
  }
  const decodeSuccess =
    <Schema extends Schema.Top>(schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, Schema extends Schema.Top>(tag: Tag, schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(TestClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "getUser": (id, options) => HttpClientRequest.get(\`/users/\${id}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetUser200),
      orElse: unexpectedStatus
    }))
  )
  }
}

export interface TestClient {
  readonly httpClient: HttpClient.HttpClient
  readonly "getUser": <Config extends OperationConfig>(id: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetUser200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
}

export interface TestClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class TestClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const TestClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): TestClientError<Tag, E> =>
  new TestClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any"
`;

exports[`OpenApiGenerator > identifier sanitization > handles collision when sanitized name already exists 5`] = `
"import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type { SchemaError } from "effect/Schema"
import * as Schema from "effect/Schema"
import type * as HttpClient from "effect/unstable/http/HttpClient"
import * as HttpClientError from "effect/unstable/http/HttpClientError"
import * as HttpClientRequest from "effect/unstable/http/HttpClientRequest"
import * as HttpClientResponse from "effect/unstable/http/HttpClientResponse"
// non-recursive definitions
export type Conversation2 = { readonly "id"?: string, readonly [x: string]: unknown }
export const Conversation2 = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String.annotate({ "description": "ID" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "First conversation", "identifier": "Conversation2" })
export type Conversation_2 = { readonly "name"?: string, readonly [x: string]: unknown }
export const Conversation_2 = Schema.StructWithRest(Schema.Struct({ "name": Schema.optionalKey(Schema.String.annotate({ "description": "Name" })) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Second conversation (will be renamed to avoid collision)", "identifier": "Conversation-2" })
// schemas
export type GetUser200 = { readonly "id": string, readonly "name": string }
export const GetUser200 = Schema.Struct({ "id": Schema.String, "name": Schema.String }).annotate({ "description": "User object" })

export interface OperationConfig {
  /**
   * Whether or not the response should be included in the value returned from
   * an operation.
   *
   * If set to \`true\`, a tuple of \`[A, HttpClientResponse]\` will be returned,
   * where \`A\` is the success type of the operation.
   *
   * If set to \`false\`, only the success type of the operation will be returned.
   */
  readonly includeResponse?: boolean | undefined
}

/**
 * A utility type which optionally includes the response in the return result
 * of an operation based upon the value of the \`includeResponse\` configuration
 * option.
 */
export type WithOptionalResponse<A, Config extends OperationConfig> = Config extends {
  readonly includeResponse: true
} ? [A, HttpClientResponse.HttpClientResponse] : A

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): TestClient => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse = <Config extends OperationConfig>(config: Config | undefined) => <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ): (request: HttpClientRequest.HttpClientRequest) => Effect.Effect<any, any> => {
    const withOptionalResponse = (
      config?.includeResponse
        ? (response: HttpClientResponse.HttpClientResponse) => Effect.map(f(response), (a) => [a, response])
        : (response: HttpClientResponse.HttpClientResponse) => f(response)
    ) as any
    return options?.transformClient
      ? (request) =>
          Effect.flatMap(
            Effect.flatMap(options.transformClient!(httpClient), (client) => client.execute(request)),
            withOptionalResponse
          )
      : (request) => Effect.flatMap(httpClient.execute(request), withOptionalResponse)
  }
  const decodeSuccess =
    <Schema extends Schema.Top>(schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, Schema extends Schema.Top>(tag: Tag, schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(TestClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "getUser": (id, options) => HttpClientRequest.get(\`/users/\${id}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetUser200),
      orElse: unexpectedStatus
    }))
  )
  }
}

export interface TestClient {
  readonly httpClient: HttpClient.HttpClient
  readonly "getUser": <Config extends OperationConfig>(id: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetUser200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
}

export interface TestClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class TestClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const TestClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): TestClientError<Tag, E> =>
  new TestClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any"
`;

exports[`OpenApiGenerator > identifier sanitization > preserves valid schema names unchanged 1`] = `
"import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type { SchemaError } from "effect/Schema"
import * as Schema from "effect/Schema"
import type * as HttpClient from "effect/unstable/http/HttpClient"
import * as HttpClientError from "effect/unstable/http/HttpClientError"
import * as HttpClientRequest from "effect/unstable/http/HttpClientRequest"
import * as HttpClientResponse from "effect/unstable/http/HttpClientResponse"
// non-recursive definitions
export type ValidName = { readonly "id"?: string, readonly [x: string]: unknown }
export const ValidName = Schema.StructWithRest(Schema.Struct({ "id": Schema.optionalKey(Schema.String) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "A valid schema name", "identifier": "ValidName" })
export type AnotherValidName123 = { readonly "value"?: number, readonly [x: string]: unknown }
export const AnotherValidName123 = Schema.StructWithRest(Schema.Struct({ "value": Schema.optionalKey(Schema.Number.check(Schema.isFinite())) }), [Schema.Record(Schema.String, Schema.Unknown)]).annotate({ "description": "Another valid schema name", "identifier": "AnotherValidName123" })
// schemas
export type GetUser200 = { readonly "id": string, readonly "name": string }
export const GetUser200 = Schema.Struct({ "id": Schema.String, "name": Schema.String }).annotate({ "description": "User object" })

export interface OperationConfig {
  /**
   * Whether or not the response should be included in the value returned from
   * an operation.
   *
   * If set to \`true\`, a tuple of \`[A, HttpClientResponse]\` will be returned,
   * where \`A\` is the success type of the operation.
   *
   * If set to \`false\`, only the success type of the operation will be returned.
   */
  readonly includeResponse?: boolean | undefined
}

/**
 * A utility type which optionally includes the response in the return result
 * of an operation based upon the value of the \`includeResponse\` configuration
 * option.
 */
export type WithOptionalResponse<A, Config extends OperationConfig> = Config extends {
  readonly includeResponse: true
} ? [A, HttpClientResponse.HttpClientResponse] : A

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): TestClient => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse = <Config extends OperationConfig>(config: Config | undefined) => <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ): (request: HttpClientRequest.HttpClientRequest) => Effect.Effect<any, any> => {
    const withOptionalResponse = (
      config?.includeResponse
        ? (response: HttpClientResponse.HttpClientResponse) => Effect.map(f(response), (a) => [a, response])
        : (response: HttpClientResponse.HttpClientResponse) => f(response)
    ) as any
    return options?.transformClient
      ? (request) =>
          Effect.flatMap(
            Effect.flatMap(options.transformClient!(httpClient), (client) => client.execute(request)),
            withOptionalResponse
          )
      : (request) => Effect.flatMap(httpClient.execute(request), withOptionalResponse)
  }
  const decodeSuccess =
    <Schema extends Schema.Top>(schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, Schema extends Schema.Top>(tag: Tag, schema: Schema) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(TestClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "getUser": (id, options) => HttpClientRequest.get(\`/users/\${id}\`).pipe(
    withResponse(options?.config)(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(GetUser200),
      orElse: unexpectedStatus
    }))
  )
  }
}

export interface TestClient {
  readonly httpClient: HttpClient.HttpClient
  readonly "getUser": <Config extends OperationConfig>(id: string, options: { readonly config?: Config | undefined } | undefined) => Effect.Effect<WithOptionalResponse<typeof GetUser200.Type, Config>, HttpClientError.HttpClientError | SchemaError>
}

export interface TestClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class TestClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const TestClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): TestClientError<Tag, E> =>
  new TestClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any"
`;
